#+TITLE: gyokaikyor プロジェクトノート
#+PROPERTY: header-args :exports code :results scalar :session *R:gyokaikyor*
#+STARTUP: contents

* 目次                                                                :TOC_3:
- [[#これは何か][これは何か？]]
- [[#レガシーファイル構成を整理する][レガシーファイル構成を整理する]]
  - [[#カタクチyyxlsx][★カタクチYY.xlsx]]
    - [[#ファイルがやっていること][ファイルがやっていること]]
    - [[#問題点][問題点]]
    - [[#解決策][解決策]]
  - [[#カタクチ月別県別漁獲量xlsx][★カタクチ月別県別漁獲量.xlsx]]
    - [[#ファイル中での作業][ファイル中での作業]]
  - [[#各県いわし][各県いわし]]
- [[#ディレクトリの構成][ディレクトリの構成]]
- [[#パッケージの機能][パッケージの機能]]
  - [[#データ目録の生成][データ目録の生成]]
  - [[#データの統合][データの統合]]
  - [[#グラフ描画][グラフ描画]]
  - [[#予報文案テンプレートの生成][予報文案テンプレートの生成]]
- [[#デモ][デモ]]
  - [[#体長組成][体長組成]]
  - [[#漁獲量][漁獲量]]
- [[#開発環境の整備][開発環境の整備]]
  - [[#本バッケージ内部で使用するパッケージ][本バッケージ内部で使用するパッケージ]]
- [[#開発][開発]]
  - [[#各県ファイルに対して必要な処理概要][各県ファイルに対して必要な処理概要]]
    - [[#体長][体長]]
    - [[#漁獲量-1][漁獲量]]
  - [[#どう問題を解くか][どう問題を解くか]]
    - [[#get_topleftkey--flmm][get_topleft(key = "FL(mm)")]]
  - [[#リロード--自動テスト][リロード & 自動テスト]]
  - [[#テストコード][テストコード]]
    - [[#テスト-ファイル名操作][テスト/ ファイル名操作]]
    - [[#テスト-セル位置取得][テスト/ セル位置取得]]
    - [[#テスト-文字列操作][テスト/ 文字列操作]]
    - [[#テスト-種名生成][テスト/ 種名生成]]
    - [[#テスト-計測データ取得][テスト/ 計測データ取得]]
    - [[#テスト-体長データ整形][テスト/ 体長データ整形]]
    - [[#テスト-漁獲量データ整形][テスト/ 漁獲量データ整形]]
  - [[#関数][関数]]
    - [[#インポート][インポート]]
    - [[#ファイル名操作][ファイル名操作]]
    - [[#セル位置取得][セル位置取得]]
    - [[#文字列操作][文字列操作]]
    - [[#種名シート名生成][種名シート名生成]]
    - [[#データ取得][データ取得]]
    - [[#体長データ整形][体長データ整形]]
    - [[#漁獲量データ整形][漁獲量データ整形]]

* これは何か？
漁海況業務のリポジトリ．
主にRのパッケージ開発のコミュニケーション用．

* レガシーファイル構成を整理する
** ★カタクチYY.xlsx
*** ファイルがやっていること
各県の月別体長組成を統合し，
- 東シナ海
- 日本海
- 計
というシートで統合する Excel ファイル．
*** 問題点
- バイナリなのでバージョン管理ができない
- 資源評価と漁海況の両方で使用されるが，両業務で集計方法が異なるので紛らわしい．
*** 解決策
2段階の抽象度（精密測定 & 体長組成）で体長整理する．
- 精密データを提出する県については，県ごとに csv 形式の精密測定データベースを作成する．
- 精密はなく，体長組成データを提出する県については，県ごとにcsv 型式の体長組成データベースを作成する．
- 精密・体長各データベースから範囲を指定して体長階級×月形式のテーブルを作成できるようにする．

使用イメージ
#+BEGIN_SRC R :exports code :results silent
kumamoto    <- fmt_bl("./data.git/漁海況/2018年10月/各県資料/熊本県", gyokaikyo = TRUE, plot = TRUE)
db_kumamoto <- read_csv("./output.git/kumamoto_2018oct.csv")
out         <- bind_rows(db_kumamoto, kumamoto)
write.csv(out, "./output.git/kumamoto_2019mar.csv", row.names = FALSE)

get_table("./output.git/nagasaki_2018oct.csv", gyokaikyo = TRUE, start = 2016, end = 2017)
#+END_SRC
**** なぜデータベースか？
過去のデータが報告なしに更新されていた場合に対処するため
**** なぜ県ごとか？
差分管理を確実に実施するため
** ★カタクチ月別県別漁獲量.xlsx
*** ファイル中での作業
**** 各県の月別漁獲量データを手作業で整形
**** "集計"というシートに各県のデータを貼り付け，月別組成を得る
**** 単位をトンに揃えて農林統計の値で引き伸ばす
**** 「しらす」については月別には集計せず，農林統計で引き伸ばす

** 各県いわし
* ディレクトリの構成
R パッケージのディレクトリは全て GitHub で公開する．
ただし，以下のディレクトリは GitHub にはアップロードせず，ローカルで管理する（リモートリポジトリを GitHub ではなく，NAS に設定する）．
- data.git/: 各県から提供されたデータ．
- docs.git/: 予報文案など．
  
* パッケージの機能
** データ目録の生成
** データの統合
** グラフ描画
- 漁獲量
- 体長組成
** 予報文案テンプレートの生成
何らかの構造化マークアップ言語の形式で．
できるだけタグが短いもの．
マークダウンが有力か？
* デモ
** 体長組成
#+BEGIN_SRC R
  library(gyokaikyor)
  library(hash)
  library(ggplot2)
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/04 【熊本県】H29まき網＆棒受網 体長組成.xlsx")
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/04_H30_まき網＆棒受網体長組成.xlsx",
              "data.git/漁海況/2018年3月/各県資料/長崎県/2017.09-2018.01小型まき網体長組成.xls",
              "data.git/漁海況/2018年3月/各県資料/鹿児島県/体長組成(H29年度).xlsx")
  prefec <- c("kumamoto", "nagasaki", "kagoshima")
  tbl_fname <- hash(fname, prefec)

  fname2 <- give_class(fname, tbl_fname)
  fname2[[1]]
  fname2[[2]]
  fname2[[3]]

  kumamoto_nested <- fmtbl(fname2[[1]], spcs = "katakuchi")
  kumamoto        <- fmtbl(fname2[[1]], spcs = "katakuchi", nest = FALSE)
  kumamoto        <- fmtbl(fname2[[1]], spcs = "maiwashi", nest = FALSE)
  nagasaki_nested <- fmtbl(fname2[[2]], spcs = "katakuchi")
  nagasaki        <- fmtbl(fname2[[2]], spcs = "katakuchi", nest = FALSE)
  kagoshima_nested <- fmtbl(fname2[[3]], spcs = "katakuchi")
  kagoshima        <- fmtbl(fname2[[3]], spcs = "katakuchi", nest = FALSE)

  kumamoto %>%
    ggplot(aes(bl, fill = as.factor(month))) +
    geom_histogram() +
    facet_grid(month ~ year, scale = "free_y")

#+END_SRC
** 漁獲量
#+BEGIN_SRC R
  library(hash)
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/03_漁獲努力量（1804~1903）（熊本県）.xls",
              "data.git/漁海況/2018年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls",
             "./data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls",
             "./data.git/漁海況/2019年3月/各県資料/長崎県/奈留漁協ｲﾜｼ類（中小旋）とりまとめ.xlsx",
             "./data.git/漁海況/2019年3月/各県資料/長崎県/九十九島漁協ｲﾜｼ類(中小まき)とりまとめ.xlsx",
              "data.git/漁海況/2018年3月/各県資料/鹿児島県/４港月計表（29年度）.xlsx")
  prefec <- c("kumamoto", rep("nagasaki", 4), "kagoshima")
  tbl_fname <- hash(fname, prefec)

  fname2 <- give_class(fname, tbl_fname)
  fname2[[1]]
  fname2[[2]]
  fname2[[3]]
  fname2[[4]]
  fname2[[5]]
  fname2[[6]]

  spcs <- "katakuchi"

  #fmtcatch(fname2[[1]], spcs = spcs)
  fmtcatch(fname2[[2]], spcs = spcs)
  fmtcatch(fname2[[3]], spcs = spcs)
  fmtcatch(fname2[[4]], spcs = spcs)
  fmtcatch(fname2[[5]], spcs = spcs)
  fmtcatch(fname2[[6]], spcs = spcs)

  paths <- c("./data.git/漁海況/2019年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls",

  ngs <- fmtcatch.nagasaki(paths[1], "katakuchi")
  tbn <- fmtcatch.nagasaki(paths[2], "katakuchi")
  nr  <- fmtcatch.nagasaki(paths[3], "katakuchi")
  kjk <- fmtcatch.nagasaki(paths[4], "katakuchi")
  nagasaki <- dplyr::bind_rows(ngs, tbn, nr, kjk)
  nagasaki %>% dplyr::filter(year == 1)
  nagasaki %>% dplyr::filter(is.na(port)) %>% data.frame()
  unique(nagasaki$port)

  nagasaki %>% ggplot(aes(month, catch, color = port)) +
    geom_line() +
    facet_wrap(~ year)

  path <- "./data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls"
  sheet <- "2006.02-2006.08"
#+END_SRC
* 開発環境の整備
#+BEGIN_SRC R :results silent
  # usethis::create_package("gyokaikyor")
    usethis::use_mit_license("Akira Hayashi")
    usethis::use_coverage(type = "codecov")
    usethis::use_lifecycle_badge("experimental")
#+END_SRC
** 本バッケージ内部で使用するパッケージ
#+BEGIN_SRC R :results silent
  usethis::use_package("magrittr", "Imports")
  usethis::use_package("hash")
  usethis::use_package("tibble")
  usethis::use_package("cellranger")
  usethis::use_package("tidyr")
  usethis::use_package("lubridate")
  usethis::use_package("readxl")
  usethis::use_package("readr")
  usethis::use_package("stringr")
  usethis::use_package("purrr")
  usethis::use_dev_package("tinyplyr")
  usethis::use_package("Nippon")
  usethis::use_package("dplyr")
  # usethis::use_package("ggplot2", "Imports")
  # usethis::use_package("tibble", "Imports")
  usethis::use_testthat()
  usethis::use_pipe()
#+END_SRC

#+BEGIN_SRC sh :exports results :session nil
cat DESCRIPTION
#+END_SRC

#+RESULTS[26e6d91ffe9c3ff5d95f888fb0006e9154a02abb]:
#+begin_example

Package: gyokaikyor
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person(given = "First",
           family = "Last",
           role = c("aut", "cre"),
           email = "first.last@example.com")
Description: What the package does (one paragraph).
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
Imports: 
    magrittr,
    hash,
    tibble,
    cellranger,
    tinyplyr,
    tidyr,
    lubridate,
    purrr,
    readxl,
    stringr,
    Nippon,
    dplyr
Suggests: 
    testthat,
    covr
RoxygenNote: 6.1.1
#+end_example

#+BEGIN_SRC sh :exports results :session nil
cat NAMESPACE
#+END_SRC

#+RESULTS:
: 
: Generated by roxygen2: do not edit by hand
: <>%")
: >%")

* 開発
** 各県ファイルに対して必要な処理概要
*** 体長
**** まず県別に整理
***** 山口
fresco
***** 福岡
カタクチ測定なし
***** 佐賀
fresco
***** DONE 長崎
- シートを読み込む．対象は春と秋とで違う．
  - 3月漁海況: 2017.09-2018.01小型まき網体長組成.xls
  - 10月漁海況: 2018.02-2018.08小型まき網体長組成.xls
- 漁法名をF2から取得
***** DONE 熊本
列方向に続いた精密測定データ．
10月漁海況のときには前年ファイルも一緒に送ってくれる．
- 04 【熊本県】H29まき網＆棒受網 体長組成.xlsx を開く <- *4月始まり*
- 「カタクチ」シートを読み込み
- df.out を初期化
- 日付が入った列（H29.4.30形式）を取得
- 漁法名を取得
- できればその他情報も取得（操業海域・陸揚げ港）
- 測定データ（全長・被鱗体長・体重）を取得
- df.out を初期化
- 過去のデータベースに df.out を結合
- 重複除去
- 新データベースをkumamoto_2018Oct.csv として書き出し
***** DONE 鹿児島
- 体長組成(H29年度).xlsx を開く　<- *4月始まり*
- 「ｶﾀｸﾁ」シートを読み込み
- 日付が入った列を取得
- 漁法名などの情報を取得
- 個体数情報を体長階級ブロックごと取得
- 過去のdbに結合...
**** まとめると
精密，体長のような分け方はしないほうが良い．
あくまでも，関数を部品として作り，各県ごとにそれを組み合わせて使う．
強いて分類するなら，以下のようになる．
- 精密タイプ: 熊本
- 体長タイプ: 長崎，鹿児島
- fresco タイプ: 山口，佐賀
**** 必要な部品
***** DONE get_cols2load(regex = , offset = )
***** get_top(regex = )
***** get_left(regex = )
***** get_topleft(regex = )
***** get_bottom(regex = )
***** get_right(regex = )
***** get_bottomright(regex = )
***** parse_jpdate(format = )
***** make_regex(spcs = katakuchi)
*** 漁獲量
**** DONE 鹿児島
***** 「４港計」「阿久根棒受」「内之浦棒受」シートを読み込み
****** 「４港計」シート
******* 第3行からスペース含みの魚種名を探し，列を決定
******* 行オフセット4つの位置にある「４港計」列の値を行方向に12ヶ月分（第5〜16行）取得
****** 「阿久根 or 内之浦棒受」シート
******* 32行目から魚種名を検索して列を決定（行数は変化しない）
******* 行方向に12ヶ月分（第33〜44行），値を取得
**** 長崎
***** 魚種に応じてファイルを読み込み
****** マアジ・サバ類
****** マサバ・ゴマサバ
****** イワシ類
***** シート名を取得
過去全データが期間別にシートを分けて入っている
****** A列から魚種名を取得し，データ行を決定
****** データ行から漁期の最初の月の列を取得
前期と後期とで，エクセル方眼紙の列構成が違うのでこれが必要
****** 漁獲量を取得
とびとびにではあるが，一定の法則で入力されている．
関数で処理．
****** 合計が一致しているかチェック

** どう問題を解くか
県ごとに，どうしてもデータ処理の振る舞いを変える必要がある
そこで， 各県のファイル名に，県名を属性として与える
#+TBLNAME: tbl_fname_prefec
| fname                                    | prefec   |
|------------------------------------------+----------|
| 03 漁獲努力量（1804~1903）（熊本県）.xls | kumamoto |
| 04 漁獲努力量（1704~1803）（熊本県）.xls | kumamoto |

#+TBLNAME: tbl_prefec_key
| prefec   | key.topleft |
|----------+-------------|
| nagasaki | FL(mm)      |


各県のファイル名を fmtbl() に与えると，データ形式に適した形で整形される．
水面下でデータ型式を読みに行き，ファイル名に属性として付与している

fname <- "04 漁獲努力量（1704~1803）（熊本県）.xls"



*** get_topleft(key = "FL(mm)")
** リロード & 自動テスト
#+BEGIN_SRC R :results output
  devtools::load_all()
  system("R CMD INSTALL --preclean --no-multiarch --with-keep.source .")
  devtools::test()
  lintr::lint_package()
  devtools::document(roclets=c('rd', 'collate', 'namespace'))
  devtools::check(args = "--as-cran")
  covr::package_coverage()
#+END_SRC
** テストコード
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** テスト/ ファイル名操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_fname.R
  context("Handle file name")
  fn_kumamoto  <- "04 漁獲努力量（1704~1803）（熊本県）.xls"
  fn_kagoshima <- "体長組成(H29年度).xlsx"
  tbl_fname    <- hash::hash(c(fn_kumamoto, fn_kagoshima),
                             c("kumamoto", "kagoshima"))
  test_that("give_class() gives fname its file format as class", {
    expect_is(give_class(fn_kumamoto, tbl_fname), "list")
    expect_is(give_class(fn_kumamoto, tbl_fname)[[1]], "kumamoto")
    expect_is(give_class(fn_kagoshima, tbl_fname)[[1]], "kagoshima")
  })
#+END_SRC
*** テスト/ セル位置取得
#+BEGIN_SRC R :tangle tests/testthat/test_locate_cellpos.R
  context("Locate cell position")
  library(tibble)
  df <- tribble(~A, ~B, ~C, ~D,
                NA, NA, NA, 1,
                NA, "name", "value", 2,
                "", "foo", 12, 3,
                "", "bar", 123, 4,
                "", "baz", 1234, 5,
                "", "bum", 12345, 6,
                "", "foo", 12, 7)

  test_that("quot_ring() throws value on given quotient ring", {
    expect_equal(quot_ring(0, 3), 3)
    expect_equal(quot_ring(1, 3), 1)
    expect_equal(quot_ring(2, 3), 2)
    expect_equal(quot_ring(0, 5), 5)
    expect_equal(quot_ring(1, 5), 1)
    expect_equal(quot_ring(2, 5), 2)
    expect_equal(quot_ring(3, 5), 3)
    expect_equal(quot_ring(4, 5), 4)
  })

  test_that("quot2col() throws col position from
   quotient of given match position in matrix", {
    expect_equal(quot2col(3, 0), 3)
    expect_equal(quot2col(3, 1), 4)
    expect_equal(quot2col(4, 1), 5)
    expect_equal(quot2col(5, 1), 6)
    expect_equal(quot2col(5, 2), 6)
  })

  test_that("get_locate_patterns() locates cell position that has given regex", {
    expect_equal(locate_patterns(df, "name"), "$B$2")
    expect_equal(locate_patterns(df, "nam."), "$B$2")
    expect_equal(locate_patterns(df, "foo"), c("$B$3", "$B$7"))
  })

  test_that("get_topleft() locates cell position that has given regex", {
    expect_equal(get_topleft(df, "name"), "$B$2")
    expect_equal(get_topleft(df, "nam."), "$B$2")
    expect_equal(get_topleft(df, "foo"), "$B$3")
  })

  test_that("get_bottomright() locates cell position that has given regex", {
    expect_equal(get_bottomright(df, "12345"), "$C$6")
    expect_equal(get_bottomright(df, "foo"), "$B$7")
  })

  test_that("locate_vecend() locates the end of the vector", {
    expect_equal(locate_vecend(c(1:10, NA, NA, NA)), 10)
    expect_equal(locate_vecend(c(rep(NA, 9), 100, NA, NA, NA)), 10)
  })
  #+END_SRC
*** テスト/ 文字列操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_str.R
  context("Handle string")

  target <-
    c("漁獲年月日", "", "2017.4.20", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.5.19", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.6.23", "操業海域", "八代海", "漁法", "まき網")

  test_that("get_col2load() works well",
            expect_equal(get_col2load(target,
                            regex = "20[0-9]{2}\\.[0-9][0-9]?\\.[0-9][0-9]?",
                            offset = -2),
                         c(1, 8, 15))
            )

  test_that("parse_ym() works well", {
    expect_setequal(parse_ym("2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_setequal(parse_ym("foo/bar/2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_error(parse_ym("20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
    expect_error(parse_ym("foo/bar/20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
  })
#+END_SRC
*** テスト/ 種名生成
#+BEGIN_SRC  R :tangle tests/testthat/test_make_shtname.R
  context("Make shtname of prefecture")

  test_that("make_shtname() makes sheetname for kumamoto data", {
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "sabarui"), "サバ類")
    expect_error(make_shtname(prefec = "kumamoto", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for nagasaki data", {
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "masaba"), "マサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "gomasaba"), "ゴマサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maaji"), "マアジ")
    expect_error(make_shtname(prefec = "nagasaki", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for kagoshima data", {
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "katakuchi"), "ｶﾀｸﾁ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "urume"), "ｳﾙﾒ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maiwashi"), "ﾏｲﾜｼ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "masaba"), "ﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "gomasaba"), "ｺﾞﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maaji"), "ﾏｱｼﾞ")
    expect_error(make_shtname(prefec = "kagoshima", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() stops for unknown prefecture", {
    expect_error(make_shtname(prefec = "foo", spcs = "katakuchi"),
                 "Unknown prefecture")
  })
#+END_SRC
*** テスト/ 計測データ取得
#+BEGIN_SRC  R :tangle tests/testthat/test_get_measdata.R
  context("Get measure data vector from data frame")

  test_that("get_vector() extracts vector correctly", {
    df <- data.frame(a = 1:200, b = 101:300, c = c(201:250, NA, 252:400))
    expect_equal(get_vector(1, 10:20, df, na.rm = TRUE), 10:20)
    expect_equal(get_vector(2, 50:60, df, na.rm = TRUE), 150:160)
    expect_equal(get_vector(3, 50:60, df, na.rm = TRUE), c(250, 252:260))
    expect_equal(get_vector(3, 50:60, df, na.rm = FALSE), c(250, 0, 252:260))
  })

  test_that("get_measdata() extracts vector correctly", {
    df <- data.frame(kumamoto_a = 1:200, kumamoto_b = c(1:100, NA, 102:200))
    expect_equal(get_measdata(1, df, prefec = "kumamoto"), 8:107)
    expect_equal(get_measdata(2, df, prefec = "kumamoto"), c(8:100, 102:107))
    expect_error(get_measdata(1, df, prefec = "foo"),
                 "Unknown prefecture", fix = TRUE)
  })

  test_that("get_histdata() extracts vector correctly", {
    df <- data.frame(blank = 1:200,
                     class_l = seq(5, 1000, 5), class_r = seq(10, 1005, 5),
                     a = c(1:50, rep(NA, 50), 101:150,
                           sum(c(1:50, 101:150)), rep(NA, 49)))
    expect_equal(get_histdata(4, df, prefec = "nagasaki")[, 2],
                 c(5:50, rep(0, 50), 101:150))
    expect_error(get_histdata(1, df, prefec = "kumamoto"),
                 "Unknown prefecture", fix = TRUE)
  })
#+END_SRC
*** テスト/ 体長データ整形
#+BEGIN_SRC R :tangle tests/testthat/test_fmtbl.R
  context("Load blhist data from Excel spreadhseet and tidy it up")

  test_that("fmtbl() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    class(path) <- "nagasaki"
    expect_is(fmtbl(path, spcs = "katakuchi", nest = TRUE), "data.frame")
  })

  test_that("fmtbl.nagasaki() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("check_month() detects bad month data", {
    path     <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki_month.xls"
    alldata  <- load_alldata(path, sheet = "カタクチ")
    colpos   <- get_col2load(target = alldata[4, ],
                             regex = ".\u6708", # "tsuki" in jp kanji
                             offset = 0)
    months   <- jpmonth2num(alldata[4, colpos])
    parsedym  <- parse_ym(path)
    check_month(months, parsedym$month_start, parsedym$month_end)
  })

  test_that("fmtbl.kumamoto() works well", {
    path <- "ExcelFiles/test_bl_kumamoto.xlsx"
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("fmtbl.kagoshima() works well", {
    path <- "ExcelFiles/test_bl_kagoshima.xlsx"
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })
#+END_SRC
*** テスト/ 漁獲量データ整形
#+BEGIN_SRC  R :tangle tests/testthat/test_fmtcatch.R
  context("Load catch data from Excel spreadhseet and tidy it up")

  test_that("fmtcatch.kagoshima() works well", {
    path <- "ExcelFiles/test_catch_kagoshima.xlsx"
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = TRUE, maki.only = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = FALSE, maki.only = TRUE),
              "data.frame")
  })

  test_that("fmtcatch.nagasaki() works well", {
    path <- "ExcelFiles/test_catch_ngs_nagasaki_iwashi.xls"
    expect_is(fmtcatch.nagasaki(path, spcs = "katakuchi"), "data.frame")
  })
#+END_SRC
** 関数
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** インポート
#+BEGIN_SRC  R :tangle R/util.R
  ## quiets concerns of R CMD check re: the .'s that appear in pipelines
  if (getRversion() >= "2.15.1") {
    utils::globalVariables(c(".", "maki4ports", "bou_akune", "bou_uchinoura"))
  }
#+END_SRC
*** ファイル名操作
#+BEGIN_SRC R :tangle R/handle_fname.R
  give_classi   <- function(fname, prefec) {
    out        <- fname
    class(out) <- prefec
    out
  }

  give_class <- function(fname, tbl.fname) {
    prefec     <- hash::values(tbl.fname, keys = fname)
    out <- purrr::map2(fname, prefec, give_classi)
    out
  }
#+END_SRC
*** セル位置取得
#+BEGIN_SRC R :tangle R/locate_cellpos.R
  quot_ring <- function(mod, ideal) {
    if (mod == 0) {
      a <- ideal
    } else {
      a <- mod
    }
    a
  }

  quot2col <- function(quotient, mod) {
    if (mod == 0) {
      col <- quotient
    } else {
      col <- quotient + 1
    }
    col
  }

  make_RC <- function(row, col) {
    rc <- paste0("R", row, "C", col)
    rc
  }

  locate_patterns <- function(df, regex) {
    nrows <- dim(df)[1]
    match <- apply(df, 2, gregexpr, pattern = regex) %>%
      unlist()
    pos <- which(match == TRUE)
    quo <- purrr::map(pos, `%/%`, nrows)
    mod <- purrr::map(pos, `%%`, nrows)
    col <- purrr::map2(quo, mod, quot2col)
    row <- purrr::map2(mod, nrows, quot_ring)
    pos <- cellranger::R1C1_to_A1(paste0("R", row, "C", col))
    pos
  }

  get_topleft <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    pos[1]
  }

  get_bottomright <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    rev(pos)[1]
  }
  #+END_SRC
*** 文字列操作
#+BEGIN_SRC R :tangle R/handle_str.R
  get_col2load   <- function(target, regex, offset) {
    match <- stringr::str_detect(target, regex)
    out <- which(match == TRUE) + offset
    out
  }

  insert_regex <- function(str, regex, prefix = FALSE, option = FALSE) {
    if (option == FALSE) {
      rep <- "+"
    } else {
      rep <- "*"
    }
    if (prefix == TRUE) {
      out <- paste0(regex, rep, substr(str, 1, 1))
    } else {
      out <- substr(str, 1, 1)
    }
    for (i in 2:nchar(str)) {
      out <- paste0(out, regex, rep, substr(str, i, i))
    }
    out
  }

  parse_ym <- function(path) {
    if (stringr::str_detect(path, "/")) {
      fname <- stringr::str_extract(path, "(?<=/)[^/]+$")
    } else {
      fname <- path
    }
    ym_start_match <- stringr::str_match(fname, "(\\d+)\\.((?:0|1)\\d)(?=-)")
    year_start     <- ym_start_match[2] %>% as.numeric()
    month_start    <- ym_start_match[3] %>% as.numeric()
    ym_end_match   <-
      stringr::str_match(fname, "\\d+\\.(?:0|1)\\d-(\\d+)\\.((?:0|1)\\d)")
    year_end       <- ym_end_match[2] %>% as.numeric()
    month_end      <- ym_end_match[3] %>% as.numeric()
    if ((nchar(year_start) != 4) | (nchar(year_end) != 4))
      stop("Failed parsing to year")
    out <- list()
    out$year_start  <- year_start
    out$month_start <- month_start
    out$year_end    <- year_end
    out$month_end   <- month_end
    out
  }
#+END_SRC
*** 種名シート名生成
#+BEGIN_SRC  R :tangle R/make_shtname.R
  make_shtname <- function(prefecture, spcs) {
    switch(prefecture,
           "kumamoto" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "sabarui"   = shtname <- "サバ類",
                    stop("Unknown spcs name"))

           },
           "nagasaki" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "masaba"    = shtname <- "マサバ",
                    "gomasaba"  = shtname <- "ゴマサバ",
                    "maaji"     = shtname <- "マアジ",
                    stop("Unknown spcs name"))
           },
           "kagoshima" = {
             switch(spcs,
                    "katakuchi" = shtname <- "ｶﾀｸﾁ",
                    "urume"     = shtname <- "ｳﾙﾒ",
                    "maiwashi"  = shtname <- "ﾏｲﾜｼ",
                    "masaba"    = shtname <- "ﾏｻﾊﾞ",
                    "gomasaba"  = shtname <- "ｺﾞﾏｻﾊﾞ",
                    "maaji"     = shtname <- "ﾏｱｼﾞ",
                    stop("Unknown spcs name"))
           },
           stop("Unknown prefecture")
           )
    shtname
  }
#+END_SRC
*** データ取得
#+BEGIN_SRC R :tangle R/get_data.R
  get_vector <- function(col, row, df, na.rm) {
    out <- dplyr::pull(df, col)[row]
    if (na.rm) {
      out %<>% stats::na.omit() %>%
        as.vector()
    } else {
      out %<>% tidyr::replace_na(0)
    }
    out
  }

  get_measdata <- function(col, df, prefec) {
    switch(prefec,
           "kumamoto" = {
             startrow <- 8
             endrow   <- 107
           },
           stop("Unknown prefecture"))
    out <- get_vector(col, startrow:endrow, df, na.rm = TRUE) %>%
      as.numeric()
    out
  }

  locate_vecend <- function(x) {
    out <- which(!is.na(x)) %>% max()
    out
  }

  get_histdata <- function(col, df, prefec) {
    switch(prefec,
           "nagasaki" = {
             startrow  <- 5
             endrow    <- locate_vecend(df[, col]) - 1
             class_l   <- get_vector(col = cellranger::letter_to_num("B"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             class_r   <- get_vector(col = cellranger::letter_to_num("C"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             class    <- make_blclass(class_l, class_r)
           },
           "kagoshima" = {
             startrow <- 9
             endrow   <- 48
             class    <- make_blclass(seq(40, 235, 5), seq(45, 240, 5))
           },
           stop("Unknown prefecture"))
    count <- get_vector(col, startrow:endrow, df, na.rm = FALSE) %>%
      as.numeric()
    out   <- data.frame(class = class, count = count)
    out
  }
#+END_SRC
*** 体長データ整形
#+BEGIN_SRC R :tangle R/fmtbl.R
  #' Load and format bl histogram data
  #'
  #' @inheritParams readxl::read_excel
  #' @param spcs Spcs name in romaji, one of
  #' @param nest If \code{TRUE}, data will be shown in rectangle format
  #'   whith nested bl datafor quick overview.
  #' \itemize{
  #'   \item maiwashi
  #'   \item maaji
  #'   \item sabarui
  #'   \item masaba
  #'   \item gomasaba
  #'   \item katakuchi
  #'   \item urume
  #' }
  #' @export
  fmtbl <- function(path, spcs, nest = FALSE) {
    UseMethod("fmtbl")
  }

  load_alldata <- function(path, sheet) {
    suppressMessages(
      alldata   <- readxl::read_excel(path,
                                      sheet = sheet, col_names = FALSE,
                                      col_types = "text")
    )
  }

  make_blclass <- function(left, right) {
    left %<>% unlist() %>%
      as.vector() %>%
      as.numeric() %>%
      formatC(width = 3, flag = 0)
    right %<>% unlist() %>%
      as.vector() %>%
      as.numeric() %>%
      formatC(width = 3, flag = 0)
    out <- paste(left, right, sep = "-")
    out
  }

  jpmonth2num <- function(x) {
    out <- x %>%
      as.vector() %>%
      gsub("\u6708", "", .) %>% # "tsuki" in jp kanji
      as.numeric()
    out
  }

  fmtbl.nagasaki  <- function(path, spcs, nest = TRUE) {

    check_month <- function(months, month_start, month_end) {
      if (!(month_start == months[1]) | (!month_end == rev(months)[1])) {
        stop ("Check month data")
      }
    }

    give_yr2month <- function(mvec, year.start) {
      out           <- list()
      is_yr_changed <- FALSE
      for (i in seq_along(mvec)) {
         m            <- mvec[i]
         out$month[i] <- m

         if (i >= 2) {
           if (m < out$month[i - 1]) {
           is_yr_changed <- TRUE
           }
         }

         if (is_yr_changed) {
           out$year[i] <- year.start + 1
         } else {
           out$year[i] <- year.start
         }
      }
      out
    }

    sheet     <- make_shtname(prefecture = "nagasaki", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    colpos    <- get_col2load(target = alldata[4, ],
                              regex = ".\u6708", # "tsuki" in jp kanji
                              offset = 0)
    months    <- jpmonth2num(alldata[4, colpos])
    histdata  <- purrr::map(colpos, get_histdata, df = alldata,
                            prefec = "nagasaki")
    parsedym  <- parse_ym(path)
    check_month(months, parsedym$month_start, parsedym$month_end)
    year_start <- parsedym$year_start
    out       <- list()
    out$year   <- give_yr2month(month, year_start)$year
    out$month  <- give_yr2month(month, year_start)$month
    out$hist   <- histdata
    out        <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kumamoto  <- function(path, spcs, nest = TRUE) {
    parse_year <- function(path) {
      if ( ( stringr::str_detect(path, "/"))) {
        fname <- stringr::str_match(path, "^.+/(\\d+\\s?【熊本県】.+)")[2]
      } else {
        fname <- path
      }
      match  <- stringr::str_match(fname, "^\\d+\\s?【熊本県】(\\w\\d+)まき")
      wareki <- match[2]
      era    <- stringr::str_sub(wareki, 1, 1)
      jpyr   <- stringr::str_replace(wareki, "^\\w", "")
      year   <- switch(era,
             "H" = paste0("heisei", jpyr, "年") %>%
               Nippon::wareki2AD()
             )

      year
    }
    sheet     <- make_shtname(prefecture = "kumamoto", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[1, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[1, cpos_date] %>%
      purrr::map_chr(tinyplyr::num2date)
    method    <- alldata[1, cpos_date + 4] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_measdata,
                             prefec = "kumamoto", df = alldata)

    out        <- list()
    out$date   <- date
    out$method <- method
    out$year   <- lubridate::year(out$date)
    out$month  <- lubridate::month(out$date)
    out$bl     <- bl

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kagoshima <- function(path, spcs, nest = TRUE) {
    sheet     <- make_shtname(prefecture = "kagoshima", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[3, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[3, cpos_date] %>%
      tinyplyr::num2date()
    method    <- alldata[6, cpos_date] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_histdata,
                             df = alldata, prefec = "kagoshima")

    out        <- list()
    out$date   <- date
    out$method <- method
    out$year   <- lubridate::year(out$date)
    out$month  <- lubridate::month(out$date)
    out$bl     <- bl

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }
#+END_SRC
*** 漁獲量データ整形
#+BEGIN_SRC R :tangle R/fmtcatch.R
    #' Load and format catch data
    #'
    #' @inheritParams readxl::read_excel
    #' @param spcs Spcs name in romaji, one of
    #' @param nest If \code{TRUE}, data will be shown in rectangle format
    #'   whith nested catch data for quick overview.
    #' \itemize{
    #'   \item maiwashi
    #'   \item maaji
    #'   \item sabarui
    #'   \item masaba
    #'   \item gomasaba
    #'   \item katakuchi
    #'   \item urume
    #' }
    #' @export
    fmtcatch <- function(path, spcs, nest = FALSE) {
      UseMethod("fmtcatch")
    }
   alert_decrease <- function(x) {
     if (any(diff(x) < 0)) {
       stop("There is a decrease in number.")
     } else {
       x
     }
   }

   fmtcatch.kagoshima <- function(path, spcs, spread = TRUE, maki.only = FALSE) {
     get_ym <- function(str, var) {
       split <- stringr::str_split(str, "\\.")
       if (var == "year") {
         out <- split[[1]][1] %>% as.numeric()
       } else if (var == "month"){
         out <- split[[1]][2] %>% as.numeric()
       }
       out
     }

     make_year <- function(yr_jp, jpera) {
       out <- paste0(jpera, yr_jp, "\u5E74") %>% # "nen" (year) in jp kanji
         Nippon::wareki2AD()
       out
     }

     data  <- load_alldata(path, sheet = "\uFF14\u6E2F\u8A08")
                                           # "4koukei" (four port sum) in jp kanji
     str   <- data[5:16, 1] %>%
       unlist() %>%
       as.vector()
     yr_jp <- tryCatch(
         purrr::map(str, get_ym, var = "year") %>%
           unlist() %>%
           alert_decrease(),
         error = function(c) {
           stop("fmtcatch.kagoshima() must be modified to follow jpera change.")
         },
         warning = function(c) "warning",
         message = function(c) "message"
       )

     years <- make_year(yr_jp, "\u5e73\u6210") # "heisei" in jp kanji

     months <- purrr::map(str, get_ym, var = "month") %>%
       unlist()

     load_catch_4ports <- function(path, spcs) {
       spcs_jp <- switch(spcs,
                         "maaji" = "マアジ",
                         "sabarui" = "サバ類",
                         "maiwashi" = "マイワシ",
                         "urume" = "ウルメイワシ",
                         "katakuchi" = "カタクチイワシ",
                         stop("Unknown spcs"))
       regex    <- insert_regex(spcs_jp, "\u3000", prefix = TRUE)
       data     <- load_alldata(path, sheet = "４港計")
       col_spcs <- which ( (gregexpr(regex, data[3, ]) > 0) == TRUE)
       col2load <- col_spcs + 4
       out      <- get_vector(col2load, 5:16, data, na.rm = FALSE) %>%
         readr::parse_number()
       out
     }

     load_catch_bouuke <- function(path, spcs, sheet, unit = "ton") {
       data     <- load_alldata(path, sheet)
       spcs_jp <- switch(spcs,
                         "maaji" = "マアジ",
                         "sabarui" = "サバ類",
                         "maiwashi" = "マイワシ",
                         "urume" = "ウルメ",
                         "katakuchi" = "カタクチ",
                         stop("Unknown spcs"))
       cols_spcs <- which ( (gregexpr(spcs_jp, data[32, ]) > 0) == TRUE)
       col_kg    <- cols_spcs[2]
       out       <- get_vector(col_kg, 33:44, data, na.rm = FALSE) %>%
         readr::parse_number()
       if (unit == "ton") {
         out <- out / 1000
       } else if (unit == "kg") {
       } else {
         stop ("Unknown unit.")
       }
       out
     }

     catch_4ports        <- load_catch_4ports(path, spcs)
     catch_bou_akune     <- load_catch_bouuke(path, spcs, sheet = "阿久根棒受")
     catch_bou_uchinoura <- load_catch_bouuke(path, spcs, sheet = "内之浦棒受")
     out <- list(year = years,
                 month = months,
                 maki4ports = catch_4ports,
                 bou_akune = catch_bou_akune,
                 bou_uchinoura = catch_bou_uchinoura) %>%
       tibble::as_tibble()
     if (maki.only == TRUE) {
       out %<>% dplyr::select(-"bou_akune", -"bou_uchinoura")
     } else {
       out %<>%
         dplyr::mutate(total = maki4ports + bou_akune + bou_uchinoura)
       if (spread == FALSE) {
         out %<>% dplyr::select(-"total") %>%
           tidyr::gather("maki4ports", "bou_akune", "bou_uchinoura",
                  key = "port", value = "catch_ton")
       }
     }
     out
   }

   fmtcatch.nagasaki <- function(path, spcs) {
     locate_spcsrow <- function(regex, df) {
       spcs_col <- dplyr::pull(df, 1)
       spcs_row <- which( (gregexpr(regex, spcs_col) > 0))
       if (length(spcs_row) == 0) {
         spcs_str <- spcs_col %>%
           tidyr::replace_na(" ")
         spcs_str[nchar(spcs_str) != 1] <- " "
         spcs_str %<>%
           stringr::str_c(collapse = "")
         spcs_row <- unlist(gregexpr(regex, spcs_str))
       }
       spcs_row
     }

     get_monthcol <- function(row, df) {
       regex <- "^([０-９]|[0-9])+　+月$"
       col   <- which(gregexpr(regex, df[row, ]) > 0)
       if (length(col) == 0) {
         row <- row - 1
         col <- which(gregexpr(regex, df[row, ]) > 0)
       }
       out   <- data.frame(row = row, col = col)
       out
     }

     xtract_numerici <- function(str) {
       regex <- "\\D+"
       half <- Nippon::zen2han(str) %>%
         stringr::str_replace(regex, "") %>%
         readr::parse_integer()
       half
     }

     xtract_numeric <- function(str) {
       out <- purrr::map_int(str, xtract_numerici)
       out
     }

     get_month <- function(regex, df, offset.x = 0, offset.y = 0,
                           xtract.digit = FALSE) {
       spcs_row <- locate_spcsrow(regex, df)
       rowcol   <- purrr::map_dfr(spcs_row, get_monthcol, df = df)
       out      <- purrr::map2(rowcol$col + offset.x,
                               rowcol$row + offset.y,
                               get_vector, df = df, na.rm = FALSE) %>%
         purrr::flatten_chr()
       if (xtract.digit) {
         out %<>% xtract_numeric()
       } else {
         out %<>% readr::parse_number()
       }
       out
     }

     get_year <- function(sheet, month) {
       ym  <- parse_ym(sheet)
       out <- rep(ym$year_start, length(month))
       if (any (diff(month) < 0)) {
         out[(which (diff(month) < 0) + 1):length(out)] <- ym$year_start + 1
       }
       out
     }

     get_port <- function(data) {
       out   <- NULL
       str   <- dplyr::pull(data, 1)[2]
       regex <- "(?<=\\）)((長崎|奈留|小佐々|橘))(?=\\w+ )"
       port  <- stringr::str_extract(str, regex)
       out   <- switch(port,
                       "長崎" = "nagasaki",
                       "奈留" = "naru",
                       "小佐々" = "kosasa",
                       "橘" = "tachibana")
       out
     }

     fmt_sheet <- function(sheet, path, regex) {
       data   <- load_alldata(path, sheet)
       port   <- get_port(data)
       months <- get_month(regex, data, xtract.digit = TRUE)
       years  <- get_year(sheet, months)
       catch  <- get_month(regex, data, offset.x = 2, offset.y = 5)
       out    <- list(year = years,
                      month = months,
                      port = port,
                      catch = catch,
                      fname = path,
                      sheet = sheet) %>%
         tibble::as_tibble()
       rm(data)
       out
     }

     spcs_jp <- switch(spcs,
                       "maiwashi" = "マイワシ",
                       "urume" = "ウルメイワシ",
                       "katakuchi" = "カタクチ")
     spcs_regex <- insert_regex(str = spcs_jp, regex = "( |　)",
                                prefix = FALSE, option = TRUE)
     sheets <- readxl::excel_sheets(path)
     out    <- purrr::map(sheets, fmt_sheet, path = path, regex = spcs_regex) %>%
       dplyr::bind_rows()
     out
  }

#+END_SRC
