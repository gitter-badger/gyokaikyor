#+TITLE: gyokaikyor プロジェクトノート
#+PROPERTY: header-args :exports code :results scalar :session *R:gyokaikyor*
#+STARTUP: contents

* 目次                                                                :TOC_3:
- [[#これは何か][これは何か？]]
- [[#レガシーファイル構成を整理する][レガシーファイル構成を整理する]]
  - [[#カタクチyyxlsx][★カタクチYY.xlsx]]
    - [[#ファイルがやっていること][ファイルがやっていること]]
    - [[#問題点][問題点]]
    - [[#解決策][解決策]]
  - [[#カタクチ月別県別漁獲量xlsx][★カタクチ月別県別漁獲量.xlsx]]
    - [[#ファイル中での作業][ファイル中での作業]]
  - [[#各県いわし][各県いわし]]
- [[#ディレクトリの構成][ディレクトリの構成]]
- [[#パッケージの機能][パッケージの機能]]
  - [[#データ目録の生成][データ目録の生成]]
  - [[#データの統合][データの統合]]
  - [[#グラフ描画][グラフ描画]]
  - [[#予報文案テンプレートの生成][予報文案テンプレートの生成]]
- [[#デモ][デモ]]
  - [[#体長組成][体長組成]]
  - [[#漁獲量][漁獲量]]
- [[#開発環境の整備][開発環境の整備]]
  - [[#本バッケージ内部で使用するパッケージ][本バッケージ内部で使用するパッケージ]]
- [[#開発][開発]]
  - [[#各県ファイルに対して必要な処理概要][各県ファイルに対して必要な処理概要]]
    - [[#体長][体長]]
    - [[#漁獲量-1][漁獲量]]
  - [[#どう問題を解くか][どう問題を解くか]]
    - [[#get_topleftkey--flmm][get_topleft(key = "FL(mm)")]]
  - [[#リロード--自動テスト][リロード & 自動テスト]]
  - [[#テストコード][テストコード]]
    - [[#テスト-ファイル名操作][テスト/ ファイル名操作]]
    - [[#テスト-セル位置取得][テスト/ セル位置取得]]
    - [[#テスト-文字列操作][テスト/ 文字列操作]]
    - [[#テスト-種名生成][テスト/ 種名生成]]
    - [[#テスト-計測データ取得][テスト/ 計測データ取得]]
    - [[#テスト-体長データ整形][テスト/ 体長データ整形]]
    - [[#テスト-漁獲量データ整形][テスト/ 漁獲量データ整形]]
    - [[#テスト-長崎漁獲量][テスト/ 長崎漁獲量]]
  - [[#関数][関数]]
    - [[#インポート][インポート]]
    - [[#ファイル名操作][ファイル名操作]]
    - [[#セル位置取得][セル位置取得]]
    - [[#文字列操作][文字列操作]]
    - [[#種名シート名生成][種名シート名生成]]
    - [[#和暦西暦変換][和暦/西暦変換]]
    - [[#データ取得][データ取得]]
    - [[#体長データ整形][体長データ整形]]
    - [[#漁獲量データ整形][漁獲量データ整形]]

* これは何か？
漁海況業務のリポジトリ．
主にRのパッケージ開発のコミュニケーション用．

* レガシーファイル構成を整理する
** ★カタクチYY.xlsx
*** ファイルがやっていること
各県の月別体長組成を統合し，
- 東シナ海
- 日本海
- 計
というシートで統合する Excel ファイル．
*** 問題点
- バイナリなのでバージョン管理ができない
- 資源評価と漁海況の両方で使用されるが，両業務で集計方法が異なるので紛らわしい．
*** 解決策
2段階の抽象度（精密測定 & 体長組成）で体長整理する．
- 精密データを提出する県については，県ごとに csv 形式の精密測定データベースを作成する．
- 精密はなく，体長組成データを提出する県については，県ごとにcsv 型式の体長組成データベースを作成する．
- 精密・体長各データベースから範囲を指定して体長階級×月形式のテーブルを作成できるようにする．

使用イメージ
#+BEGIN_SRC R :exports code :results silent
kumamoto    <- fmt_bl("./data.git/漁海況/2018年10月/各県資料/熊本県", gyokaikyo = TRUE, plot = TRUE)
db_kumamoto <- read_csv("./output.git/kumamoto_2018oct.csv")
out         <- bind_rows(db_kumamoto, kumamoto)
write.csv(out, "./output.git/kumamoto_2019mar.csv", row.names = FALSE)

get_table("./output.git/nagasaki_2018oct.csv", gyokaikyo = TRUE, start = 2016, end = 2017)
#+END_SRC
**** なぜデータベースか？
過去のデータが報告なしに更新されていた場合に対処するため
**** なぜ県ごとか？
差分管理を確実に実施するため
** ★カタクチ月別県別漁獲量.xlsx
*** ファイル中での作業
**** 各県の月別漁獲量データを手作業で整形
**** "集計"というシートに各県のデータを貼り付け，月別組成を得る
**** 単位をトンに揃えて農林統計の値で引き伸ばす
**** 「しらす」については月別には集計せず，農林統計で引き伸ばす

** 各県いわし
* ディレクトリの構成
R パッケージのディレクトリは全て GitHub で公開する．
ただし，以下のディレクトリは GitHub にはアップロードせず，ローカルで管理する（リモートリポジトリを GitHub ではなく，NAS に設定する）．
- data.git/: 各県から提供されたデータ．
- docs.git/: 予報文案など．
  
* パッケージの機能
** データ目録の生成
** データの統合
** グラフ描画
- 漁獲量
- 体長組成
** 予報文案テンプレートの生成
何らかの構造化マークアップ言語の形式で．
できるだけタグが短いもの．
マークダウンが有力か？
* デモ
** 体長組成
#+BEGIN_SRC R
  library(gyokaikyor)
  library(hash)
  library(ggplot2)
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/04 【熊本県】H29まき網＆棒受網 体長組成.xlsx")
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/04_H30_まき網＆棒受網体長組成.xlsx",
              "data.git/漁海況/2018年3月/各県資料/長崎県/2017.09-2018.01小型まき網体長組成.xls",
              "data.git/漁海況/2018年3月/各県資料/鹿児島県/体長組成(H29年度).xlsx")
  prefec <- c("kumamoto", "nagasaki", "kagoshima")
  tbl_fname <- hash(fname, prefec)

  fname2 <- give_class(fname, tbl_fname)
  fname2[[1]]
  fname2[[2]]
  fname2[[3]]

  kumamoto_nested <- fmtbl(fname2[[1]], spcs = "katakuchi")
  kumamoto        <- fmtbl(fname2[[1]], spcs = "katakuchi", nest = FALSE)
  kumamoto        <- fmtbl(fname2[[1]], spcs = "maiwashi", nest = FALSE)
  nagasaki_nested <- fmtbl(fname2[[2]], spcs = "katakuchi")
  nagasaki        <- fmtbl(fname2[[2]], spcs = "katakuchi", nest = FALSE)
  kagoshima_nested <- fmtbl(fname2[[3]], spcs = "katakuchi")
  kagoshima        <- fmtbl(fname2[[3]], spcs = "katakuchi", nest = FALSE)

  kumamoto %>%
    ggplot(aes(bl, fill = as.factor(month))) +
    geom_histogram() +
    facet_grid(month ~ year, scale = "free_y")

#+END_SRC
** 漁獲量
#+BEGIN_SRC R
  library(hash)
  library(ggplot2)
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/01_H30まき網漁獲量（熊本県）.xls",
              "data.git/漁海況/2019年3月/各県資料/熊本県/02_H30棒受網漁獲量（熊本県）.xls",
              "data.git/漁海況/2019年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls",
             "./data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls",
             "./data.git/漁海況/2019年3月/各県資料/長崎県/奈留漁協ｲﾜｼ類（中小旋）とりまとめ.xlsx",
             "./data.git/漁海況/2019年3月/各県資料/長崎県/九十九島漁協ｲﾜｼ類(中小まき)とりまとめ.xlsx",
             "data.git/漁海況/2019年3月/各県資料/鹿児島県/４港月計表（30年度）.xlsx",
             "data.git/漁海況/2019年3月/各県資料/佐賀県/➁佐賀県_予報対象種漁獲量（元データ）.xls",
             "data.git/漁海況/2019年3月/各県資料/福岡県/2019-3月送付_S51_H30経年福岡漁獲量データ(提出分).xlsx",
             "data.git/漁海況/2019年3月/各県資料/山口県/2018-2019湊銘柄別水揚市場調査表.xlsx")

  prefec <- c(rep("kumamoto", 2),
             rep("nagasaki", 4),
             "kagoshima",
             "saga",
             "fukuoka",
             "yamaguchi")
  tbl_fname <- hash(fname, prefec)

  fname2 <- give_class(fname, tbl_fname)
  fname2[[1]]
  fname2[[2]]
  fname2[[3]]
  fname2[[4]]
  fname2[[5]]
  fname2[[6]]
  fname2[[7]]
  fname2[[8]]
  fname2[[9]]
  fname2[[10]]

  spcs <- "katakuchi"

  km_maki <- fmtcatch(fname2[[1]], spcs = spcs, type = "maki")
  km_bou  <- fmtcatch(fname2[[2]], spcs = spcs, type = "bouuke")
  kumamoto <- dplyr::bind_rows(km_maki, km_bou)
  kumamoto %>% ggplot(aes(month, catch, color = type)) +
    geom_line() +
    facet_wrap(~ year)


  ngs      <- fmtcatch(fname2[[3]], "katakuchi")
  tbn      <- fmtcatch(fname2[[4]], "katakuchi")
  nr       <- fmtcatch(fname2[[5]], "katakuchi")
  kjk      <- fmtcatch(fname2[[6]], "katakuchi")
  nagasaki <- dplyr::bind_rows(ngs, tbn, nr, kjk)

  nagasaki %>% ggplot(aes(month, catch, color = port)) +
    geom_line() +
    facet_wrap(~ year)

  kagoshima <- fmtcatch(fname2[[7]], spcs = spcs)

  sg_kennai  <- fmtcatch(fname2[[8]], spcs = spcs, type = "kennai")
  sg_chumaki <- fmtcatch(fname2[[8]], spcs = spcs, type = "chumaki")
  sg_teichi  <- fmtcatch(fname2[[8]], spcs = spcs, type = "teichi")
  saga       <- dplyr::bind_rows(sg_kennai, sg_chumaki, sg_teichi)

  saga %>% ggplot(aes(month, catch, color = type)) +
    geom_line() +
    facet_wrap(~ year)

  fk_maki  <- fmtcatch(fname2[[9]], spcs = spcs, type = "maki")
  fk_bou   <- fmtcatch(fname2[[9]], spcs = spcs, type = "bouuke")
  fk_other <- fmtcatch(fname2[[9]], spcs = spcs, type = "others")
  fukuoka  <- dplyr::bind_rows(fk_maki, fk_bou, fk_other)
  fukuoka %>% ggplot(aes(month, catch, color = type)) +
    geom_line() +
    facet_wrap(~ year)

  yamaguchi <- fmtcatch(fname2[[10]], spcs = spcs)
  yamaguchi %>% ggplot(aes(month, catch, color = meigara)) +
    geom_line() +
    facet_wrap(year ~ type)
#+END_SRC
* 開発環境の整備
#+BEGIN_SRC R :results silent
  # usethis::create_package("gyokaikyor")
    usethis::use_mit_license("Akira Hayashi")
    usethis::use_coverage(type = "codecov")
    usethis::use_lifecycle_badge("experimental")
#+END_SRC
** 本バッケージ内部で使用するパッケージ
#+BEGIN_SRC R :results silent
  usethis::use_package("magrittr", "Imports")
  usethis::use_package("hash")
  usethis::use_package("tibble")
  usethis::use_package("cellranger")
  usethis::use_package("tidyr")
  usethis::use_package("lubridate")
  usethis::use_package("readxl")
  usethis::use_package("readr")
  usethis::use_package("stringr")
  usethis::use_package("purrr")
  usethis::use_dev_package("tinyplyr")
  usethis::use_package("Nippon")
  usethis::use_package("stringi")
  usethis::use_package("dplyr")
  # usethis::use_package("ggplot2", "Imports")
  # usethis::use_package("tibble", "Imports")
  usethis::use_testthat()
  usethis::use_pipe()
#+END_SRC

#+BEGIN_SRC sh :exports results :session nil
cat DESCRIPTION
#+END_SRC

#+RESULTS[26e6d91ffe9c3ff5d95f888fb0006e9154a02abb]:
#+begin_example

Package: gyokaikyor
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person(given = "First",
           family = "Last",
           role = c("aut", "cre"),
           email = "first.last@example.com")
Description: What the package does (one paragraph).
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
Imports: 
    magrittr,
    hash,
    tibble,
    cellranger,
    tinyplyr,
    tidyr,
    lubridate,
    purrr,
    readxl,
    stringr,
    Nippon,
    dplyr
Suggests: 
    testthat,
    covr
RoxygenNote: 6.1.1
#+end_example

#+BEGIN_SRC sh :exports results :session nil
cat NAMESPACE
#+END_SRC

#+RESULTS:
: 
: Generated by roxygen2: do not edit by hand
: <>%")
: >%")

* 開発
** 各県ファイルに対して必要な処理概要
*** 体長
**** まず県別に整理
***** 山口
fresco
***** 福岡
カタクチ測定なし
***** 佐賀
fresco
***** DONE 長崎
- シートを読み込む．対象は春と秋とで違う．
  - 3月漁海況: 2017.09-2018.01小型まき網体長組成.xls
  - 10月漁海況: 2018.02-2018.08小型まき網体長組成.xls
- 漁法名をF2から取得
***** DONE 熊本
列方向に続いた精密測定データ．
10月漁海況のときには前年ファイルも一緒に送ってくれる．
- 04 【熊本県】H29まき網＆棒受網 体長組成.xlsx を開く <- *4月始まり*
- 「カタクチ」シートを読み込み
- df.out を初期化
- 日付が入った列（H29.4.30形式）を取得
- 漁法名を取得
- できればその他情報も取得（操業海域・陸揚げ港）
- 測定データ（全長・被鱗体長・体重）を取得
- df.out を初期化
- 過去のデータベースに df.out を結合
- 重複除去
- 新データベースをkumamoto_2018Oct.csv として書き出し
***** DONE 鹿児島
- 体長組成(H29年度).xlsx を開く　<- *4月始まり*
- 「ｶﾀｸﾁ」シートを読み込み
- 日付が入った列を取得
- 漁法名などの情報を取得
- 個体数情報を体長階級ブロックごと取得
- 過去のdbに結合...
**** まとめると
精密，体長のような分け方はしないほうが良い．
あくまでも，関数を部品として作り，各県ごとにそれを組み合わせて使う．
強いて分類するなら，以下のようになる．
- 精密タイプ: 熊本
- 体長タイプ: 長崎，鹿児島
- fresco タイプ: 山口，佐賀
*** 漁獲量
**** 山口
資源評価のデータと，形式が全然違う．
***** ファイルを開く
***** 年シートをパースして年を取得
***** シートを読み込む
***** 各魚種のデータ列を与えてしまう
****** 各魚種の4行目から，銘柄を取得
***** 列Aから月を生成し，各月データの行位置を取得
****** 「抄網」は行オフセット1，「棒受網」は行オフセット2として，各漁業の漁獲量を取得
**** DONE 福岡
***** 全年データが集まったファイルを開く
***** type = 漁業 としてシートにアクセス
***** "KEI"が入った月の列をget_datrow()に渡し，データ行を得る
***** 年と月のベクトルから，データ行だけ抽出して月と年を作る
***** 魚種の列もデータ行だけ抽出する
**** DONE 熊本
***** 漁業種別（まき網 or 棒受け網）のブックを開く
***** ファイル名をパースして漁法を取得
***** 魚種シートにアクセス
***** 年を生成
セルC4から真下に読み，「前年比」が出てきたらストップ
***** 月とデータを一気に読む
ただし年度整理になっているので1〜3月はyear+1年とする
**** DONE 佐賀
熊本と似てる．漁業種別もシートに分かれている
***** シート一覧を取得
***** 正規表現で魚種シートを絞り込み
***** シートから漁法を取得
***** 年を生成
***** 月とデータを一気に読む
熊本と同様，年度になっている
**** DONE 長崎
***** 魚種に応じてファイルを読み込み
****** マアジ・サバ類
****** マサバ・ゴマサバ
****** イワシ類
***** シート名を取得
過去全データが期間別にシートを分けて入っている
****** A列から魚種名を取得し，データ行を決定
****** データ行から漁期の最初の月の列を取得
前期と後期とで，エクセル方眼紙の列構成が違うのでこれが必要
****** 漁獲量を取得
とびとびにではあるが，一定の法則で入力されている．
関数で処理．
****** 合計が一致しているかチェック
**** DONE 鹿児島
***** 「４港計」「阿久根棒受」「内之浦棒受」シートを読み込み
****** 「４港計」シート
******* 第3行からスペース含みの魚種名を探し，列を決定
******* 行オフセット4つの位置にある「４港計」列の値を行方向に12ヶ月分（第5〜16行）取得
****** 「阿久根 or 内之浦棒受」シート
******* 32行目から魚種名を検索して列を決定（行数は変化しない）
******* 行方向に12ヶ月分（第33〜44行），値を取得
** どう問題を解くか
県ごとに，どうしてもデータ処理の振る舞いを変える必要がある
そこで， 各県のファイル名に，県名を属性として与える
#+TBLNAME: tbl_fname_prefec
| fname                                    | prefec   |
|------------------------------------------+----------|
| 03 漁獲努力量（1804~1903）（熊本県）.xls | kumamoto |
| 04 漁獲努力量（1704~1803）（熊本県）.xls | kumamoto |

#+TBLNAME: tbl_prefec_key
| prefec   | key.topleft |
|----------+-------------|
| nagasaki | FL(mm)      |


各県のファイル名を fmtbl() に与えると，データ形式に適した形で整形される．
水面下でデータ型式を読みに行き，ファイル名に属性として付与している

fname <- "04 漁獲努力量（1704~1803）（熊本県）.xls"



*** get_topleft(key = "FL(mm)")
** リロード & 自動テスト
#+BEGIN_SRC R :results silent
  devtools::load_all()
  system("R CMD INSTALL --preclean --no-multiarch --with-keep.source .")
  devtools::test()
  lintr::lint_package()
  devtools::document(roclets=c('rd', 'collate', 'namespace'))
  devtools::check(args = "--as-cran")
  covr::package_coverage()
#+END_SRC

** テストコード
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** テスト/ ファイル名操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_fname.R
  library(gyokaikyor)
  context("Handle file name")
  fn_kumamoto  <- "04 漁獲努力量（1704~1803）（熊本県）.xls"
  fn_kagoshima <- "体長組成(H29年度).xlsx"
  tbl_fname    <- hash::hash(c(fn_kumamoto, fn_kagoshima),
                             c("kumamoto", "kagoshima"))
  test_that("give_class() gives fname its file format as class", {
    expect_is(give_class(fn_kumamoto, tbl_fname), "list")
    expect_is(give_class(fn_kumamoto, tbl_fname)[[1]], "kumamoto")
    expect_is(give_class(fn_kagoshima, tbl_fname)[[1]], "kagoshima")
  })
#+END_SRC
*** テスト/ セル位置取得
#+BEGIN_SRC R :tangle tests/testthat/test_locate_cellpos.R
  library(gyokaikyor)
  context("Locate cell position")

  suppressWarnings(library(tibble))
  df <- tribble(~A, ~B, ~C, ~D,
                NA, NA, NA, 1,
                NA, "name", "value", 2,
                "", "foo", 12, 3,
                "", "bar", 123, 4,
                "", "baz", 1234, 5,
                "", "bum", 12345, 6,
                "", "foo", 12, 7)

  test_that("quot_ring() throws value on given quotient ring", {
    expect_equal(quot_ring(0, 3), 3)
    expect_equal(quot_ring(1, 3), 1)
    expect_equal(quot_ring(2, 3), 2)
    expect_equal(quot_ring(0, 5), 5)
    expect_equal(quot_ring(1, 5), 1)
    expect_equal(quot_ring(2, 5), 2)
    expect_equal(quot_ring(3, 5), 3)
    expect_equal(quot_ring(4, 5), 4)
  })

  test_that("quot2col() throws col position from
   quotient of given match position in matrix", {
    expect_equal(quot2col(3, 0), 3)
    expect_equal(quot2col(3, 1), 4)
    expect_equal(quot2col(4, 1), 5)
    expect_equal(quot2col(5, 1), 6)
    expect_equal(quot2col(5, 2), 6)
  })

  test_that("get_locate_patterns() locates cell position that has given regex", {
    expect_equal(locate_patterns(df, "name"), "$B$2")
    expect_equal(locate_patterns(df, "nam."), "$B$2")
    expect_equal(locate_patterns(df, "foo"), c("$B$3", "$B$7"))
  })

  test_that("get_topleft() locates cell position that has given regex", {
    expect_equal(get_topleft(df, "name"), "$B$2")
    expect_equal(get_topleft(df, "nam."), "$B$2")
    expect_equal(get_topleft(df, "foo"), "$B$3")
  })

  test_that("get_bottomright() locates cell position that has given regex", {
    expect_equal(get_bottomright(df, "12345"), "$C$6")
    expect_equal(get_bottomright(df, "foo"), "$B$7")
  })

  test_that("locate_vecend() locates the end of the vector", {
    expect_equal(locate_vecend(c(1:10, NA, NA, NA)), 10)
    expect_equal(locate_vecend(c(rep(NA, 9), 100, NA, NA, NA)), 10)
  })
  #+END_SRC
*** テスト/ 文字列操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_str.R
  library(gyokaikyor)
  context("Handle string")

  target <-
    c("漁獲年月日", "", "2017.4.20", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.5.19", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.6.23", "操業海域", "八代海", "漁法", "まき網")

  test_that("get_col2load() works well",
            expect_equal(get_col2load(target,
                            regex = "20[0-9]{2}\\.[0-9][0-9]?\\.[0-9][0-9]?",
                            offset = -2),
                         c(1, 8, 15))
            )

  test_that("parse_ym() works well", {
    expect_setequal(parse_ym("2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_setequal(parse_ym("foo/bar/2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_error(parse_ym("20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
    expect_error(parse_ym("foo/bar/20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
  })
#+END_SRC
*** テスト/ 種名生成
#+BEGIN_SRC  R :tangle tests/testthat/test_make_shtname.R
  library(gyokaikyor)
  context("Make shtname of prefecture")

  test_that("make_shtname() makes sheetname for kumamoto data", {
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "sabarui"), "サバ類")
    expect_error(make_shtname(prefec = "kumamoto", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for nagasaki data", {
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "masaba"), "マサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "gomasaba"), "ゴマサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maaji"), "マアジ")
    expect_error(make_shtname(prefec = "nagasaki", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for kagoshima data", {
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "katakuchi"), "ｶﾀｸﾁ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "urume"), "ｳﾙﾒ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maiwashi"), "ﾏｲﾜｼ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "masaba"), "ﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "gomasaba"), "ｺﾞﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maaji"), "ﾏｱｼﾞ")
    expect_error(make_shtname(prefec = "kagoshima", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() stops for unknown prefecture", {
    expect_error(make_shtname(prefec = "foo", spcs = "katakuchi"),
                 "Unknown prefecture")
  })
#+END_SRC
*** テスト/ 計測データ取得
#+BEGIN_SRC  R :tangle tests/testthat/test_get_measdata.R
  library(gyokaikyor)
  context("Get measure data vector from data frame")

  test_that("get_vector() extracts vector correctly", {
    df <- data.frame(a = 1:200, b = 101:300, c = c(201:250, NA, 252:400))
    expect_equal(get_vector(1, 10:20, df, na.rm = TRUE), 10:20)
    expect_equal(get_vector(2, 50:60, df, na.rm = TRUE), 150:160)
    expect_equal(get_vector(3, 50:60, df, na.rm = TRUE), c(250, 252:260))
    expect_equal(get_vector(3, 50:60, df, na.rm = FALSE), c(250, 0, 252:260))
  })

  test_that("get_measdata() extracts vector correctly", {
    df <- data.frame(kumamoto_a = 1:200, kumamoto_b = c(1:100, NA, 102:200))
    expect_equal(get_measdata(1, df, prefec = "kumamoto"), 8:107)
    expect_equal(get_measdata(2, df, prefec = "kumamoto"), c(8:100, 102:107))
    expect_error(get_measdata(1, df, prefec = "foo"),
                 "Unknown prefecture", fix = TRUE)
  })

  test_that("get_histdata() extracts vector correctly", {
    df <- data.frame(blank = 1:200,
                     class_l = seq(5, 1000, 5), class_r = seq(10, 1005, 5),
                     a = c(1:50, rep(NA, 50), 101:150,
                           sum(c(1:50, 101:150)), rep(NA, 49)))
    expect_equal(get_histdata(4, df, prefec = "nagasaki")[, 2],
                 c(5:50, rep(0, 50), 101:150))
    expect_error(get_histdata(1, df, prefec = "kumamoto"),
                 "Unknown prefecture", fix = TRUE)
  })
#+END_SRC
*** テスト/ 体長データ整形
#+BEGIN_SRC R :tangle tests/testthat/test_fmtbl.R
  library(gyokaikyor)
  context("Load blhist data from Excel spreadhseet and tidy it up")

  test_that("fmtbl() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    class(path) <- "nagasaki"
    expect_is(fmtbl(path, spcs = "katakuchi", nest = TRUE), "data.frame")
  })

  test_that("fmtbl.nagasaki() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("check_month() detects bad month data", {
    path     <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki_month.xls"
    expect_error(fmtbl.nagasaki(path, spcs = "katakuchi"),
                 "Check month data", fix = TRUE)
  })

  test_that("fmtbl.kumamoto() works well", {
    path <- "ExcelFiles/test_bl_kumamoto.xlsx"
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("fmtbl.kagoshima() works well", {
    path <- "ExcelFiles/test_bl_kagoshima.xlsx"
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })
#+END_SRC
*** テスト/ 漁獲量データ整形
#+BEGIN_SRC  R :tangle tests/testthat/test_fmtcatch.R
  library(gyokaikyor)
  context("Load catch data from Excel spreadhseet and tidy it up")

  test_that("fmtcatch.yamaguchi() work correctly", {
    path <- "ExcelFiles/test_catch_yamaguchi.xlsx"
    df   <- fmtcatch.yamaguchi(path, spcs = "katakuchi")
    expect_is(df, "data.frame")

    expect_setequal(dplyr::filter(df,
                                  year == 2018,
                                  month == 1,
                                  type == "sukui") %>%
                    dplyr::pull(catch),
                    seq(33, 36))
    expect_setequal(unique(df$type), c("sukui", "bouuke"))
  })

  test_that("fmtcatch.fukuoka() work correctly", {
    path <- "ExcelFiles/test_catch_fukuoka.xlsx"
    df   <- fmtcatch.fukuoka(path, spcs = "katakuchi", type = "maki")
    expect_is(df, "data.frame")
    expect_setequal(subset(df, year == 1977)$catch,
                    c(18, 51, 84, 117, 150, 183, 216, 249))
    expect_setequal(subset(df, year == 1978)$catch,
                    c(315, 348, 381, 414, 447, 480, 513, 546))
    expect_equal(unique(df$type), "maki")
    expect_setequal(unique(df$month), 4:12)
  })

  test_that("fmtcatch.kumamoto() processes makiami data correctly", {
    path <- "ExcelFiles/test_catch_kumamoto_maki.xls"
    df   <- fmtcatch.kumamoto(path, spcs = "katakuchi", type = "maki")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1989)$catch, 1:9)
    expect_equal(subset(df, year == 1990)$catch, 10:21)
    expect_equal(unique(df$type), "maki")
    expect_setequal(unique(df$month), 1:12)
  })

  test_that("fmtcatch.kumamoto() processes bouukeami data correctly", {
    path <- "ExcelFiles/test_catch_kumamoto_bouuke.xls"
    df   <- fmtcatch.kumamoto(path, spcs = "katakuchi", type = "bouuke")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1993)$catch, 1:7)
    expect_equal(subset(df, year == 1994)$catch, 8:14)
    expect_equal(unique(df$type), "bouuke")
    expect_setequal(unique(df$month), 6:12)
  })

  test_that("fmtcatch.saga() prosesses saga data correctly", {
    path <- "ExcelFiles/test_catch_saga.xls"
    df   <- fmtcatch.saga(path, spcs = "katakuchi", type = "kennai")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1975)$catch, 1:9)
    expect_equal(subset(df, year == 1976)$catch, 10:21)
    expect_equal(unique(df$type), "kennai")
    expect_setequal(unique(df$month), 1:12)
  })

  test_that("fmtcatch.kagoshima() works well", {
    path <- "ExcelFiles/test_catch_kagoshima.xlsx"
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = TRUE, maki.only = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = FALSE, maki.only = TRUE),
              "data.frame")
  })
#+END_SRC
*** テスト/ 長崎漁獲量
#+BEGIN_SRC  R :tangle tests/testthat/test_catch_nagasaki.R
  library(gyokaikyor)
  context(Formating nagasaki catch data)

#+END_SRC

** 関数
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** インポート
#+BEGIN_SRC  R :tangle R/util.R
  ## quiets concerns of R CMD check re: the .'s that appear in pipelines
  if (getRversion() >= "2.15.1") {
    utils::globalVariables(c(".", "maki4ports", "bou_akune", "bou_uchinoura"))
  }
#+END_SRC
*** ファイル名操作
#+BEGIN_SRC R :tangle R/handle_fname.R
  give_classi   <- function(fname, prefec) {
    out        <- fname
    class(out) <- prefec
    out
  }

  give_class <- function(fname, tbl.fname) {
    prefec     <- hash::values(tbl.fname, keys = fname)
    out <- purrr::map2(fname, prefec, give_classi)
    out
  }
#+END_SRC
*** セル位置取得
#+BEGIN_SRC R :tangle R/locate_cellpos.R
  quot_ring <- function(mod, ideal) {
    if (mod == 0) {
      a <- ideal
    } else {
      a <- mod
    }
    a
  }

  quot2col <- function(quotient, mod) {
    if (mod == 0) {
      col <- quotient
    } else {
      col <- quotient + 1
    }
    col
  }

  make_RC <- function(row, col) {
    rc <- paste0("R", row, "C", col)
    rc
  }

  locate_patterns <- function(df, regex) {
    nrows <- dim(df)[1]
    match <- apply(df, 2, gregexpr, pattern = regex) %>%
      unlist()
    pos <- which(match == TRUE)
    quo <- purrr::map(pos, `%/%`, nrows)
    mod <- purrr::map(pos, `%%`, nrows)
    col <- purrr::map2(quo, mod, quot2col)
    row <- purrr::map2(mod, nrows, quot_ring)
    pos <- cellranger::R1C1_to_A1(paste0("R", row, "C", col))
    pos
  }

  get_topleft <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    pos[1]
  }

  get_bottomright <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    rev(pos)[1]
  }

  get_row <- function(str, regex, offset = 0) {
    stringr::str_which(str, regex) + offset
  }
  #+END_SRC
*** 文字列操作
#+BEGIN_SRC R :tangle R/handle_str.R
  get_col2load   <- function(target, regex, offset) {
    match <- stringr::str_detect(target, regex)
    out <- which(match == TRUE) + offset
    out
  }

  insert_regex <- function(str, regex, prefix = FALSE, option = FALSE) {
    if (option == FALSE) {
      rep <- "+"
    } else {
      rep <- "*"
    }
    if (prefix == TRUE) {
      out <- paste0(regex, rep, substr(str, 1, 1))
    } else {
      out <- substr(str, 1, 1)
    }
    for (i in 2:nchar(str)) {
      out <- paste0(out, regex, rep, substr(str, i, i))
    }
    out
  }

  parse_ym <- function(path) {
    if (stringr::str_detect(path, "/")) {
      fname <- stringr::str_extract(path, "(?<=/)[^/]+$")
    } else {
      fname <- path
    }
    ym_start_match <- stringr::str_match(fname, "(\\d+)\\.((?:0|1)\\d)(?=-)")
    year_start     <- ym_start_match[2] %>% as.numeric()
    month_start    <- ym_start_match[3] %>% as.numeric()
    ym_end_match   <-
      stringr::str_match(fname, "\\d+\\.(?:0|1)\\d-(\\d+)\\.((?:0|1)\\d)")
    year_end       <- ym_end_match[2] %>% as.numeric()
    month_end      <- ym_end_match[3] %>% as.numeric()
    if ( (nchar(year_start) != 4) | (nchar(year_end) != 4))
      stop("Failed parsing to year")
    out <- list()
    out$year_start  <- year_start
    out$month_start <- month_start
    out$year_end    <- year_end
    out$month_end   <- month_end
    out
  }

  xtract_numeric <- function(str) {
    xtract_numerici <- function(str) {
      regex <- "\\D+"
      half <- Nippon::zen2han(str) %>%
        stringr::str_replace(regex, "") %>%
        readr::parse_integer()
      half
    }
    out <- purrr::map_int(str, xtract_numerici)
    out
  }

#+END_SRC
*** 種名シート名生成
#+BEGIN_SRC  R :tangle R/make_shtname.R
  make_shtname <- function(prefecture, spcs) {
    switch(prefecture,
           "kumamoto" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "sabarui"   = shtname <- "サバ類",
                    stop("Unknown spcs name"))

           },
           "nagasaki" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "masaba"    = shtname <- "マサバ",
                    "gomasaba"  = shtname <- "ゴマサバ",
                    "maaji"     = shtname <- "マアジ",
                    stop("Unknown spcs name"))
           },
           "kagoshima" = {
             switch(spcs,
                    "katakuchi" = shtname <- "ｶﾀｸﾁ",
                    "urume"     = shtname <- "ｳﾙﾒ",
                    "maiwashi"  = shtname <- "ﾏｲﾜｼ",
                    "masaba"    = shtname <- "ﾏｻﾊﾞ",
                    "gomasaba"  = shtname <- "ｺﾞﾏｻﾊﾞ",
                    "maaji"     = shtname <- "ﾏｱｼﾞ",
                    stop("Unknown spcs name"))
           },
           stop("Unknown prefecture")
           )
    shtname
  }
#+END_SRC
*** 和暦/西暦変換
#+BEGIN_SRC  R :tangle R/jpyr2ad.R
  jpyr2ad <- function(x, start) {
    conv <- vector(mode = "integer")
    if (start == "showa") {
     suppressMessages(pos_lastyr <- alert_decrease(x))
     x[1:96]
     x[1:97]
     conv[1:pos_lastyr] <- 1925
     conv[1:96]
     conv[1:97]
     conv[(pos_lastyr + 1):length(x)] <- 1988
    } else {
      stop("jpyr2ad")
    }
    ad <- x + conv
    ad
  }

#+END_SRC
*** データ取得
#+BEGIN_SRC R :tangle R/get_data.R
  get_vector <- function(col, row, df, na.rm) {
    out <- dplyr::pull(df, col)[row]
    if (na.rm) {
      out %<>% stats::na.omit() %>%
        as.vector()
    } else {
      out %<>% tidyr::replace_na(0)
    }
    out
  }

  get_measdata <- function(col, df, prefec) {
    switch(prefec,
           "kumamoto" = {
             startrow <- 8
             endrow   <- 107
           },
           stop("Unknown prefecture"))
    out <- get_vector(col, startrow:endrow, df, na.rm = TRUE) %>%
      as.numeric()
    out
  }

  locate_vecend <- function(x) {
    out <- which(!is.na(x)) %>% max()
    out
  }

  get_histdata <- function(col, df, prefec) {
    switch(prefec,
           "nagasaki" = {
             startrow  <- 5
             endrow    <- locate_vecend(df[, col]) - 1
             class_l   <- get_vector(col = cellranger::letter_to_num("B"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             class_r   <- get_vector(col = cellranger::letter_to_num("C"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             class    <- make_blclass(class_l, class_r)
           },
           "kagoshima" = {
             startrow <- 9
             endrow   <- 48
             class    <- make_blclass(seq(40, 235, 5), seq(45, 240, 5))
           },
           stop("Unknown prefecture"))
    count <- get_vector(col, startrow:endrow, df, na.rm = FALSE) %>%
      as.numeric()
    out   <- data.frame(class = class, count = count)
    out
  }
#+END_SRC
*** 体長データ整形
#+BEGIN_SRC R :tangle R/fmtbl.R
  #' Load and format bl histogram data
  #'
  #' @inheritParams readxl::read_excel
  #' @param spcs Spcs name in romaji, one of
  #' @param nest If \code{TRUE}, data will be shown in rectangle format
  #'   whith nested bl datafor quick overview.
  #' \itemize{
  #'   \item maiwashi
  #'   \item maaji
  #'   \item sabarui
  #'   \item masaba
  #'   \item gomasaba
  #'   \item katakuchi
  #'   \item urume
  #' }
  #' @export
  fmtbl <- function(path, spcs, nest = FALSE) {
    UseMethod("fmtbl")
  }

  load_alldata <- function(path, sheet) {
    suppressMessages(
      alldata   <- readxl::read_excel(path,
                                      sheet = sheet, col_names = FALSE,
                                      col_types = "text")
    )
  }

  make_blclass <- function(left, right) {
    left %<>% unlist() %>%
      as.vector() %>%
      as.numeric() %>%
      formatC(width = 3, flag = 0)
    right %<>% unlist() %>%
      as.vector() %>%
      as.numeric() %>%
      formatC(width = 3, flag = 0)
    out <- paste(left, right, sep = "-")
    out
  }

  jpmonth2num <- function(x) {
    out <- x %>%
      as.vector() %>%
      gsub("\u6708", "", .) %>% # "tsuki" in jp kanji
      as.numeric()
    out
  }

  fmtbl.nagasaki  <- function(path, spcs, nest = TRUE) {

    check_month <- function(months, month_start, month_end) {
      if (!(month_start == months[1]) | (!month_end == rev(months)[1])) {
        stop ("Check month data")
      }
    }

    give_yr2month <- function(mvec, year.start) {
      out           <- list()
      is_yr_changed <- FALSE
      for (i in seq_along(mvec)) {
         m            <- mvec[i]
         out$month[i] <- m

         if (i >= 2) {
           if (m < out$month[i - 1]) {
           is_yr_changed <- TRUE
           }
         }

         if (is_yr_changed) {
           out$year[i] <- year.start + 1
         } else {
           out$year[i] <- year.start
         }
      }
      out
    }

    sheet     <- make_shtname(prefecture = "nagasaki", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    colpos    <- get_col2load(target = alldata[4, ],
                              regex = ".\u6708", # "tsuki" in jp kanji
                              offset = 0)
    months    <- jpmonth2num(alldata[4, colpos])
    histdata  <- purrr::map(colpos, get_histdata, df = alldata,
                            prefec = "nagasaki")
    parsedym  <- parse_ym(path)
    check_month(months, parsedym$month_start, parsedym$month_end)
    year_start <- parsedym$year_start
    out       <- list()
    out$year   <- give_yr2month(months, year_start)$year
    out$month  <- give_yr2month(months, year_start)$month
    out$hist   <- histdata
    out        <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kumamoto  <- function(path, spcs, nest = TRUE) {
    parse_year <- function(path) {
      if ( ( stringr::str_detect(path, "/"))) {
        fname <- stringr::str_match(path, "^.+/(\\d+\\s?【熊本県】.+)")[2]
      } else {
        fname <- path
      }
      match  <- stringr::str_match(fname, "^\\d+\\s?【熊本県】(\\w\\d+)まき")
      wareki <- match[2]
      era    <- stringr::str_sub(wareki, 1, 1)
      jpyr   <- stringr::str_replace(wareki, "^\\w", "")
      year   <- switch(era,
             "H" = paste0("heisei", jpyr, "年") %>%
               Nippon::wareki2AD()
             )

      year
    }
    sheet     <- make_shtname(prefecture = "kumamoto", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[1, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[1, cpos_date] %>%
      purrr::map_chr(tinyplyr::num2date)
    method    <- alldata[1, cpos_date + 4] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_measdata,
                             prefec = "kumamoto", df = alldata)

    out        <- list()
    out$date   <- date
    out$method <- method
    out$year   <- lubridate::year(out$date)
    out$month  <- lubridate::month(out$date)
    out$bl     <- bl

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kagoshima <- function(path, spcs, nest = TRUE) {
    sheet     <- make_shtname(prefecture = "kagoshima", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[3, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[3, cpos_date] %>%
      tinyplyr::num2date()
    method    <- alldata[6, cpos_date] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_histdata,
                             df = alldata, prefec = "kagoshima")

    out        <- list()
    out$date   <- date
    out$method <- method
    out$year   <- lubridate::year(out$date)
    out$month  <- lubridate::month(out$date)
    out$bl     <- bl

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }
#+END_SRC
*** 漁獲量データ整形
**** 総称関数
#+BEGIN_SRC R :tangle R/fmtcatch.R
  #' Load and format catch data
  #'
  #' @inheritParams readxl::read_excel
  #' @param spcs Spcs name in romaji, one of
  #' @param nest If \code{TRUE}, data will be shown in rectangle format
  #' @param type Character value either "maki" or "bouuke" to control
  #'   data processing algorithm for kumamoto data.
  #'   whith nested catch data for quick overview.
  #' \itemize{
  #'   \item maiwashi
  #'   \item maaji
  #'   \item sabarui
  #'   \item masaba
  #'   \item gomasaba
  #'   \item katakuchi
  #'   \item urume
  #' }
  #' @export
  fmtcatch <- function(path, spcs, type = NULL) {
    UseMethod("fmtcatch")
  }

  alert_decrease <- function(x) {
    if (any(diff(x) < 0)) {
      message("There is a decrease in number.")
      which(diff(x) < 0)
    } else {
      x
    }
  }
#+END_SRC
**** 山口
#+BEGIN_SRC R :tangle R/fmtcatch_yamaguchi.R
  #' Load and format catch data of yamaguchi
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "sukui" or "bouuke".
  fmtcatch.yamaguchi <- function(path, spcs, type = NULL) {
    switch(spcs,
           "maaji"    = {
             spcs_col     <- 5
             meigara_ofst <- 1:3
           },
           "sabarui"  = {
             spcs_col     <- 9
             meigara_ofst <- 1:2
           },
           "maiwashi" = {
             spcs_col     <- 12
             meigara_ofst <- 1:3
           },
           "urume"    = {
             spcs_col     <- 21
             meigara_ofst <- 1:3
           },
           "katakuchi" = {
             spcs_col     <- 16
             meigara_ofst <- 1:4
           })

    get_catch_meigara <- function(cofst, spcs_col, sheet) {
      alldata     <- load_alldata(path, sheet = sheet)
      year        <- xtract_numeric(sheet)
      row_jan     <- 5
      rows        <- row_jan:38
      mmatch      <- xtract_numeric(alldata[[1]][rows])
      mrows       <- which(!is.na(mmatch)) + row_jan - 1
      ofst_sukui  <- 1
      ofst_bouuke <- 2
      out         <- NULL
      out$year    <- year
      out$month   <- dplyr::pull(alldata, 1)[mrows] %>%
        xtract_numeric()
      out$sukui   <- col2data(col = spcs_col + cofst,
                        rows = 1:40,
                        row.pick = mrows + ofst_sukui,
                        alldata)
      out$bouuke  <- col2data(col = spcs_col + cofst,
                        rows = 1:40,
                        row.pick = mrows + ofst_bouuke,
                        alldata)
      out$meigara <- alldata[4, spcs_col + cofst] %>%
        unlist() %>% as.vector()
      out %<>% tibble::as_tibble() %>%
        tidyr::gather("sukui", "bouuke", key = "type", value = "catch")
      out
    }

    sheets <- readxl::excel_sheets(path) %>%
      stringr::str_extract("[0-9]+.+") %>%
      na.omit()

    dat1   <- purrr::map_df(meigara_ofst, get_catch_meigara,
                          spcs_col = spcs_col, sheet = sheets[1])
    dat2   <- purrr::map_df(meigara_ofst, get_catch_meigara,
                          spcs_col = spcs_col, sheet = sheets[2])
    out    <- dplyr::bind_rows(dat1, dat2) %>%
      dplyr::mutate(catch = catch / 1000)
    out
  }
#+END_SRC
**** 福岡
#+BEGIN_SRC R :tangle R/fmtcatch_fukuoka.R
  #' Load and format catch data of fukuoka
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "maki" or "bouuke", and "others".
  fmtcatch.fukuoka <- function(path, spcs, type) {
    spcs_jp <- switch(spcs,
                      "maaji"     = "ﾏｱｼﾞ",
                      "maiwashi"  = "ﾏｲﾜｼ",
                      "masaba"    = "ﾏｻﾊﾞ",
                      "gomasaba"  = "ｺﾞﾏｻﾊﾞ",
                      "katakuchi" = "ｶﾀｸﾁ",
                      "urume"     = "ｳﾙﾒ")

    sheet <- switch(type,
                    "maki"   = "まき網 ",
                    "bouuke" = "棒受網",
                    "others" = "その他漁業")
    alldata <- load_alldata(path, sheet)

    ycol     <- 2
    mcol     <- 3
    mstr     <- alldata[[mcol]]
    startrow <- get_row(mstr, "ﾂｷ", offset = 1)
    endrow   <- get_row(mstr, "KEI") %>% max()
    rows     <- startrow:endrow
    datrow   <- stringr::str_count(mstr[startrow:endrow], "KEI") == 0
    spcs_col <- get_spcscol(alldata, spcs_jp)

    out       <- NULL
    out$year  <- col2data(col = ycol, row = rows,
                          row.pick = datrow, df = alldata) %>%
      jpyr2ad(start = "showa")
    out$month <- col2data(col = mcol, row = rows,
                          row.pick = datrow, df = alldata)
    out$type  <- type
    out$catch <- col2data(col = spcs_col, row = rows,
                          row.pick = datrow, df = alldata)
    tibble::as_tibble(out)
  }

  col2data <- function(col, rows, row.pick, df) {
    out <- df[[col]][rows][row.pick] %>%
      as.numeric()
    out
  }

  get_spcscol <- function(df, spcs_jp) {
    out <- NULL
    for (i in 2:5) {
      str <- df[i, ] %>%
        unlist() %>%
        as.vector()
      out <- stringr::str_which(str, spcs_jp)
      if (length(out) > 0)
        break
    }
    out
  }

#+END_SRC
**** 鹿児島
#+BEGIN_SRC R :tangle R/fmtcatch_kagoshima.R
   fmtcatch.kagoshima <- function(path, spcs, spread = TRUE, maki.only = FALSE) {
     get_ym <- function(str, var) {
       split <- stringr::str_split(str, "\\.")
       if (var == "year") {
         out <- split[[1]][1] %>% as.numeric()
       } else if (var == "month"){
         out <- split[[1]][2] %>% as.numeric()
       }
       out
     }

     make_year <- function(yr_jp, jpera) {
       out <- paste0(jpera, yr_jp, "\u5E74") %>% # "nen" (year) in jp kanji
         Nippon::wareki2AD()
       out
     }

     data  <- load_alldata(path, sheet = "\uFF14\u6E2F\u8A08")
                                           # "4koukei" (four port sum) in jp kanji
     str   <- data[5:16, 1] %>%
       unlist() %>%
       as.vector()
     yr_jp <- tryCatch(
         purrr::map(str, get_ym, var = "year") %>%
           unlist() %>%
           alert_decrease(),
         error = function(c) {
           stop("fmtcatch.kagoshima() must be modified to follow jpera change.")
         },
         warning = function(c) "warning",
         message = function(c) "message"
       )

     years <- make_year(yr_jp, "\u5e73\u6210") # "heisei" in jp kanji

     months <- purrr::map(str, get_ym, var = "month") %>%
       unlist()

     load_catch_4ports <- function(path, spcs) {
       spcs_jp <- switch(spcs,
                         "maaji" = "マアジ",
                         "sabarui" = "サバ類",
                         "maiwashi" = "マイワシ",
                         "urume" = "ウルメイワシ",
                         "katakuchi" = "カタクチイワシ",
                         stop("Unknown spcs"))
       regex    <- insert_regex(spcs_jp, "\u3000", prefix = TRUE)
       data     <- load_alldata(path, sheet = "４港計")
       col_spcs <- which((gregexpr(regex, data[3, ]) > 0) == TRUE) #nolint
       col2load <- col_spcs + 4
       out      <- get_vector(col2load, 5:16, data, na.rm = FALSE) %>%
         readr::parse_number()
       out
     }

     load_catch_bouuke <- function(path, spcs, sheet, unit = "ton") {
       data     <- load_alldata(path, sheet)
       spcs_jp <- switch(spcs,
                         "maaji" = "マアジ",
                         "sabarui" = "サバ類",
                         "maiwashi" = "マイワシ",
                         "urume" = "ウルメ",
                         "katakuchi" = "カタクチ",
                         stop("Unknown spcs"))
       cols_spcs <- which((gregexpr(spcs_jp, data[32, ]) > 0) == TRUE) # nolint
       col_kg    <- cols_spcs[2]
       out       <- get_vector(col_kg, 33:44, data, na.rm = FALSE) %>%
         readr::parse_number()
       if (unit == "ton") {
         out <- out / 1000
       } else if (unit == "kg") {
       } else {
         stop ("Unknown unit.")
       }
       out
     }

     catch_4ports        <- load_catch_4ports(path, spcs)
     catch_bou_akune     <- load_catch_bouuke(path, spcs, sheet = "阿久根棒受")
     catch_bou_uchinoura <- load_catch_bouuke(path, spcs, sheet = "内之浦棒受")
     out <- list(year = years,
                 month = months,
                 maki4ports = catch_4ports,
                 bou_akune = catch_bou_akune,
                 bou_uchinoura = catch_bou_uchinoura) %>%
       tibble::as_tibble()
     if (maki.only == TRUE) {
       out %<>% dplyr::select(-"bou_akune", -"bou_uchinoura")
     } else {
       out %<>%
         dplyr::mutate(total = maki4ports + bou_akune + bou_uchinoura)
       if (spread == FALSE) {
         out %<>% dplyr::select(-"total") %>%
           tidyr::gather("maki4ports", "bou_akune", "bou_uchinoura",
                  key = "port", value = "catch_ton")
       }
     }
     out
   }
#+END_SRC
**** 長崎
#+BEGIN_SRC R :tangle R/fmtcatch_nagasaki.R
  #' Make vector 'houganshi'
  #'
  #' This function returns vector 'houganshi' to locate the position of
  #'   target word (e.g. species name) in a Excel rows or columns.
  #' To keep correspondence between nubmer of cells and nchar of output string,
  #' This function replaces \code{NA} and a cell value with multiple characters.
  #' @param str String vector with NA or multiple characters
  #' @return Long single string composed of single-word cell and whitespace
  #' @examples
  #' str <- rep(1:10, 10) %>%
  #'   replace(which(. %% 3  == 0), NA) %>%
  #'   replace(which(. %% 5  == 0), "foo") %>%
  #'   as.character()
  #' make_hougan(str)
  make_hougan <- function(str) {
    out <- tidyr::replace_na(str, " ")
    out[nchar(out) != 1] <- " "
    out %<>% stringr::str_c(collapse = "")
    out
  }

  #' Locate row position of the cell which contains species name
  #'
  #' This function locates the row position of the cell which contains
  #'   specific species name.
  #' @param regex Regular expression to match the name of the target species.
  #' @param colstr String vector made from a Excel worksheet column.
  #' @return All the row positions where the species name start.
  ngs_locate_spcsrow <- function(regex, colstr) {
    spcs_row <- stringr::str_which(colstr, regex)
    if (length(spcs_row) == 0) {
      spcs_str <- make_hougan(colstr)
      spcs_row <- unlist(gregexpr(regex, spcs_str))
    }
    spcs_row
  }
  regex <- "カ( |　)*タ( |　)*ク( |　)*チ"
  ngs_locate_spcsrow(regex, str)

  #' Detect month column coping with variation in row position of the month cell
  #'
  #' @param row Assumed position of the month cell
  #' @param df Loaded Excel sheet
  #' @return Row-column set of month cells in a given \code{row}
  ngs_get_monthcol <- function(row, df) {
    regex <- "^([０-９]|[0-9])+　+月$"
    col   <- which(gregexpr(regex, df[row, ]) > 0)
    if (length(col) == 0) {
      row <- row - 1
      col <- which(gregexpr(regex, df[row, ]) > 0)
    }
    out   <- data.frame(row = row, col = col)
    out
  }

  #' Get values placed separately in column direction
  #'
  #' This function return values placed separately on the specific fish row
  #'   in column direction.
  #' @inheritParams ngs_locate_spcsrow ngs_get_monthcol
  #' @param offset.x X-offset of the target value
  #'   from the position of the month cell
  #' @param offset.y Y-offest of the target value
  #'   from the position of the month cell
  #' @param xtract.digit If \code{TRUE}, all characters were deleted so that
  #'   the return value composed only of numerics.
  ngs_get_colvalue <- function(regex, df, offset.x = 0, offset.y = 0,
                            xtract.digit = FALSE) {
    spcs_col <- dplyr::select(df, 1)
    spcs_row <- ngs_locate_spcsrow(regex, spcs_col)
    rowcol   <- purrr::map_dfr(spcs_row, ngs_get_monthcol, df = df)
    out      <- purrr::map2(rowcol$col + offset.x,
                            rowcol$row + offset.y,
                            get_vector, df = df, na.rm = FALSE) %>%
      purrr::flatten_chr()
    if (xtract.digit) {
      out %<>% xtract_numeric()
    } else {
      out %<>% readr::parse_number()
    }
    out
  }

  ngs_get_year <- function(sheet, month) {
    ym  <- parse_ym(sheet)
    out <- rep(ym$year_start, length(month))
    if (any (diff(month) < 0)) {
      out[(which (diff(month) < 0) + 1):length(out)] <- ym$year_start + 1
    }
    out
  }

  ngs_get_port <- function(str) {
    out   <- NULL
    regex <- stringi::stri_escape_unicode(
      "(?<=Ｈ(．|\\.)\\d\\d?(）|\\))?)((長崎|奈留|九十九|小佐々|橘))(?=\\w+ )"
    )
    port  <- stringr::str_extract(str, stringi::stri_unescape_unicode(regex))
    out   <- switch(stringi::stri_escape_unicode(port),
                    "\\u9577\\u5d0e"        = "nagasaki",
                    "\\u5948\\u7559"        = "naru",
                    "\\u4e5d\\u5341\\u4e5d" = "kujuku",
                    "\\u5c0f\\u4f50\\u3005" = "kujuku",
                    "\\u6a58"               = "tachibana")
    out
  }

  ngs_fmt_sheet <- function(sheet, path, regex) {
    data   <- load_alldata(path, sheet)
    port   <- ngs_get_port(dplyr::pull(data, 1)[2])
    months <- ngs_get_colvalue(regex, data, xtract.digit = TRUE)
    years  <- ngs_get_year(sheet, months)
    catch  <- ngs_get_colvalue(regex, data, offset.x = 2, offset.y = 5)
    out    <- list(year = years,
                   month = months,
                   port = port,
                   catch = catch,
                   fname = path,
                   sheet = sheet) %>%
      tibble::as_tibble()
    rm(data)
    out
  }

  fmtcatch.nagasaki <- function(path, spcs) {
    spcs_jp <- switch(spcs,
                      "maiwashi" = "マイワシ",
                      "urume" = "ウルメイワシ",
                      "katakuchi" = "カタクチ")
    spcs_regex <- insert_regex(str = spcs_jp, regex = "( |　)",
                               prefix = FALSE, option = TRUE)
    sheets <- readxl::excel_sheets(path)
    out    <- purrr::map(sheets, ngs_fmt_sheet,
                         path = path, regex = spcs_regex) %>%
      dplyr::bind_rows()
    out
  }
  path <- "data.git/漁海況/2019年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls"
  test <- fmtcatch.nagasaki(path, spcs)
  path <- "data.git/漁海況/2019年3月/各県資料/長崎県/九十九島漁協ｲﾜｼ類(中小まき)とりまとめ.xlsx"
  test <- fmtcatch.nagasaki(path, spcs)
  path <- "data.git/漁海況/2019年3月/各県資料/長崎県/奈留漁協ｲﾜｼ類（中小旋）とりまとめ.xlsx"
  test <- fmtcatch.nagasaki(path, spcs)
  path <- "data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls"
  test <- fmtcatch.nagasaki(path, spcs)
#+END_SRC
**** 熊本 & 佐賀
#+BEGIN_SRC R :tangle R/fmtcatch_kumamoto_saga.R
  #' Load catch data of kumamoto and tidy it up
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "maki" or "bouke".
  #'   Data processing algorithm is controled by this parameter.
  fmtcatch.kumamoto <- function(path, spcs, type) {
    sheet   <- switch(spcs,
                      "maaji" = "マアジ",
                      "maiwashi" = "マイワシ",
                      "sabarui" = "サバ類",
                      "katakuchi" = "カタクチイワシ",
                      "urume" = "ウルメイワシ")
    alldata <- load_alldata(path, sheet)
    out     <- get_data(alldata, type, key.start = "年度計", key.end = "前年比")
    out
  }
  #' Load catch data of saga and tidy it up
  #'
  #' @inheritParams fmtcatch.kumamoto
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"masaba"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value one of
  #' \itemize{
  #'   \item{"karatsu"}
  #'   \item{"kennai"}
  #'   \item{"teichi"}
  #'   \item{"chumaki"}
  #' }
  #'   Data processing algorithm is controled by this parameter.
  fmtcatch.saga <- function(path, spcs, type) {
    spcs_jp <- switch(spcs,
                      "maaji" = "ﾏｱｼﾞ",
                      "maiwashi" = "ﾏｲﾜｼ",
                      "masaba" = "ﾏｻﾊﾞ",
                      "katakuchi" = "ｶﾀｸﾁ",
                      "urume" = "ｳﾙﾒ")
    type_jp <- switch(type,
                      "karatsu" = "（唐津港）",
                      "kennai" = "（唐津港県内船）",
                      "teichi" = "（定置）",
                      "chumaki" = "（中まき）")
    sheets  <- readxl::excel_sheets(path)
    regex   <- paste0(spcs_jp, type_jp)
    sheet   <- sheets[stringr::str_detect(sheets, regex)]
    alldata <- load_alldata(path, sheet)
    out     <- get_data(alldata, type, key.start = "年度", key.end = "平年値")
    out
  }

  get_data <- function(df, type, key.start, key.end) {
    switch(type,
           "maki" = {
             judgecol_start <- 18
             judgecol_end   <- 3
             cols           <- 4:15
             months         <- c(4:12, 1:3)
             yrcol          <- 3
           },
           "bouuke" = {
             judgecol_start <- 13
             judgecol_end   <- 2
             cols           <- 4:10
             months         <- 6:12
             yrcol          <- 3
           }
         , {
             if (!type %in% c("karatsu", "kennai", "teichi", "chumaki"))
               stop("Unknown type")
             judgecol_start <- 1
             judgecol_end   <- 16
             cols           <- 3:14
             months         <- c(4:12, 1:3)
             yrcol          <- 1
           })
    str_judge_start <- dplyr::pull(df, judgecol_start)
    str_judge_end   <- dplyr::pull(df, judgecol_end)
    row_start       <- get_row(str_judge_start, key.start, offset = 1)
    row_end         <- get_row(str_judge_end, key.end, offset = -1)
    rows            <- row_start:row_end
    year            <- dplyr::pull(df, yrcol)[rows] %>%
      as.numeric()
    out             <- NULL
    out             <- df[rows, cols]
    colnames(out)   <- months
    out %<>% dplyr::mutate(year = year,
                           type = type) %>%
      tidyr::gather(-year, -type, key = month, value = "catch") %>%
      dplyr::mutate(year = as.integer(year),
                    month = as.integer(month),
                    catch = as.double(catch)) %>%
      dplyr::select(year, month, type, catch) %>%
      dplyr::mutate(year = ifelse(dplyr::between(month, 1, 3),
                                  year + 1,
                                  year)) %>%
      dplyr::arrange(year, month)
    out
  }
#+END_SRC
