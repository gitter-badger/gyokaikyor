#+TITLE: gyokaikyor プロジェクトノート
#+PROPERTY: header-args :exports code :results scalar :session *R:gyokaikyor*
#+STARTUP: contents

* 目次                                                                :TOC_3:
- [[#これは何か][これは何か？]]
- [[#レガシーワークフローを整理する][レガシーワークフローを整理する]]
  - [[#カタクチyyxlsx][★カタクチYY.xlsx]]
    - [[#ファイルがやっていること][ファイルがやっていること]]
    - [[#問題点][問題点]]
    - [[#解決策][解決策]]
  - [[#カタクチ月別県別漁獲量xlsx][★カタクチ月別県別漁獲量.xlsx]]
    - [[#ファイル中での作業][ファイル中での作業]]
  - [[#各県いわしファイル][「各県いわし」ファイル]]
  - [[#水温データの整理][水温データの整理]]
  - [[#漁況予測][漁況予測]]
    - [[#glmによる予測][GLMによる予測]]
    - [[#時系列解析による予測][時系列解析による予測]]
    - [[#問題点-1][問題点]]
- [[#ディレクトリの構成][ディレクトリの構成]]
- [[#パッケージの機能][パッケージの機能]]
  - [[#データ目録の生成][データ目録の生成]]
  - [[#データの統合][データの統合]]
  - [[#グラフ描画][グラフ描画]]
  - [[#予報文案テンプレートの生成][予報文案テンプレートの生成]]
- [[#使い方デモ][使い方デモ]]
  - [[#体長組成整理][体長組成整理]]
  - [[#漁獲量整理][漁獲量整理]]
  - [[#漁況予測-1][漁況予測]]
- [[#開発環境の整備][開発環境の整備]]
  - [[#本バッケージ内部で使用するパッケージ][本バッケージ内部で使用するパッケージ]]
- [[#開発][開発]]
  - [[#各県ファイルに対して必要な処理概要][各県ファイルに対して必要な処理概要]]
    - [[#体長][体長]]
    - [[#漁獲量][漁獲量]]
  - [[#どう問題を解くか][どう問題を解くか]]
    - [[#get_topleftkey--flmm][get_topleft(key = "FL(mm)")]]
  - [[#リロード--自動テスト][リロード & 自動テスト]]
  - [[#テストコード][テストコード]]
    - [[#テスト-ファイル名操作][テスト/ ファイル名操作]]
    - [[#テスト-セル位置取得][テスト/ セル位置取得]]
    - [[#テスト-文字列操作][テスト/ 文字列操作]]
    - [[#テスト-種名生成][テスト/ 種名生成]]
    - [[#テスト-計測データ取得][テスト/ 計測データ取得]]
    - [[#テスト-体長データ整形][テスト/ 体長データ整形]]
    - [[#テスト-漁獲量データ整形][テスト/ 漁獲量データ整形]]
    - [[#テスト-長崎漁獲量][テスト/ 長崎漁獲量]]
  - [[#関数][関数]]
    - [[#インポート][インポート]]
    - [[#ファイル名操作][ファイル名操作]]
    - [[#セル位置取得][セル位置取得]]
    - [[#文字列操作][文字列操作]]
    - [[#種名シート名生成][種名シート名生成]]
    - [[#和暦西暦変換][和暦/西暦変換]]
    - [[#データ取得][データ取得]]
    - [[#データ作成][データ作成]]
    - [[#体長データ整形][体長データ整形]]
    - [[#漁獲量データ整形][漁獲量データ整形]]
    - [[#ファイル形式で書き出し][★ファイル形式で書き出し]]
    - [[#各県いわしをrで使いやすい形式に変換][「各県いわし」をRで使いやすい形式に変換]]
    - [[#体長頻度データを擬似精密データに変換][体長頻度データを擬似精密データに変換]]
    - [[#水温データを整理][水温データを整理]]

* これは何か？
漁海況業務のリポジトリ．
主にRのパッケージ開発のコミュニケーション用．

* レガシーワークフローを整理する
** ★カタクチYY.xlsx
*** ファイルがやっていること
各県の月別体長組成を統合し，
- 東シナ海
- 日本海
- 計
というシートで統合する Excel ファイル．
*** 問題点
- バイナリなのでバージョン管理ができない
- 資源評価と漁海況の両方で使用されるが，両業務で集計方法が異なるので紛らわしい．
*** 解決策
2段階の抽象度（精密測定 & 体長組成）で体長整理する．
- 精密データを提出する県については，県ごとに csv 形式の精密測定データベースを作成する．
- 精密はなく，体長組成データを提出する県については，県ごとにcsv 型式の体長組成データベースを作成する．
- 精密・体長各データベースから範囲を指定して体長階級×月形式のテーブルを作成できるようにする．

使用イメージ
#+BEGIN_SRC R :exports code :results silent
kumamoto    <- fmt_bl("./data.git/漁海況/2018年10月/各県資料/熊本県", gyokaikyo = TRUE, plot = TRUE)
db_kumamoto <- read_csv("./output.git/kumamoto_2018oct.csv")
out         <- bind_rows(db_kumamoto, kumamoto)
write.csv(out, "./output.git/kumamoto_2019mar.csv", row.names = FALSE)

get_table("./output.git/nagasaki_2018oct.csv", gyokaikyo = TRUE, start = 2016, end = 2017)
#+END_SRC
**** なぜデータベースか？
過去のデータが報告なしに更新されていた場合に対処するため
**** なぜ県ごとか？
差分管理を確実に実施するため
** ★カタクチ月別県別漁獲量.xlsx
*** ファイル中での作業
**** 各県の月別漁獲量データを手作業で整形
**** "集計"というシートに各県のデータを貼り付け，月別組成を得る
**** 単位をトンに揃えて農林統計の値で引き伸ばす
**** 「しらす」については月別には集計せず，農林統計で引き伸ばす

** 「各県いわし」ファイル
** 水温データの整理
#+BEGIN_SRC R
  temp <- get_tw_sst("/Users/ahayashi/Documents/GitHub/gyokaikyor/data.git/水温データ/mgdsst_till201902.xlsx",
                     year.end = 2019)
  write.csv(temp, "/Volumes/評価研/個人的データ置き場/hayashi/output/gkk_2019Mar_sst.csv", row.names = FALSE)
#+END_SRC
** 作図
#+BEGIN_SRC R
  ym_matrix2df <- function(x) {
    out <- x %>%
      tidyr::gather(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec,
                    key = month, value = catch) %>%
      dplyr::mutate(month = abb2num(month),
                    ym    = make_ym(year, month))
    out
  }

  make_ymrange <- function(year, gkk.month) {
    switch(gkk.month,
           "Mar" = {
             mstart <- 4
             mend   <- 3
           },
           "Oct" = {
           },
           stop("Unknown month"))
    out$start <- paste0(year - 1, formatC(mstart, width = 2, flag = 0)) %>%
      as.numeric()
    out$end   <- paste0(year, formatC(mend, width = 2, flag = 0)) %>%
      as.numeric()
    out
  }
  make_ymrange(2019, "Mar")

  plot_catch_monthvar <- function(df.seikai, year, gkk.month) {
    get_catch <- function(year, gkk.month, df.seikai) {
      ym.start <- make_ymrange(year, gkk.month)$start
      ym.end   <- make_ymrange(year, gkk.month)$end
      out  <- ym_matrix2df(df.seikai) %>%
        dplyr::filter(dplyr::between(ym,
                                     ym.start,
                                     ym.end)) %>%
        dplyr::arrange(ym) %>%
        dplyr::pull(catch)
      out
    }

    draw_catch <- function(l, var, year) {
      catch <- l[[var]]
      ofst  <- 0.5
      switch(var,
             "recent" = {
               polygon(c(1:12, 12:1), c(catch * 0.8, rev(catch * 1.2)),
                       col = hsv(0, 0, 0.8), border = FALSE)
               lines(1:12, catch, lwd = 2)
               points(1:12, catch, pch = 16)
               text(12, catch[12], "平年±20%", pos = 4, offset = ofst, cex = 1.5)
             },
             "last" = {
               col <- hsv(200/360, 0.8, 0.8)
               lines(1:12, catch, col = col, lwd = 2)
               points(1:12, catch, col = col , pch = 16)
               arrows(1:12, catch * 0.8, 1:12, catch * 1.2,
                      col = col, length = 0)
               text(12, catch[12], "前年±20%",
                    col = col, pos = 4, offset = ofst, cex = 1.5)
             },
             "this" = {
               catch <- catch[1:11]
               col <- hsv(0/360, 0.8, 0.8)
               lines(1:11, catch, col = col, lwd = 3)
               points(1:11, catch, col = col, pch = 16, cex = 1.5)
               text(11, catch[11], paste0(year - 1, "年度"),
                    col = col, pos = 4, offset = ofst, cex = 2)
             })
    }

    init_plot <- function(l, gkk.month) {
      max <- l$max
      min <- l$min
      plot(1, 1, xlim = c(1, 16), ylim = c(min, max * 1.2), type = "n",
           axes = FALSE, ann = FALSE, yaxs = "i")
      switch(gkk.month,
             "Mar" = {
               rect(7.8, -10, 12.2, max * 1.1, col = hsv(20/360, 0.2, 1),
                           border = FALSE)
               axis(1, at = 1:12, labels = month.abb[c(4:12, 1:3)])
             })
    }

    draw_axes <- function(l) {
      axis(2, at = l$min:l$max)
      mtext("漁獲量 (千トン)", side = 2, line = 2.5, cex = 1.5)
    }

    lastyr   <- year - 1
    recentyr <- (year - 4):year
    l        <- list()
    l$this   <- get_catch(year, "Mar", l) / 1000
    l$last   <- get_catch(lastyr, "Mar", df.seikai) / 1000
    l$recent <- purrr::map_dfc(recentyr, get_catch, "Mar", df.seikai) %>%
      rowMeans() / 1000
    max      <- max(unlist(l)) * 1.2
    min      <- min(unlist(l)) * 0.8
    l$max    <- max
    l$min    <- min

    init_plot(l, gkk.month)
    draw_catch(l, var = "recent", year)
    draw_catch(l, var = "last", year)
    draw_catch(l, var = "this", year)
    draw_axes(l)
  }

  list_catchdata <- iwashi2list(path = "../../../Google Drive/gkk/各県いわし_林20190312.xlsx",
                                sheet = "カタクチイワシ",
                                year.end = 2019, year.start = 1992)
  df.seikai <- summarize_seikai(list_catchdata)

  plot_catch_monthvar(df.seikai, 2019, "Mar")

  library(XLConnect)
  library(cluster)
  # mathematical parameters
  YMAX_INIT   <- 0; ymax_updated <- YMAX_INIT
  MONTHS      <- 1:12
  SHEETNAME   <- "計"
  BLBIN       <- 5
  CLASS_LEFT  <- seq(0, 295, BLBIN)
  CLASS_RIGHT <- CLASS_LEFT + BLBIN
  CLASS_NAME  <- paste(formatC(CLASS_LEFT, width=3, flag=0), "_",
                       formatC(CLASS_RIGHT, width=3, flag=0), sep="")
  CLASS00_10_AGE0   <- data.frame(matrix(1, nrow=2, ncol=12), 
                                  row.names=c("000-005", "005-010"))
  CLASS00_10_AGE12  <- data.frame(matrix(0, nrow=2, ncol=12), 
                                  row.names=c("000-005", "005-010"))
  CLASS155_300   <- data.frame(matrix(0, nrow=length(seq(155, 295, 5)), ncol=12), 
                                  row.names=paste(seq(155, 295, 5), 
                                                    seq(160, 300, 5), sep = "_"))
  colnames(CLASS00_10_AGE0)   <- month.abb
  colnames(CLASS00_10_AGE12)  <- month.abb
  colnames(CLASS155_300)      <- month.abb
  AGE_LENGTH_KEY_0  <- read.csv("../_Library/ageLengthKey0.csv", row.names=1)
  AGE_LENGTH_KEY_0  <- rbind(CLASS00_10_AGE0, AGE_LENGTH_KEY_0, CLASS155_300)
  AGE_LENGTH_KEY_1  <- read.csv("../_Library/ageLengthKey1.csv", row.names=1)
  AGE_LENGTH_KEY_1  <- rbind(CLASS00_10_AGE12, AGE_LENGTH_KEY_1, CLASS155_300)
  AGE_LENGTH_KEY_2  <- read.csv("../_Library/ageLengthKey2.csv", row.names=1)
  AGE_LENGTH_KEY_2  <- rbind(CLASS00_10_AGE12, AGE_LENGTH_KEY_2, CLASS155_300)
  CLASS_LEFT_AL     <- as.numeric(substr(rownames(AGE_LENGTH_KEY_0), 1,3))
  STARTROW    <- 6 # Start from 0-5 mm but it is OK
  ENDROW      <- STARTROW + length(CLASS_LEFT) - 1

  plot.blhist <- function()
  # 体長組成
  # graphic parameters
  BORDER_KAERI_KOBA <- 50
  BORDER_KOBA_CHUBA <- 80
  BORDER_CHUBA_OHBA <- 100
  BARWIDTH      <- 4
  COL_FILL      <- hsv(0, 0, 0)
  COL0          <- hsv(200/360, 0.8, 0.9)
  COL1          <- hsv(200/360, 0.8, 0.6)
  COL2          <- hsv(200/360, 0.8, 0.1)
  COL_KAERI     <- hsv( 60/360, 0.9, 0.9, 0.1)
  COL_KOBA      <- hsv( 60/360, 0.9, 0.9, 0.35)
  COL_CHUBA     <- hsv( 60/360, 0.9, 0.9, 0.65)
  COL_OHBA      <- hsv( 60/360, 0.9, 0.9, 1)
  XMAX          <- 150
  YMAX_INIT     <- 100 # decide value by refering to ymax_init
  ymax_updated  <- 0
  TICKBIN_X     <- 1
  TICKBIN_Y     <- 10
  TICKLEN_X     <- 0.25
  TICKLEN_Y     <- 0.25
  LABELBIN_X    <- 5 # in cm
  LABELBIN_Y    <- 20
  pdf(paste("../output/gyokaikyo_", YEAR, "年3月_体長組成.pdf", sep=""), family="Helvetica", width=9, height=6)
  par(mfcol=c(12, 3), mai=c(0.1, 0.4, 0.05, 0.1), ps=20, oma=c(0, 0, 0.5, 0))
  for(y in (YEAR - 2):YEAR){ # To plot blhist of recent three years
    ychar     <- substr(y, 3, 4)
    if (y != YEAR){
      yfilename <- paste("★カタクチ", ychar, ".xls", sep="")
      wb        <- loadWorkbook(yfilename)
      data      <- readWorksheetFromFile(yfilename, sheet=SHEETNAME)
    }else{
      # No need to read file
    }
    out       <- NULL
    for(m in MONTHS){
      if (y != YEAR){
        startcol    <- 3
      }else{
        if (m == 3){
          break
        }
        startcol    <- 15
      }
      mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, startcol + m - 1]))
      out         <- cbind(out, mdata)
      n_mdata     <- sum(mdata)
      mdata_pcnt  <- mdata / n_mdata * 100
      if(sum(mdata)!=0){
        max_pcnt    <- max(mdata_pcnt, na.rm=T) 
        if(max_pcnt > ymax_updated){
          ymax_updated <- max_pcnt
        }
      }
      ymax      <- YMAX_INIT
      ymax_int  <- ceiling(max(mdata)/100) * 100
      if(ymax_int > ymax){
        ymax <- ymax_int
      }
      tickbin_y   <- ymax/2
      labelbin_y  <- ymax/1
      plot(1, 1, xlim=c(0, XMAX), ylim=c(0, ymax), 
           type="n", xaxs="i", yaxs="i", axes=F, ann=F)
      polygon(c(0, BORDER_KAERI_KOBA, BORDER_KAERI_KOBA, 0),
              c(0, 0, ymax, ymax), col=COL_KAERI, border=F)
      polygon(c(BORDER_KAERI_KOBA, BORDER_KOBA_CHUBA, BORDER_KOBA_CHUBA, BORDER_KAERI_KOBA), 
              c(0, 0, ymax, ymax), col=COL_KOBA, border=F)
      polygon(c(BORDER_KOBA_CHUBA, BORDER_CHUBA_OHBA, BORDER_CHUBA_OHBA, BORDER_KOBA_CHUBA),
              c(0, 0, ymax, ymax), col=COL_CHUBA, border=F)
      polygon(c(BORDER_CHUBA_OHBA, XMAX, XMAX, BORDER_CHUBA_OHBA), 
              c(0, 0, ymax, ymax), col=COL_OHBA, border=F)
      m_alkey0  <- AGE_LENGTH_KEY_0[, m]
      m_alkey1  <- AGE_LENGTH_KEY_1[, m]
      m_alkey2  <- AGE_LENGTH_KEY_2[, m]
      bottom0   <- rep(0, length(m_alkey0))
      top0      <- m_alkey0 * mdata
      bottom1   <- top0
      top1      <- (bottom1 + m_alkey1 * mdata)
      bottom2   <- top1 
      top2      <- (bottom2 + m_alkey2 * mdata)
      rect(CLASS_LEFT, bottom0, CLASS_LEFT + BARWIDTH, top0, col=COL0, border=F)
      rect(CLASS_LEFT, bottom1, CLASS_LEFT + BARWIDTH, top1, col=COL1, border=F)
      rect(CLASS_LEFT, bottom2, CLASS_LEFT + BARWIDTH, top2, col=COL2, border=F)
      # rect(CLASS_LEFT, rep(0, length(CLASS_LEFT)), CLASS_LEFT + BARWIDTH, mdata_pcnt, col=COL_FILL, border=F)
      axis(1, at=seq(0, XMAX, TICKBIN_X * 10), labels=F, tcl=TICKLEN_X)
      # axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
      axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax), tcl=0, labels=F)
      axis(2, at=seq(0, ymax, tickbin_y), labels=F, tcl=TICKLEN_Y)
      axis(2, at=seq(0, ymax, labelbin_y), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax, labelbin_y), labels=T, las=2, pos=4, col="transparent")
    }
    out           <- as.data.frame(out)
    colnames(out) <- month.abb[1:ncol(out)]
    rownames(out) <- CLASS_NAME
    if (exists("wb") == TRUE){
      rm(wb)
    }
    gc(); gc()
  }
  dev.off()
  print(paste("max % is", ceiling(ymax_updated)))

  pdf(paste("../output/gyokaikyo_", YEAR, "年3月_体長組成_4月スタート.pdf", sep=""), family="Helvetica", width=9, height=6)
  par(mfcol=c(12, 3), mai=c(0.1, 0.4, 0.05, 0.1), ps=20, oma=c(0, 0, 0.5, 0))
  for(y in (YEAR - 2):YEAR - 1){
    ychar     <- substr(y, 3, 4)
    yfilename <- paste("★カタクチ", ychar, ".xls", sep = "")
    wb        <- loadWorkbook(yfilename)
    data      <- readWorksheetFromFile(yfilename, sheet = SHEETNAME)
    out       <- NULL
    for(m in 4:12){
      mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, 3 + m - 1]))
      out         <- cbind(out, mdata)
      n_mdata     <- sum(mdata)
      mdata_pcnt  <- mdata / n_mdata * 100
      if(sum(mdata)!=0){
        max_pcnt    <- max(mdata_pcnt, na.rm=T) 
        if(max_pcnt > ymax_updated){
          ymax_updated <- max_pcnt
        }
      }
      ymax      <- YMAX_INIT
      ymax_int  <- ceiling(max(mdata)/100) * 100
      if(ymax_int > ymax){
        ymax <- ymax_int
      }
      tickbin_y   <- ymax/2
      labelbin_y  <- ymax/1
      plot(1, 1, xlim=c(0, XMAX), ylim=c(0, ymax), type="n", xaxs="i", yaxs="i", axes=F, ann=F)
      polygon(c(0, BORDER_KAERI_KOBA, BORDER_KAERI_KOBA, 0), c(0, 0, ymax, ymax), col=COL_KAERI, border=F)
      polygon(c(BORDER_KAERI_KOBA, BORDER_KOBA_CHUBA, BORDER_KOBA_CHUBA, BORDER_KAERI_KOBA), c(0, 0, ymax, ymax), col=COL_KOBA, border=F)
      polygon(c(BORDER_KOBA_CHUBA, BORDER_CHUBA_OHBA, BORDER_CHUBA_OHBA, BORDER_KOBA_CHUBA), c(0, 0, ymax, ymax), col=COL_CHUBA, border=F)
      polygon(c(BORDER_CHUBA_OHBA, XMAX, XMAX, BORDER_CHUBA_OHBA), c(0, 0, ymax, ymax), col=COL_OHBA, border=F)
      m_alkey0  <- AGE_LENGTH_KEY_0[, m]
      m_alkey1  <- AGE_LENGTH_KEY_1[, m]
      m_alkey2  <- AGE_LENGTH_KEY_2[, m]
      bottom0   <- rep(0, length(m_alkey0))
      top0      <- m_alkey0 * mdata
      bottom1   <- top0
      top1      <- (bottom1 + m_alkey1 * mdata)
      bottom2   <- top1 
      top2      <- (bottom2 + m_alkey2 * mdata)
      rect(CLASS_LEFT, bottom0, CLASS_LEFT + BARWIDTH, top0, col=COL0, border=F)
      rect(CLASS_LEFT, bottom1, CLASS_LEFT + BARWIDTH, top1, col=COL1, border=F)
      rect(CLASS_LEFT, bottom2, CLASS_LEFT + BARWIDTH, top2, col=COL2, border=F)
      # rect(CLASS_LEFT, rep(0, length(CLASS_LEFT)), CLASS_LEFT + BARWIDTH, mdata_pcnt, col=COL_FILL, border=F)
      # text(15, ymax/2, paste(ychar, m), cex = 1.5)
      axis(1, at=seq(0, XMAX, TICKBIN_X * 10), labels=F, tcl=TICKLEN_X)
      # axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
      axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax), tcl=0, labels=F)
      axis(2, at=seq(0, ymax, tickbin_y), labels=F, tcl=TICKLEN_Y)
      axis(2, at=seq(0, ymax, labelbin_y), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax, labelbin_y), labels=T, las=2, pos=4, col="transparent")
    }
    if (exists("wb") == TRUE){
      rm(wb)
    }
    gc(); gc()
    if(y != (YEAR - 1)){
      ychar_plus1 <- substr(y + 1, 3, 4)
      yfilename <- paste("★カタクチ", ychar_plus1, ".xls", sep="")
      wb        <- loadWorkbook(yfilename)
      data      <- readWorksheetFromFile(yfilename, sheet=SHEETNAME)
    }
    for(m in 1:3){
      if (y != (YEAR - 1)){
        mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, 3 + m - 1]))
      }else{
        if (m == 3){
          break
        }
        mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, 15 + m - 1]))
      }
      # if(y == 2017 & m == 1){browser()}
      out         <- cbind(out, mdata)
      n_mdata     <- sum(mdata)
      mdata_pcnt  <- mdata / n_mdata * 100
      if(sum(mdata)!=0){
        max_pcnt    <- max(mdata_pcnt, na.rm=T) 
        if(max_pcnt > ymax_updated){
          ymax_updated <- max_pcnt
        }
      }
      ymax      <- YMAX_INIT
      ymax_int  <- ceiling(max(mdata)/100) * 100
      if(ymax_int > ymax){
        ymax <- ymax_int
      }
      tickbin_y   <- ymax/2
      labelbin_y  <- ymax/1
      plot(1, 1, xlim=c(0, XMAX), ylim=c(0, ymax), type="n", xaxs="i", yaxs="i", axes=F, ann=F)
      polygon(c(0, BORDER_KAERI_KOBA, BORDER_KAERI_KOBA, 0), c(0, 0, ymax, ymax), col=COL_KAERI, border=F)
      polygon(c(BORDER_KAERI_KOBA, BORDER_KOBA_CHUBA, BORDER_KOBA_CHUBA, BORDER_KAERI_KOBA), c(0, 0, ymax, ymax), col=COL_KOBA, border=F)
      polygon(c(BORDER_KOBA_CHUBA, BORDER_CHUBA_OHBA, BORDER_CHUBA_OHBA, BORDER_KOBA_CHUBA), c(0, 0, ymax, ymax), col=COL_CHUBA, border=F)
      polygon(c(BORDER_CHUBA_OHBA, XMAX, XMAX, BORDER_CHUBA_OHBA), c(0, 0, ymax, ymax), col=COL_OHBA, border=F)
      m_alkey0  <- AGE_LENGTH_KEY_0[, m]
      m_alkey1  <- AGE_LENGTH_KEY_1[, m]
      m_alkey2  <- AGE_LENGTH_KEY_2[, m]
      bottom0   <- rep(0, length(m_alkey0))
      top0      <- m_alkey0 * mdata
      bottom1   <- top0
      top1      <- (bottom1 + m_alkey1 * mdata)
      bottom2   <- top1 
      top2      <- (bottom2 + m_alkey2 * mdata)
      rect(CLASS_LEFT, bottom0, CLASS_LEFT + BARWIDTH, top0, col=COL0, border=F)
      rect(CLASS_LEFT, bottom1, CLASS_LEFT + BARWIDTH, top1, col=COL1, border=F)
      rect(CLASS_LEFT, bottom2, CLASS_LEFT + BARWIDTH, top2, col=COL2, border=F)
      # rect(CLASS_LEFT, rep(0, length(CLASS_LEFT)), CLASS_LEFT + BARWIDTH, mdata_pcnt, col=COL_FILL, border=F)
      axis(1, at=seq(0, XMAX, TICKBIN_X * 10), labels=F, tcl=TICKLEN_X)
      # axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
      axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax), tcl=0, labels=F)
      axis(2, at=seq(0, ymax, tickbin_y), labels=F, tcl=TICKLEN_Y)
      axis(2, at=seq(0, ymax, labelbin_y), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax, labelbin_y), labels=T, las=2, pos=4, col="transparent")
      # text(15, ymax/2, paste(ychar, m), cex = 1.5)
    }
    # }else{
    out           <- as.data.frame(out)
    colnames(out) <- month.abb[1:ncol(out)]
    rownames(out) <- CLASS_NAME
    if (exists("wb") == TRUE){
      rm(wb)
    }
    gc(); gc()
  }
  dev.off()

  pdf(paste("../output/gyokaikyo_", YEAR, "西海ブロックの漁獲量の推移.pdf", sep=""),
      family="Times", width=8, height=6)
  IWASHI_DATA <- readWorksheetFromFile(IWASHI_FILE, sheet="カタクチイワシ")
  cnt         <- 0
  for(i in 1:nrow(IWASHI_DATA)){
    idata <- as.character(IWASHI_DATA[i, 1])
    if(is.na(idata)==F){
      if(substr(idata, 1, 4)=="1992"){
        # print(idata)
        cnt <- cnt+1
        if(cnt==7){
          # print(i)
          row_start   <- i
          start_year  <- as.numeric(substr(idata, 1, 4))
          row_end     <- row_start + YEAR - start_year
          # print(IWASHI_DATA[row_end, 1])
          break()
        }
      }
    }
  }

  IWASHI_DATA_SEIKAI            <- IWASHI_DATA[row_start:row_end, MONTHS+1]
  out_seikai                    <- NULL
  for(j in  1:ncol(IWASHI_DATA_SEIKAI)){
    out_seikai <- cbind(out_seikai, as.numeric(as.character(IWASHI_DATA_SEIKAI[, j])))
  }
  out_seikai            <- as.data.frame(out_seikai)
  colnames(out_seikai)  <- month.abb
  rownames(out_seikai)  <- start_year:YEAR
  DATA_THISYEAR                 <- out_seikai[nrow(out_seikai),]
  DATA_LASTYEAR                 <- out_seikai[nrow(out_seikai)-1,]
  DATA_RECENTYR                 <- out_seikai[nrow(out_seikai)-(5:1),]
  DATA_LASTYEAR_LOWER           <- as.numeric(DATA_LASTYEAR * 0.8)
  DATA_LASTYEAR_UPPER           <- as.numeric(DATA_LASTYEAR * 1.2)
  RECENT_MAX                    <- apply(DATA_RECENTYR, 2, max)
  RECENT_MIN                    <- apply(DATA_RECENTYR, 2, min)
  RECENT_MEAN                   <- apply(DATA_RECENTYR, 2, mean)
  RECENT_LOWER                  <- RECENT_MEAN * 0.8
  RECENT_UPPER                  <- RECENT_MEAN * 1.2
  # graphic parameters
  COL_FILL      <- hsv(200/360, 0, 0.8, 1)
  COL_MEAN      <- hsv(200/360, 0, 0.8, 1)
  COL_LASTYR    <- hsv(200/360, 0.8, 0.8, 1)
  COL_THISYR    <- hsv(  0/360, 0.8, 0.8, 1)
  XMIN          <- 1
  XMAX          <- 12
  YMAX          <- 4000
  TICKBIN_X     <- 1
  TICKBIN_Y     <- 200
  TICKLEN_X     <- YMAX/100000
  TICKLEN_Y     <- 0.3
  LABELBIN_X    <- 1
  LABELBIN_Y    <- 1000
  plot(MONTHS, RECENT_MAX, type="n", ylim=c(0, max(RECENT_MAX)), axes=F, ann=F, yaxs="i")
  polygon(c(MONTHS, rev(MONTHS)), c(RECENT_LOWER, rev(RECENT_UPPER)), col=COL_FILL, border=F)
  lines(MONTHS, RECENT_MEAN, col=COL_MEAN, lwd=6)
  lines(MONTHS, DATA_LASTYEAR, col=COL_LASTYR, lwd=2)
  arrows(MONTHS, DATA_LASTYEAR_LOWER, MONTHS, DATA_LASTYEAR_UPPER, col=COL_LASTYR, lwd=2, length=0)
  points(MONTHS, DATA_LASTYEAR, col=COL_LASTYR, pch=16, cex=1.5)
  lines(MONTHS, DATA_THISYEAR, col=COL_THISYR, lwd=4)
  points(MONTHS, DATA_THISYEAR, col=COL_THISYR, pch=16, cex=2.5)

  axis(1, at=seq(XMIN, XMAX, LABELBIN_X), tcl=0, labels=F)
  # axis(1, at=seq(XMIN, XMAX, TICKBIN_X), labels=F, tcl=TICKLEN_X)
  # axis(1, at=seq(XMIN, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
  axis(1, at=seq(XMIN, XMAX, LABELBIN_X), labels=month.abb)
  axis(2, at=seq(0, YMAX), tcl=0, labels=F)
  # axis(2, at=seq(0, YMAX, TICKBIN_Y), labels=F, tcl=TICKLEN_Y)
  axis(2, at=seq(0, YMAX, LABELBIN_Y))
  dev.off()

  pdf(paste("../output/gyokaikyo_", YEAR, "4月始まりの漁獲量変動.pdf", sep=""), 
      family="Times", width=8, height=6)
  plot(1:12, ylim=c(0, 6000), axes=F, ann=F, type="n", yaxs="i")
  recent_catch_apr_start <- NULL
  all_mean_apr_start    <- NULL
  for(i in 1:(nrow(out_seikai)-1)){
    year                <- rownames(out_seikai)[i]
    # lines(1:12, c(out_seikai[i, 4:12], out_seikai[i+1, 1:3]), col=hsv(0,0,0.8))
    all_mean_apr_start  <- rbind(all_mean_apr_start, 
                                 t(unlist(c(out_seikai[i, 4:12], 
                                            out_seikai[i+1, 1:3]))))
    if(year >= (YEAR-5) & year <= (YEAR-1)){
      recent_catch_apr_start  <- rbind(recent_catch_apr_start, 
                                      t(unlist(c(out_seikai[i - 1, 4:12], 
                                                 out_seikai[i, 1:3]))))
    }
  }
  all_mean_apr_start                <- as.data.frame(all_mean_apr_start)
  apr_start_this_fiscal             <- cbind(out_seikai[nrow(out_seikai) - 1, 4:12],
                                             out_seikai[nrow(out_seikai),     1: 3])
  apr_start_last_fiscal             <- cbind(out_seikai[nrow(out_seikai) - 2, 4:12],
                                             out_seikai[nrow(out_seikai) - 1, 1: 3])
  recent_catch_apr_start            <- as.data.frame(recent_catch_apr_start)
  rownames(all_mean_apr_start)      <- paste("Fiscal", 
                                             rownames(out_seikai)[1]:(YEAR-1), sep="")
  rownames(recent_catch_apr_start)  <- paste("Fiscal", (YEAR-5):(YEAR-1), sep="")
  mean_value_apr_start              <- colMeans(all_mean_apr_start, na.rm=T)
  recent_mean_apr_start             <- colMeans(recent_catch_apr_start)
  sd_value_apr_start                <- apply(all_mean_apr_start, 2, sd)
  polygon(c(1:12, 12:1), c(recent_mean_apr_start * 0.8, 
                            rev(recent_mean_apr_start)* 1.2), 
          col = COL_MEAN, border=F)
  lines(1:12, recent_mean_apr_start, col = "black", lwd = 2)
  points(1:12, recent_mean_apr_start, col = "black", pch = 16, cex=1)
  lines(1:12, apr_start_last_fiscal , col = COL_LASTYR, lwd = 2)
  points(1:12, apr_start_last_fiscal, col = COL_LASTYR, pch = 16, cex=1)
  lines(1:12, apr_start_this_fiscal , col = COL_THISYR, lwd = 3)
  points(1:12, apr_start_this_fiscal, col = COL_THISYR, pch = 16, cex=2)
  # lines(1:12, colMeans(recent_mean_apr_start, na.rm=T), col = hsv(0, 0, 0.8), lwd = 2)
  # lines(1:12, c(out_seikai[nrow(out_seikai)-1, 4:12], out_seikai[nrow(out_seikai), 1:3]), col = COL_LASTYR, lwd = 3)
  axis(1, at=1:12, labels=c(month.abb[4:12], month.abb[1:3]))
  axis(2)
  dev.off()

  pdf(paste("../output/gyokaikyo_", YEAR, "クラスターごとの漁獲量変動.pdf", sep=""), family="Times", width=8, height=6)
  CLUST_AGNES         <- agnes(out_seikai, stand=T)
  CLUST_DIANA         <- diana(out_seikai, stand=T)
  DATA_CLUSTER        <- out_seikai
  DATA_CLUSTER$group  <- NA
  YEAR_GROUP_A             <- c(1992, 1993, 2015, 2016, 1994)
  YEAR_GROUP_B             <- c(2014, 2017)
  YEAR_GROUP_C             <- c(1995, 2000, 1998, 2011, 2009, 2012, 2001, 2002, 1999, 2003, 2013, 2004, 2010, 2006, 1997)
  YEAR_GROUP_D             <- c(1996, 2007, 2005, 2008)
  for(i in 1:nrow(DATA_CLUSTER)){
    year  <- rownames(DATA_CLUSTER[i, ])
    if(year %in% YEAR_GROUP_A){
      group <- "a"
    }
    if(year %in% YEAR_GROUP_B){
      group <- "b"
    }
    if(year %in% YEAR_GROUP_C){
      group <- "c"
    }
    if(year %in% YEAR_GROUP_D){
      group <- "d"
    }
    DATA_CLUSTER[i, "group"]  <- group
  }
  GROUP_A <- subset(DATA_CLUSTER, group=="a")
  GROUP_B <- subset(DATA_CLUSTER, group=="b")
  GROUP_C <- subset(DATA_CLUSTER, group=="c")
  GROUP_D <- subset(DATA_CLUSTER, group=="d")
  COLA    <- hsv(  0/360, 0.8, 0.8)
  COLB    <- hsv( 80/360, 0.8, 0.8)
  COLC    <- hsv(180/360, 0.8, 0.8)
  COLD    <- hsv(290/360, 0.8, 0.8)
  plot(1:12, DATA_CLUSTER[1, -13], type="n", ylim=c(0, 3500))
  lines(1:12, colMeans(GROUP_A[, -13]), col=COLA, lwd=2)
  lines(1:12, colMeans(GROUP_B[, -13]), col=COLB, lwd=2)
  lines(1:12, colMeans(GROUP_C[, -13]), col=COLC, lwd=2)
  lines(1:12, colMeans(GROUP_D[, -13]), col=COLD, lwd=2)
  dev.off()

  # 各県ごとの4–8月漁獲量
  YMAX          <- 8000
  TICKBIN_Y     <- 2000
  TICKLEN_X     <- YMAX/100000
  TICKLEN_Y     <- 0.3
  LABELBIN_Y    <- 2000
  pdf(paste("../output/gyokaikyo_", YEAR, "各県の4–8月漁獲量.pdf", sep=""), family="Times", width=8, height=6)
  plot(1,1, type="n", xlim=c(1, 18), ylim=c(0, 8000), axes=F, ann=F)
  for(i in seq(2, 8, 2)){
    abline(h = 1000*i, lty=2)
  }
  out_last_this_kakuken   <- NULL
  out_recent_max_kakuken  <- NULL
  out_recent_min_kakuken  <- NULL
  out_recent_ave_kakuken  <- NULL
  COLPOS_APR_AUG          <- 5:9
  IWASHI_DATA <- readWorksheetFromFile(IWASHI_FILE, sheet="カタクチイワシ")
  cnt <- 0
  for(i in 1:nrow(IWASHI_DATA)){
    idata <- as.character(IWASHI_DATA[i, 1])
    if(is.na(idata)==F){
      if(substr(idata, 1, 4)=="1992"){
        cnt <- cnt+1
        if(cnt!=7){
          # print(i)
          row_start         <- i
          start_year        <- as.numeric(substr(idata, 1, 4))
          row_end           <- row_start + YEAR - start_year
          row_recent        <- row_end - (5:1)
          zenki_thisyr      <- sum(as.numeric(gsub(",","",as.character(IWASHI_DATA[row_end, COLPOS_APR_AUG]))))
          zenki_lastyr      <- sum(as.numeric(gsub(",","",as.character(IWASHI_DATA[row_end - 1, COLPOS_APR_AUG]))))
          lastyr_upper      <- zenki_lastyr * 1.2
          lastyr_lower      <- zenki_lastyr * 0.8
          zenki_recent      <- IWASHI_DATA[row_recent, COLPOS_APR_AUG]
          out_sum_apr_aug   <- NULL
          for(ii in 1:nrow(zenki_recent)){
            sum_apr_aug     <- sum(as.numeric(gsub(",","",as.character(zenki_recent[ii,]))))
            out_sum_apr_aug <- append(out_sum_apr_aug, sum_apr_aug)
          }
          zenki_max         <- max(out_sum_apr_aug, na.rm=T)
          zenki_min         <- min(out_sum_apr_aug, na.rm=T)
          zenki_ave         <- mean(out_sum_apr_aug, na.rm=T)
          recent_lower      <- zenki_ave * 0.8
          recent_upper      <- zenki_ave * 1.2
          polygon(c((3*(cnt-1)):(3*(cnt-1)+1)+1,(3*(cnt-1)+1):(3*(cnt-1))+1), c(rep(recent_lower, 2), rep(recent_upper, 2)), col=COL_FILL, border=F)
          lines((3*(cnt-1)):(3*(cnt-1)+1)+1,  rep(zenki_ave, 2), col=COL_MEAN, lwd=6)
          lines((3*(cnt-1)):(3*(cnt-1)+1)+1,  c(zenki_lastyr, zenki_thisyr), lwd=3)
          arrows(3*(cnt-1)+1, lastyr_lower, 3*(cnt-1)+1, lastyr_upper, length=0, col=COL2, lwd=2)
          points((3*(cnt-1)):(3*(cnt-1)+1)+1,  c(zenki_lastyr, zenki_thisyr), pch=16, col=c(COL2, COL1), cex=c(1.5, 2.5))
        }
      }
    }
  }
  axis(2, at=seq(0, YMAX), tcl=0, labels=F)
  axis(2, at=seq(0, YMAX, LABELBIN_Y))
  dev.off()

  # 資源量
  pdf(paste("../output/gyokaikyo_", YEAR, "親魚量.pdf", sep=""), family="Times", width=8, height=6)
  XMIN          <- 1980
  XMAX          <- 2020
  YMAX          <- 250
  BLIMIT        <- 91
  TICKBIN_Y     <- 50
  TICKLEN_X     <- YMAX/100000
  TICKLEN_Y     <- 0.3
  LABELBIN_X    <- 5
  LABELBIN_Y    <- 100
  plot(DATA$year, DATA$ssb/1000, ylim=c(0, YMAX), type="n", axes=F, ann=F, yaxs="i")
  abline(h=BLIMIT, lwd=2,  lty=2)
  lines(DATA$year, DATA$ssb/1000, lwd=4)
  points(DATA$year, DATA$ssb/1000, pch=16, cex=2)
  axis(1, at=seq(XMIN, XMAX, LABELBIN_X), tcl=0, labels=F)
  # axis(1, at=seq(XMIN, XMAX, TICKBIN_X), labels=F, tcl=TICKLEN_X)
  # axis(1, at=seq(XMIN, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
  axis(1, at=seq(XMIN, XMAX, LABELBIN_X))
  axis(2, at=seq(0, YMAX), tcl=0, labels=F)
  # axis(2, at=seq(0, YMAX, TICKBIN_Y), labels=F, tcl=TICKLEN_Y)
  axis(2, at=seq(0, YMAX, LABELBIN_Y))
  dev.off()


#+END_SRC
** 漁況予測
*** GLMによる予測
どの変数も効いていない
#+BEGIN_SRC R
  # 漁海況予報会議のためのコード：カタクチイワシ3月時点の予報（黒田作成・林責任）
  # 一般化線形モデルを用いて、4–8月の水揚量を説明。漁獲量の予測値±95%信頼区間を表示

  library(MuMIn)

  # データ読み込み
  data_org <- read.csv("/Users/ahayashi/Documents/work/gyokaikyo_2019_katakuchi_data_190314.csv",
                       header = TRUE)

  yr2pred <- 2019
  period2use  <- 10
  last_row <- which(data_org$year == yr2pred) # 2018
  first_row <- last_row - period2use

  data        <- data_org[first_row:last_row, ]
  data_minus1 <- data[1:(nrow(data) - 1), ]
  data_recent <- data_minus1[(nrow(data_minus1) - 4):(nrow(data_minus1)), ]
  recent_lower  <- mean(data_recent$catch49) * 0.8
  recent_upper  <- mean(data_recent$catch49) * 1.2

  resglm <- glm(catch49 ~ catch1 + catch11 + catch12 + catch111 +
                  temp11 + temp12 + temp1 + temp2 + bio,
                family = gaussian(link = "identity"),
                    data = data_minus1)
  MASS::stepAIC(resglm)
  summary(resglm)

  prediction  <- predict(resglm, newdata = data.frame(catch1 = data$catch1),
                         se.fit = TRUE, type = "response",
                         na.action = "na.fail")
  uconf  <- prediction$fit + prediction$se.fit * 1.96
  lconf  <- prediction$fit - prediction$se.fit * 1.96
  summary(resglm)
  as.numeric(resglm$fitted.values)


  color.model.shade <- hsv( 20/360, 0.2, 0.9)
  color.model       <- hsv( 20/360, 0.8, 0.9)
  col.lastyr        <- hsv(200/360, 0.8, 0.9)
  min.catch         <- 5000
  max.catch         <- 20000

  # png(paste("/Volumes/評価研/個人的データ置き場/hayashi/output/figs/gkk", yr2pred, "年3月_漁獲量予測.png"),
  #     width = 1300, height = 800)
  # plot(data_minus1$year, data_minus1$catch49,
  #      xlim = c(min(data$year), max(data$year)),
  #      ylim=c(min.catch, max.catch), type = "n", axes = FALSE, ann = FALSE)
  # polygon(c(data$year, rev(data$year)),
  #         c(uconf, rev(lconf)), col = color.model.shade, border = FALSE)
  # lines(data$year, prediction$fit, col = COLOR.MODEL, lwd = 8)
  # lines(data.minus1$year, data.minus1$catch49, lwd = 4)
  # points(data.minus1$year, data.minus1$catch49, pch = 16, cex = 3)
  # lines(min(data.recent$year):year.to.predict, rep(recent.lower,
  #                                             nrow(data.recent) + 1), lty = 2, lwd = 4)
  # lines(min(data.recent$year):year.to.predict, rep(recent.upper,
  #                                             nrow(data.recent) + 1), lty = 2, lwd = 4)
  # arrows((year.to.predict - 1), data.minus1[nrow(data.minus1), "catch49"] * 1.2,
  #        (year.to.predict - 1), data.minus1[nrow(data.minus1), "catch49"] * 0.8,
  #       length = 0, col = COL.LASTYR, lwd = 4)
  # points((year.to.predict - 1), data.minus1[nrow(data.minus1), "catch49"]
  #        , pch = 16, col = COL.LASTYR, cex = 4)
  # points(max(data$year), prediction$fit[nrow(data)],
  #        col = COLOR.MODEL, pch = 16, cex = 6)
  # axis(1, data$year, tcl = -0.6, lwd = 4, labels = FALSE)
  # axis(1, data$year[(data$year %% 5) == 0], tcl = -1.6, lwd = 4, labels = FALSE)
  # axis(2, seq(MIN.CATCH, MAX.CATCH, 5000), lwd = 4, tcl = -1.6, labels = FALSE)
  # dev.off()
#+END_SRC
*** 時系列解析による予測
#+BEGIN_SRC R
  # load packages ------------------------------------------------------------
  library(tidyverse)
  library(zoo)
  library(xts)
  library(lubridate)
  library(urca)
  library(forecast)
  library(tseries)
  library(ggfortify)
  source("_bk/fmtcatch/R/make_list.R")
  source("_bk/fmtcatch/R/plot_figs.R")
  source("_bk/fmtcatch/R/get_temp.R")

  # Load data ------------------------------------------------------------
  stacdata <- read_csv("/Users/ahayashi/Dropbox/Imported/Stock/Timeseries_TW_Engraulis-japonicus.csv") %>%
    rename(year = Year,
           biomass = `B_10^3ton`) %>%
    dplyr::select(year, biomass)

  sstdata <- get_tw_sst("data.git/水温データ/mgdsst_till201902.xlsx", 2018)

  list_catchdata <- iwashi2list(path = "/Volumes/評価研/漁海況/2019年3月/漁況資料作成/いわし/各県いわし_林20190312.xlsx",
                                sheet = "カタクチイワシ",
                                year.end = 2019)
  seikai <- summarize_seikai(list_catchdata)


  db   <- seikai %>%
    tidyr::gather(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec,
                  key = month, value = catch) %>%
    dplyr::mutate(month = abb2num(month)) %>%
    left_join(sstdata, key = c(year, month)) %>%
    left_join(stacdata, key = year) %>%
    mutate(day = 1,
           date = make_date(year, month, day))

  data <- readRDS("_bk/fmtcatch/output/西海ブロック漁獲量2018.rds")
  db   <- make_database(data) %>%
  db2 <- left_join(db, sstdata, key = c(year, month))
  db3 <- left_join(db2, stacdata, key = year)

  blank_data <- data_frame(year = 2019,
                           month = 1:3,
                           tw_degc = NA,
                           biomass = NA)

  seikai_org <- db %>%
    group_by(year, month, tw_degc, biomass) %>%
    summarize(logcatch = log(sum(catch, na.rm = TRUE))) %>%
    as.data.frame()

  seikai <- db %>%
    filter(year < 2019) %>%
    group_by(year, month, tw_degc, biomass) %>%
    summarize(logcatch = log(sum(catch, na.rm = TRUE))) %>%
    as.data.frame()

  seikai_year <- seikai %>%
    group_by(year) %>%
    summarize(sum = sum(logcatch))

  seikai_ts <- seikai %>%
    dplyr::select(logcatch) %>%
    unlist() %>%
    ts(start = min(db$year), frequency = 12)

  seikai_sst <- seikai %>%
    dplyr::select(tw_degc) %>%
    unlist() %>%
    ts(start = min(db$year), frequency = 12)

  seikai_b <- seikai %>%
    dplyr::select(biomass) %>%
    unlist() %>%
    ts(start = min(db$year), frequency = 12)
  xvars <- cbind(seikai_sst, seikai_b)

  # autoplot(seikai_ts)
  # autoplot(seikai_sst)

  # analysis ------------------------------------------------------------

  ndiffs(seikai_ts) # No lag is needed
  ggtsdisplay(seikai_ts)

  ggsubseriesplot(seikai_ts)

  seikai_ts_seas <- diff(seikai_ts, lag = frequency(seikai_ts))
  ggtsdisplay(seikai_ts_seas)
  acf(seikai_ts_seas, plot = FALSE, lag.max = 12)


  train       <- window(seikai_ts,  end = c(2016, 12))
  xvars_train <- window(xvars, end = c(2016, 12))
  test        <- window(seikai_ts,  start = c(2017, 1), end = c(2017, 12))
  xvars_test  <- window(xvars, start = c(2017, 1), end = c(2017, 12))

  # Build model ----------------------------------------------------------------------
  model_sarimax <- auto.arima(y = seikai_ts,
  #                            y = train,
  #                            xreg = xvars_train,
                              ic = "aicc",
                              max.order = 8,
                              stepwise = FALSE,
                              approximation = FALSE,
                              parallel = TRUE,
                              num.cores = 4)
  model_sarimax

  abs(polyroot(c(1, -coef(model_sarimax)[c("ar1")]))) # ok
  abs(polyroot(c(1,  coef(model_sarimax)[c("ma1")]))) # ok
  checkresiduals(model_sarimax)
  jarque.bera.test(resid(model_sarimax)) # Not good. Residuals do not distribute normally (p < 0.001).

  # Validation of the model ------------------------------------------------------------

  model_valid <- forecast(model_sarimax,
  #                           xreg = xvars_test,
                             h = 24,
                             level = c(95, 70))
  model_valid
  mean(model_valid$mean[11:15])
  mean(model_valid$lower[11:15])
  mean(model_valid$upper[11:15])
  p <- autoplot(model_valid, predict.color = 1)
  ggsave("../../figs/tsplot.png", family = "Helvetica")

  xvar_mean <- data.frame(tw_degc = rep(mean(xvars_train[,"seikai_sst"], na.rm = TRUE), 12),
                          biomass = rep(mean(xvars_train[,"seikai_b"])))
  fc_mean  <- forecast(model_sarimax,
                       xreg = xvar_mean,
                       h = 12,
                       level = c(95, 70))
  autoplot(fc_mean, predict.color = 1)

  xvar_tail <- data.frame(tw_degc = rep(tail(xvars_train[,"seikai_sst"], n = 1), 12),
                          biomass = rep(tail(xvars_train[,"seikai_b"], n = 1), 12))
  fc_tail  <- forecast(model_sarimax,
                       xreg = xvar_tail,
                       h = 24,
                       level = c(95, 70))
  autoplot(fc_tail, predict.color = 1)

  g <- autoplot(model_valid)
  real2017 <- data.frame(date = seq.Date(as.Date("2017-01-01"), as.Date("2017-12-01"), by = "month"), logcatch = test)
  g <- g + geom_point(data = real2017, aes(date, logcatch))
  real2018 <- data.frame(date = seq.Date(as.Date("2018-01-01"), as.Date("2018-12-01"), by = "month"),
                         logcatch = window(seikai_ts,  start = c(2018, 1), end = c(2018, 12)))
  g <- g + geom_point(data = real2018, aes(date, logcatch), color = "red")
  g

  gm <- autoplot(fc_mean)
  real2017 <- data.frame(date = seq.Date(as.Date("2017-01-01"), as.Date("2017-12-01"), by = "month"), logcatch = test)
  gm <- gm + geom_point(data = real2017, aes(date, logcatch))
  gm

  gt <- autoplot(fc_tail)
  real2017 <- data.frame(date = seq.Date(as.Date("2017-01-01"), as.Date("2017-12-01"), by = "month"), logcatch = test)
  gt <- gt + geom_point(data = real2017, aes(date, logcatch))
  gt

  naive <- meanf(train, h = 12)

  rmse_valid <- sqrt(sum((model_valid$mean - test)^2) / length(model_valid$mean))
  rmse_valid
  accuracy(naive, x = test)["Test set", "RMSE"]
  accuracy(model_valid, x = test)["Test set", "RMSE"] # better than naive model
  accuracy(fc_mean, x = test)["Test set", "RMSE"]
  accuracy(fc_tail, x = test)["Test set", "RMSE"] # best

  model_valid$mean
  str(model_valid)


  # Plot by year ------------------------------------------------------------
  res_valid <- data.frame(year = rep(2017, 12),
                            month = month.abb,
                            logcatch = model_valid$mean,
                            lwr = model_valid$lower,
                            upr = model_valid$upper) %>%
    group_by(year) %>%
    summarize(sum = sum(logcatch),
              upr = sum(upr.95.),
              lwr = sum(lwr.95.))

  years <- seikai %>%
    filter(year < 2017) %>%
    select(year) %>%
    unlist()
  years
  length(unique(years))
  nrow(seikai)

  res_train   <- data.frame(year = years,
                            month = rep(month.abb, length(unique(years))),
                            logcatch = as.numeric(model_sarimax$fitted),
                            upper = model_sarimax$fitted + 1.96 * sqrt(model_sarimax$sigma2),
                            lower = model_sarimax$fitted - 1.96 * sqrt(model_sarimax$sigma2)) %>%
    group_by(year) %>%
    summarize(sum = sum(logcatch),
              upr = sum(upper),
              lwr = sum(lower))

  res <- bind_rows(res_train, res_valid)

  p <- res %>%
    ggplot(aes(year, sum)) +
    geom_ribbon(aes(ymin = lwr, ymax = upr), fill = hsv(200/360, 0.8, 0.8, 0.4)) +
    geom_line(color = hsv(200/360, 0.8, 0.8))
  p <- p + geom_point(data = seikai_year, aes(year, sum))
  p

  dat.forecast <- data.frame(biomass = rep(tail(stacdata$biomass, 1), 24),
                             tw_degc = rep(filter(sstdata, year==2017)$tw_degc, 2)) %>%
    ts(start = 2016, frequency = 12)
  dat.forecast

  ts.plot(model_sarimax$fit, train, col = c(3, 1))

#+END_SRC
*** 問題点
各県いわしに依存している．
catch49など，手作業が介在
* ディレクトリの構成
R パッケージのディレクトリは全て GitHub で公開する．
ただし，以下のディレクトリは GitHub にはアップロードせず，ローカルで管理する（リモートリポジトリを GitHub ではなく，NAS に設定する）．
- data.git/: 各県から提供されたデータ．
- docs.git/: 予報文案など．
  
* パッケージの機能
** データ目録の生成
** データの統合
** グラフ描画
- 漁獲量
- 体長組成
** 予報文案テンプレートの生成
何らかの構造化マークアップ言語の形式で．
できるだけタグが短いもの．
マークダウンが有力か？
* 使い方デモ
** 体長組成整理
#+BEGIN_SRC R
  library(gyokaikyor)
  library(dplyr)
  library(hash)
  library(ggplot2)
  fname  <- c("data.git/漁海況/2018年10月/各県資料/熊本県/05 H29体長組成 まき網＆棒受網（熊本県）.xlsx",
              "data.git/漁海況/2019年3月/各県資料/熊本県/04_H30_まき網＆棒受網体長組成.xlsx",
              "data.git/漁海況/2018年3月/各県資料/長崎県/2017.09-2018.01小型まき網体長組成.xls",
              "data.git/漁海況/2018年10月/各県資料/長崎県/2018.02-2018.08小型まき網体長組成.xls",
              "data.git/漁海況/2019年3月/各県資料/長崎県/2018.09-2019.01小型まき網体長組成.xls",
              "data.git/漁海況/2018年10月/各県資料/鹿児島県/体長組成(H29年度).xlsx",
              "data.git/漁海況/2019年3月/各県資料/鹿児島県/体長組成(H30年度).xlsx")
  prefec <- c(rep("kumamoto", 2), rep("nagasaki", 3), rep("kagoshima", 2))
  tbl_fname <- hash(fname, prefec)
  fname2 <- give_class(fname, tbl_fname)

  kumamoto_nested <- dplyr::bind_rows(fmtbl(fname2[[1]], spcs = "katakuchi"),
                                      fmtbl(fname2[[2]], spcs = "katakuchi"))
  kumamoto        <- dplyr::bind_rows(fmtbl(fname2[[1]], spcs = "katakuchi",
                                            nest = FALSE),
                                      fmtbl(fname2[[2]], spcs = "katakuchi",
                                            nest = FALSE))
  # kumamoto        <- fmtbl(fname2[[1]], spcs = "maiwashi", nest = FALSE)
  nagasaki_nested  <- dplyr::bind_rows(fmtbl(fname2[[3]], spcs = "katakuchi"),
                                       fmtbl(fname2[[4]], spcs = "katakuchi"),
                                       fmtbl(fname2[[5]], spcs = "katakuchi"))
  nagasaki  <- dplyr::bind_rows(fmtbl(fname2[[3]], spcs = "katakuchi",
                                      nest = FALSE),
                                fmtbl(fname2[[4]], spcs = "katakuchi",
                                      nest = FALSE),
                                fmtbl(fname2[[5]], spcs = "katakuchi",
                                      nest = FALSE))
  kagoshima_nested <- dplyr::bind_rows(fmtbl(fname2[[6]], spcs = "katakuchi"),
                                      fmtbl(fname2[[7]], spcs = "katakuchi"))
  kagoshima        <- dplyr::bind_rows(fmtbl(fname2[[6]], spcs = "katakuchi",
                                            nest = FALSE),
                                      fmtbl(fname2[[7]], spcs = "katakuchi",
                                            nest = FALSE))

  kumamoto %>%
    ggplot(aes(bl, fill = as.factor(month))) +
    geom_histogram() +
    facet_grid(month ~ year, scale = "free_y")


  seikai_seimitsu   <- fmtbl_fresco("data.git/fresco/2019Mar_seikai_seimitsu_katakuchi.csv", type = "seimitsu",
                                    date.start = "20180101", date.end = "20190331")
  nihonkai_seimitsu <- fmtbl_fresco("data.git/fresco/2019Mar_nihonkai_seimitsu_katakuchi.csv", type = "seimitsu",
                                    date.start = "20180101", date.end = "20190331")
  seikai_taichou    <- fmtbl_fresco("data.git/fresco/2019Mar_seikai_taichou_katakuchi.csv", type = "taichou",
                                    date.start = "20180101", date.end = "20190331")
  nihonkai_taichou  <- fmtbl_fresco("data.git/fresco/2019Mar_nihonkai_taichou_katakuchi.csv", type = "taichou",
                                    date.start = "20180101", date.end = "20190331")
  fresco_seimitsu   <- dplyr::bind_rows(seikai_seimitsu, nihonkai_seimitsu)
  fresco_taichou    <- dplyr::bind_rows(seikai_taichou, nihonkai_taichou)


  # yamaguchi
  conv2hoshifile(df = fresco_seimitsu, prefec = "yamaguchi",
                 type = "seimitsu", 201801, 201903,
                 export = TRUE, fname = "gkk_2019Mar_bl_yamaguchi.csv")
  # conv2hoshifile(df = fresco_taichou, prefec = "yamaguchi",
  #                type = "taichou", 201801, 201903)

  # fukuoka & saga
  # no data

  # nagasaki
  conv2hoshifile(df = nagasaki, prefec = "nagasaki",
                 type = "taichou", 201801, 201903,
                 export = TRUE, fname = "gkk_2019Mar_bl_nagasaki.csv")

  # kumamoto
  kumamoto %>%
    dplyr::filter(type == "まき網") %>%
    conv2hoshifile(prefec = "kumamoto",
                 type = "seimitsu", 201801, 201903,
                 export = TRUE, fname = "gkk_2019Mar_bl_kumamoto_maki.csv")
  conv2hoshifile(df = kumamoto, prefec = "kumamoto",
                 type = "seimitsu", 201801, 201903,
                 export = TRUE, fname = "gkk_2019Mar_bl_kumamoto_all.csv")
  # kagoshima
  kagoshima %>%
    dplyr::filter(grepl("まき", type)) %>%
    conv2hoshifile(prefec = "kagoshima",
                   type = "taichou", 201801, 201903,
                   export = TRUE, fname = "gkk_2019Mar_bl_kagoshima_maki.csv")

  conv2hoshifile(df = kagoshima, prefec = "kagoshima",
                 type = "taichou", 201801, 201903,
                 export = TRUE, fname = "gkk_2019Mar_bl_kagoshima_all.csv")


  # seikai
  #no data

#+END_SRC
** 漁獲量整理
#+BEGIN_SRC R
  library(hash)
  library(dplyr)
  library(ggplot2)
  fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/01_H30まき網漁獲量（熊本県）.xls",
              "data.git/漁海況/2019年3月/各県資料/熊本県/02_H30棒受網漁獲量（熊本県）.xls",
              "data.git/漁海況/2019年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls",
              "./data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls",
              "./data.git/漁海況/2019年3月/各県資料/長崎県/奈留漁協ｲﾜｼ類（中小旋）とりまとめ.xlsx",
              "./data.git/漁海況/2019年3月/各県資料/長崎県/九十九島漁協ｲﾜｼ類(中小まき)とりまとめ.xlsx",
              "data.git/漁海況/2019年3月/各県資料/鹿児島県/４港月計表（30年度）.xlsx",
              "data.git/漁海況/2019年3月/各県資料/佐賀県/➁佐賀県_予報対象種漁獲量（元データ）.xls",
              "data.git/漁海況/2019年3月/各県資料/福岡県/2019-3月送付_S51_H30経年福岡漁獲量データ(提出分).xlsx",
              "data.git/漁海況/2019年3月/各県資料/山口県/2018-2019湊銘柄別水揚市場調査表.xlsx")

  prefec <- c(rep("kumamoto", 2),
             rep("nagasaki", 4),
             "kagoshima",
             "saga",
             "fukuoka",
             "yamaguchi")
  tbl_fname <- hash(fname, prefec)

  fname2 <- give_class(fname, tbl_fname)
  fname2[[1]]
  fname2[[2]]
  fname2[[3]]
  fname2[[4]]
  fname2[[5]]
  fname2[[6]]
  fname2[[7]]
  fname2[[8]]
  fname2[[9]]
  fname2[[10]]

  spcs <- "katakuchi"

  km_maki <- fmtcatch(fname2[[1]], spcs = spcs, type = "maki")
  km_bou  <- fmtcatch(fname2[[2]], spcs = spcs, type = "bouuke")
  kumamoto <- dplyr::bind_rows(km_maki, km_bou)
  kumamoto %>% ggplot(aes(month, catch, color = type)) +
    geom_line() +
    facet_wrap(~ year)


  ngs      <- fmtcatch(fname2[[3]], "katakuchi")
  tbn      <- fmtcatch(fname2[[4]], "katakuchi")
  nr       <- fmtcatch(fname2[[5]], "katakuchi")
  kjk      <- fmtcatch(fname2[[6]], "katakuchi")
  nagasaki <- dplyr::bind_rows(ngs, tbn, nr, kjk)

  nagasaki %>% ggplot(aes(month, catch, color = port)) +
    geom_line() +
    facet_wrap(~ year)

  kagoshima <- fmtcatch(fname2[[7]], spcs = spcs)

  sg_kennai  <- fmtcatch(fname2[[8]], spcs = spcs, type = "kennai")
  sg_chumaki <- fmtcatch(fname2[[8]], spcs = spcs, type = "chumaki")
  sg_teichi  <- fmtcatch(fname2[[8]], spcs = spcs, type = "teichi")
  saga       <- dplyr::bind_rows(sg_kennai, sg_chumaki, sg_teichi)

  saga %>% ggplot(aes(month, catch, color = type)) +
    geom_line() +
    facet_wrap(~ year)

  fk_maki  <- fmtcatch(fname2[[9]], spcs = spcs, type = "maki")
  fk_bou   <- fmtcatch(fname2[[9]], spcs = spcs, type = "bouuke")
  fk_other <- fmtcatch(fname2[[9]], spcs = spcs, type = "others")
  fukuoka  <- dplyr::bind_rows(fk_maki, fk_bou, fk_other)
  fukuoka %>% ggplot(aes(month, catch, color = type)) +
    geom_line() +
    facet_wrap(~ year)

  yamaguchi <- fmtcatch(fname2[[10]], spcs = spcs)
  yamaguchi %>% ggplot(aes(month, catch, color = meigara)) +
    geom_line() +
    facet_wrap(year ~ type)

  catch_all <- dplyr::bind_rows(yamaguchi, fukuoka, saga,
                                nagasaki, kumamoto, kagoshima)

  catch_all %>%
    filter(year >= 2018) %>%
    ggplot(aes(month, catch)) +
    geom_line() +
    facet_grid(year ~ prefecture)


  export2kakuken_iwashi <- function(df, export.csv = FALSE, fname = NULL) {
    out <- tribble(~year,
                   ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`,
                   ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`)
    df2 <- df %>%
      tidyr::spread(key = month, value = catch)
    out %<>% right_join(df2)
    if (export.csv == TRUE) {
      write.csv(out,
                paste0("/Volumes/評価研/個人的データ置き場/hayashi/output/",
                       fname),
                row.names = FALSE)
    }
    out
  }

  yamaguchi %>%
    group_by(year, month) %>%
    summarize(catch = sum(catch, na.rm = TRUE)) %>%
    export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_yamaguchi.csv")

  fukuoka %>%
    group_by(year, month) %>%
    summarize(catch = sum(catch, na.rm = TRUE)) %>%
    export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_fukuoka.csv")

  saga %>%
    dplyr::filter(type == "kennai") %>%
    group_by(year, month) %>%
    summarize(catch = sum(catch, na.rm = TRUE)) %>%
    export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_saga.csv")

  nagasaki %>%
    group_by(year, month) %>%
    summarize(catch = sum(catch, na.rm = TRUE)) %>%
    export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_nagasaki.csv")

  kumamoto %>%
    dplyr::filter(type == "maki") %>%
    group_by(year, month) %>%
    summarize(catch = sum(catch, na.rm = TRUE)) %>%
    export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_kumamoto.csv")

  kagoshima %>%
    dplyr::filter(type == "maki4ports") %>%
    group_by(year, month) %>%
    summarize(catch = sum(catch, na.rm = TRUE)) %>%
    export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_kagoshima.csv")
#+END_SRC
** 漁況予測
#+BEGIN_SRC R

#+END_SRC
* 開発環境の整備
#+BEGIN_SRC R :results silent
  # usethis::create_package("gyokaikyor")
  # usethis::use_mit_license("Akira Hayashi")
  # usethis::use_coverage(type = "codecov")
  # usethis::use_lifecycle_badge("experimental")
#+END_SRC
** 本バッケージ内部で使用するパッケージ
#+BEGIN_SRC R :results silent
  usethis::use_package("magrittr", "Imports")
  usethis::use_package("hash")
  usethis::use_package("tibble")
  usethis::use_package("cellranger")
  usethis::use_package("tidyr")
  usethis::use_package("lubridate")
  usethis::use_package("readxl")
  usethis::use_package("readr")
  usethis::use_package("stringr")
  usethis::use_package("purrr")
  usethis::use_dev_package("tinyplyr")
  usethis::use_package("Nippon")
  usethis::use_package("stringi")
  usethis::use_package("dplyr")
  # usethis::use_package("ggplot2", "Imports")
  # usethis::use_package("tibble", "Imports")
  # usethis::use_testthat()
  # usethis::use_pipe()
#+END_SRC

#+BEGIN_SRC sh :exports results :session nil
cat DESCRIPTION
#+END_SRC

#+RESULTS[26e6d91ffe9c3ff5d95f888fb0006e9154a02abb]:
#+begin_example

Package: gyokaikyor
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person(given = "First",
           family = "Last",
           role = c("aut", "cre"),
           email = "first.last@example.com")
Description: What the package does (one paragraph).
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
Imports: 
    magrittr,
    hash,
    tibble,
    cellranger,
    tinyplyr,
    tidyr,
    lubridate,
    purrr,
    readxl,
    stringr,
    Nippon,
    dplyr
Suggests: 
    testthat,
    covr
RoxygenNote: 6.1.1
#+end_example

#+BEGIN_SRC sh :exports results :session nil
cat NAMESPACE
#+END_SRC

#+RESULTS:
: 
: Generated by roxygen2: do not edit by hand
: <>%")
: >%")

* 開発
** 各県ファイルに対して必要な処理概要
*** 体長
**** まず県別に整理
***** 山口
fresco
***** 福岡
カタクチ測定なし
***** 佐賀
fresco
***** DONE 長崎
- シートを読み込む．対象は春と秋とで違う．
  - 3月漁海況: 2017.09-2018.01小型まき網体長組成.xls
  - 10月漁海況: 2018.02-2018.08小型まき網体長組成.xls
- 漁法名をF2から取得
***** DONE 熊本
列方向に続いた精密測定データ．
10月漁海況のときには前年ファイルも一緒に送ってくれる．
- 04 【熊本県】H29まき網＆棒受網 体長組成.xlsx を開く <- *4月始まり*
- 「カタクチ」シートを読み込み
- df.out を初期化
- 日付が入った列（H29.4.30形式）を取得
- 漁法名を取得
- できればその他情報も取得（操業海域・陸揚げ港）
- 測定データ（全長・被鱗体長・体重）を取得
- df.out を初期化
- 過去のデータベースに df.out を結合
- 重複除去
- 新データベースをkumamoto_2018Oct.csv として書き出し
***** DONE 鹿児島
- 体長組成(H29年度).xlsx を開く　<- *4月始まり*
- 「ｶﾀｸﾁ」シートを読み込み
- 日付が入った列を取得
- 漁法名などの情報を取得
- 個体数情報を体長階級ブロックごと取得
- 過去のdbに結合...
**** まとめると
精密，体長のような分け方はしないほうが良い．
あくまでも，関数を部品として作り，各県ごとにそれを組み合わせて使う．
強いて分類するなら，以下のようになる．
- 精密タイプ: 熊本
- 体長タイプ: 長崎，鹿児島
- fresco タイプ: 山口，佐賀
*** 漁獲量
**** 山口
資源評価のデータと，形式が全然違う．
***** ファイルを開く
***** 年シートをパースして年を取得
***** シートを読み込む
***** 各魚種のデータ列を与えてしまう
****** 各魚種の4行目から，銘柄を取得
***** 列Aから月を生成し，各月データの行位置を取得
****** 「抄網」は行オフセット1，「棒受網」は行オフセット2として，各漁業の漁獲量を取得
**** DONE 福岡
***** 全年データが集まったファイルを開く
***** type = 漁業 としてシートにアクセス
***** "KEI"が入った月の列をget_datrow()に渡し，データ行を得る
***** 年と月のベクトルから，データ行だけ抽出して月と年を作る
***** 魚種の列もデータ行だけ抽出する
**** DONE 熊本
***** 漁業種別（まき網 or 棒受け網）のブックを開く
***** ファイル名をパースして漁法を取得
***** 魚種シートにアクセス
***** 年を生成
セルC4から真下に読み，「前年比」が出てきたらストップ
***** 月とデータを一気に読む
ただし年度整理になっているので1〜3月はyear+1年とする
**** DONE 佐賀
熊本と似てる．漁業種別もシートに分かれている
***** シート一覧を取得
***** 正規表現で魚種シートを絞り込み
***** シートから漁法を取得
***** 年を生成
***** 月とデータを一気に読む
熊本と同様，年度になっている
**** DONE 長崎
***** 魚種に応じてファイルを読み込み
****** マアジ・サバ類
****** マサバ・ゴマサバ
****** イワシ類
***** シート名を取得
過去全データが期間別にシートを分けて入っている
****** A列から魚種名を取得し，データ行を決定
****** データ行から漁期の最初の月の列を取得
前期と後期とで，エクセル方眼紙の列構成が違うのでこれが必要
****** 漁獲量を取得
とびとびにではあるが，一定の法則で入力されている．
関数で処理．
****** 合計が一致しているかチェック
**** DONE 鹿児島
***** 「４港計」「阿久根棒受」「内之浦棒受」シートを読み込み
****** 「４港計」シート
******* 第3行からスペース含みの魚種名を探し，列を決定
******* 行オフセット4つの位置にある「４港計」列の値を行方向に12ヶ月分（第5〜16行）取得
****** 「阿久根 or 内之浦棒受」シート
******* 32行目から魚種名を検索して列を決定（行数は変化しない）
******* 行方向に12ヶ月分（第33〜44行），値を取得
** どう問題を解くか
県ごとに，どうしてもデータ処理の振る舞いを変える必要がある
そこで， 各県のファイル名に，県名を属性として与える
#+TBLNAME: tbl_fname_prefec
| fname                                    | prefec   |
|------------------------------------------+----------|
| 03 漁獲努力量（1804~1903）（熊本県）.xls | kumamoto |
| 04 漁獲努力量（1704~1803）（熊本県）.xls | kumamoto |

#+TBLNAME: tbl_prefec_key
| prefec   | key.topleft |
|----------+-------------|
| nagasaki | FL(mm)      |


各県のファイル名を fmtbl() に与えると，データ形式に適した形で整形される．
水面下でデータ型式を読みに行き，ファイル名に属性として付与している

fname <- "04 漁獲努力量（1704~1803）（熊本県）.xls"



*** get_topleft(key = "FL(mm)")
** リロード & 自動テスト
#+BEGIN_SRC R :results silent
  devtools::document(roclets=c('rd', 'collate', 'namespace'))
  devtools::load_all()
  system("R CMD INSTALL --preclean --no-multiarch --with-keep.source .")
  devtools::test()
  lintr::lint_package()
  devtools::check(args = "--as-cran")
  covr::package_coverage()
#+END_SRC

** テストコード
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** テスト/ ファイル名操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_fname.R
  library(gyokaikyor)
  context("Handle file name")
  fn_kumamoto  <- "04 漁獲努力量（1704~1803）（熊本県）.xls"
  fn_kagoshima <- "体長組成(H29年度).xlsx"
  tbl_fname    <- hash::hash(c(fn_kumamoto, fn_kagoshima),
                             c("kumamoto", "kagoshima"))
  test_that("give_class() gives fname its file format as class", {
    expect_is(give_class(fn_kumamoto, tbl_fname), "list")
    expect_is(give_class(fn_kumamoto, tbl_fname)[[1]], "kumamoto")
    expect_is(give_class(fn_kagoshima, tbl_fname)[[1]], "kagoshima")
  })
#+END_SRC
*** テスト/ セル位置取得
#+BEGIN_SRC R :tangle tests/testthat/test_locate_cellpos.R
  library(gyokaikyor)
  context("Locate cell position")

  suppressWarnings(library(tibble))
  df <- tribble(~A, ~B, ~C, ~D,
                NA, NA, NA, 1,
                NA, "name", "value", 2,
                "", "foo", 12, 3,
                "", "bar", 123, 4,
                "", "baz", 1234, 5,
                "", "bum", 12345, 6,
                "", "foo", 12, 7)

  test_that("quot_ring() throws value on given quotient ring", {
    expect_equal(quot_ring(0, 3), 3)
    expect_equal(quot_ring(1, 3), 1)
    expect_equal(quot_ring(2, 3), 2)
    expect_equal(quot_ring(0, 5), 5)
    expect_equal(quot_ring(1, 5), 1)
    expect_equal(quot_ring(2, 5), 2)
    expect_equal(quot_ring(3, 5), 3)
    expect_equal(quot_ring(4, 5), 4)
  })

  test_that("quot2col() throws col position from
   quotient of given match position in matrix", {
    expect_equal(quot2col(3, 0), 3)
    expect_equal(quot2col(3, 1), 4)
    expect_equal(quot2col(4, 1), 5)
    expect_equal(quot2col(5, 1), 6)
    expect_equal(quot2col(5, 2), 6)
  })

  test_that("get_locate_patterns() locates cell position that has given regex", {
    expect_equal(locate_patterns(df, "name"), "$B$2")
    expect_equal(locate_patterns(df, "nam."), "$B$2")
    expect_equal(locate_patterns(df, "foo"), c("$B$3", "$B$7"))
  })

  test_that("get_topleft() locates cell position that has given regex", {
    expect_equal(get_topleft(df, "name"), "$B$2")
    expect_equal(get_topleft(df, "nam."), "$B$2")
    expect_equal(get_topleft(df, "foo"), "$B$3")
  })

  test_that("get_bottomright() locates cell position that has given regex", {
    expect_equal(get_bottomright(df, "12345"), "$C$6")
    expect_equal(get_bottomright(df, "foo"), "$B$7")
  })

  test_that("locate_vecend() locates the end of the vector", {
    expect_equal(locate_vecend(c(1:10, NA, NA, NA)), 10)
    expect_equal(locate_vecend(c(rep(NA, 9), 100, NA, NA, NA)), 10)
  })
  #+END_SRC
*** テスト/ 文字列操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_str.R
  library(gyokaikyor)
  context("Handle string")

  target <-
    c("漁獲年月日", "", "2017.4.20", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.5.19", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.6.23", "操業海域", "八代海", "漁法", "まき網")

  test_that("get_col2load() works well",
            expect_equal(get_col2load(target,
                            regex = "20[0-9]{2}\\.[0-9][0-9]?\\.[0-9][0-9]?",
                            offset = -2),
                         c(1, 8, 15))
            )

  test_that("parse_ym() works well", {
    expect_setequal(parse_ym("2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_setequal(parse_ym("foo/bar/2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_error(parse_ym("20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
    expect_error(parse_ym("foo/bar/20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
  })
#+END_SRC
*** テスト/ 種名生成
#+BEGIN_SRC  R :tangle tests/testthat/test_make_shtname.R
  library(gyokaikyor)
  context("Make shtname of prefecture")

  test_that("make_shtname() makes sheetname for kumamoto data", {
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "sabarui"), "サバ類")
    expect_error(make_shtname(prefec = "kumamoto", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for nagasaki data", {
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "masaba"), "マサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "gomasaba"), "ゴマサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maaji"), "マアジ")
    expect_error(make_shtname(prefec = "nagasaki", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for kagoshima data", {
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "katakuchi"), "ｶﾀｸﾁ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "urume"), "ｳﾙﾒ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maiwashi"), "ﾏｲﾜｼ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "masaba"), "ﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "gomasaba"), "ｺﾞﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maaji"), "ﾏｱｼﾞ")
    expect_error(make_shtname(prefec = "kagoshima", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() stops for unknown prefecture", {
    expect_error(make_shtname(prefec = "foo", spcs = "katakuchi"),
                 "Unknown prefecture")
  })
#+END_SRC
*** テスト/ 計測データ取得
#+BEGIN_SRC  R :tangle tests/testthat/test_get_measdata.R
  library(gyokaikyor)
  context("Get measure data vector from data frame")

  test_that("get_vector() extracts vector correctly", {
    df <- data.frame(a = 1:200, b = 101:300, c = c(201:250, NA, 252:400))
    expect_equal(get_vector(1, 10:20, df, na.rm = TRUE), 10:20)
    expect_equal(get_vector(2, 50:60, df, na.rm = TRUE), 150:160)
    expect_equal(get_vector(3, 50:60, df, na.rm = TRUE), c(250, 252:260))
    expect_equal(get_vector(3, 50:60, df, na.rm = FALSE), c(250, 0, 252:260))
  })

  test_that("get_measdata() extracts vector correctly", {
    df <- data.frame(kumamoto_a = 1:200, kumamoto_b = c(1:100, NA, 102:200))
    expect_equal(get_measdata(1, df, prefec = "kumamoto"), 8:107)
    expect_equal(get_measdata(2, df, prefec = "kumamoto"), c(8:100, 102:107))
    expect_error(get_measdata(1, df, prefec = "foo"),
                 "Unknown prefecture", fix = TRUE)
  })

  test_that("get_histdata() extracts vector correctly", {
    df <- data.frame(blank = 1:200,
                     class_l = seq(5, 1000, 5), class_r = seq(10, 1005, 5),
                     a = c(1:50, rep(NA, 50), 101:150,
                           sum(c(1:50, 101:150)), rep(NA, 49)))
    expect_equal(get_histdata(4, df, prefec = "nagasaki")[, 2],
                 c(5:50, rep(0, 50), 101:150))
    expect_error(get_histdata(1, df, prefec = "kumamoto"),
                 "Unknown prefecture", fix = TRUE)
  })
#+END_SRC
*** テスト/ 体長データ整形
#+BEGIN_SRC R :tangle tests/testthat/test_fmtbl.R
  library(gyokaikyor)
  context("Load blhist data from Excel spreadhseet and tidy it up")

  test_that("fmtbl() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    class(path) <- "nagasaki"
    expect_is(fmtbl(path, spcs = "katakuchi", nest = TRUE), "data.frame")
  })

  test_that("fmtbl.nagasaki() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("fmtbl.kumamoto() works well", {
    path <- "ExcelFiles/test_bl_kumamoto.xlsx"
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("fmtbl.kagoshima() works well", {
    path <- "ExcelFiles/test_bl_kagoshima.xlsx"
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })
#+END_SRC
*** テスト/ 漁獲量データ整形
#+BEGIN_SRC  R :tangle tests/testthat/test_fmtcatch.R
  library(gyokaikyor)
  context("Load catch data from Excel spreadhseet and tidy it up")

  test_that("fmtcatch.yamaguchi() work correctly", {
    path <- "ExcelFiles/test_catch_yamaguchi.xlsx"
    df   <- fmtcatch.yamaguchi(path, spcs = "katakuchi")
    expect_is(df, "data.frame")

    expect_setequal(dplyr::filter(df,
                                  year == 2018,
                                  month == 1,
                                  type == "sukui") %>%
                    dplyr::pull(catch),
                    seq(33, 36))
    expect_setequal(unique(df$type), c("sukui", "bouuke"))
  })

  test_that("fmtcatch.fukuoka() work correctly", {
    path <- "ExcelFiles/test_catch_fukuoka.xlsx"
    df   <- fmtcatch.fukuoka(path, spcs = "katakuchi", type = "maki")
    expect_is(df, "data.frame")
    expect_setequal(subset(df, year == 1977)$catch,
                    c(18, 51, 84, 117, 150, 183, 216, 249))
    expect_setequal(subset(df, year == 1978)$catch,
                    c(315, 348, 381, 414, 447, 480, 513, 546))
    expect_equal(unique(df$type), "maki")
    expect_setequal(unique(df$month), 4:12)
  })

  test_that("fmtcatch.kumamoto() processes makiami data correctly", {
    path <- "ExcelFiles/test_catch_kumamoto_maki.xls"
    df   <- fmtcatch.kumamoto(path, spcs = "katakuchi", type = "maki")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1989)$catch, 1:9)
    expect_equal(subset(df, year == 1990)$catch, 10:21)
    expect_equal(unique(df$type), "maki")
    expect_setequal(unique(df$month), 1:12)
  })

  test_that("fmtcatch.kumamoto() processes bouukeami data correctly", {
    path <- "ExcelFiles/test_catch_kumamoto_bouuke.xls"
    df   <- fmtcatch.kumamoto(path, spcs = "katakuchi", type = "bouuke")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1993)$catch, 1:7)
    expect_equal(subset(df, year == 1994)$catch, 8:14)
    expect_equal(unique(df$type), "bouuke")
    expect_setequal(unique(df$month), 6:12)
  })

  test_that("fmtcatch.saga() prosesses saga data correctly", {
    path <- "ExcelFiles/test_catch_saga.xls"
    df   <- fmtcatch.saga(path, spcs = "katakuchi", type = "kennai")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1975)$catch, 1:9)
    expect_equal(subset(df, year == 1976)$catch, 10:21)
    expect_equal(unique(df$type), "kennai")
    expect_setequal(unique(df$month), 1:12)
  })

  test_that("fmtcatch.kagoshima() works well", {
    path <- "ExcelFiles/test_catch_kagoshima.xlsx"
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = TRUE, maki.only = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = FALSE, maki.only = TRUE),
              "data.frame")
  })
#+END_SRC
*** テスト/ 長崎漁獲量
#+BEGIN_SRC  R :tangle tests/testthat/test_catch_nagasaki.R
  library(gyokaikyor)
  context("Formating nagasaki catch data")

  test_that("make_hougan() creates vector houganshi", {
    str1 <- rep(1:10, 4) %>%
      replace(which(. %% 3  == 0), NA) %>%
      replace(which(. %% 5  == 0), "foo") %>%
      as.character()
    str2 <- c("いち", "に", "さん", "し",
              NA, "ろく", "なな", "はち", NA, "じゅう")
    str3 <- c("カ", NA, "タ", NA, "ク", NA, "チ", "イ", "ワ", "シ")
    expect_equal(make_hougan(str1), "12 4  78  12 4  78  12 4  78  12 4  78  ")
    expect_equal(make_hougan(str2), " に し      ")
    expect_equal(make_hougan(str3), "カ タ ク チイワシ")
  })

  test_that("ngs_locate_spcsrow(), locates row position", {
    regex <- "カ( |　)*タ( |　)*ク( |　)*チ"
    str1  <- c("カタクチ", NA, "カ タ ク チ", NA, "カ　タ　ク　チ")
    str2  <- c("カ", NA, "タ", NA, "ク", NA, "チ",
               NA, "foo", NA, "カ", "タ", "ク", "チ")
    expect_equal(ngs_locate_spcsrow(regex, str1), c(1, 3, 5))
    expect_equal(ngs_locate_spcsrow(regex, str2), c(1, 11))
  })

  test_that("ngs_get_monthcol() detect month column", {
    df <- tibble::tribble(~A, ~B, ~C, ~D, ~E, ~F, ~G,
                          "foo", "bar", "3月", "baz", "４　月", "bum", "5　月",
                          1, 2, 3, 4, 5, 6, 7,
                          8, 9, 10, 11, 12, 13, 14)
    expect_equal(ngs_get_monthcol(1, df), data.frame(row = c(1, 1),
                 col = c(5, 7)))
    expect_equal(ngs_get_monthcol(2, df), data.frame(row = c(1, 1),
                 col = c(5, 7)))
  })

  test_that("ngs_get_colvalue(), gets values correctly", {
    df <- tibble::tribble(
        ~A, ~B, ~C, ~D, ~E, ~F, ~G, ~H,
        "foo", "bar", "3月", "baz", "４　月", "bum", "5　月", "boo",
        "カタクチイワシ", 2, 3, 4, 5, 6, 7, 8,
        9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24,
        "foo", "bar", "3月", "baz", "４　月", "bum", "5　月", "boo",
        "カタクチイワシ", 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40
      )
    expect_setequal(
      ngs_get_colvalue(regex = "カタクチイワシ", df = df,
                       offset.x = 1, offset.y = 1, xtract.digit = TRUE),
                       c(6, 8, 30, 32))
    expect_setequal(
      ngs_get_colvalue(regex = "カタクチイワシ", df = df,
                       offset.x = 1, offset.y = 2, xtract.digit = TRUE),
                       c(14, 16, 38, 40))
  })

  test_that("ngs_make_yrvec() makes year vector correctly", {
    expect_equal(ngs_make_yrvec("2018.11-2019.03", c(11, 12, 1, 2, 3)),
                 c(rep(2018, 2), rep(2019, 3)))
    expect_equal(ngs_make_yrvec("2019.01-2019.03", c(1, 2, 3)),
                 rep(2019, 3))
  })


  # test_that("ngs_get_port() parses port name correctly", {
  #   port1 <- "地名 ：（Ｈ.29）長崎魚市      漁業種 ：中小型まき網"
  #   port2 <- "地名 ：（Ｈ.29）奈留      漁業種 ：中小型まき網"
  #   port3 <- "地名 ：（Ｈ.29）小佐々      漁業種 ：中小型まき網"
  #   port4 <- "地名 ：（Ｈ.29）九十九      漁業種 ：中小型まき網"
  #   port5 <- "地名 ：（Ｈ.29）橘      漁業種 ：中小型まき網"
  #   port6 <- "地名 ：（Ｈ.29）foo      漁業種 ：中小型まき網"
  #   expect_equal(ngs_get_port(port1), "nagasaki")
  #   expect_equal(ngs_get_port(port2), "naru")
  #   expect_equal(ngs_get_port(port3), "kujuku")
  #   expect_equal(ngs_get_port(port4), "kujuku")
  #   expect_equal(ngs_get_port(port5), "tachibana")
  #   expect_error(ngs_get_port(port6), "Unknown port")
  # })

  # test_that("ngs_fmt_sheet() load catch data and tidy it up correctly", {
  #   expect_is(
  #     ngs_fmt_sheet(sheet = "2017.02-2017.08",
  #     path = "ExcelFiles/test_catch_ngs_nagasaki_iwashi.xls",
  #     regex = "カ タ ク チ"),
  #     "data.frame")
  # })

  # test_that("fmtcatch.nagasaki() load catch data and tidy it up correctly", {
  #   expect_is(fmtcatch.nagasaki(
  #               path = "ExcelFiles/test_catch_ngs_nagasaki_iwashi.xls",
  #               spcs = "katakuchi"),
  #               "data.frame")
  # })
#+END_SRC

** 関数
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** インポート
#+BEGIN_SRC  R :tangle R/util.R
  ## quiets concerns of R CMD check re: the .'s that appear in pipelines
  if (getRversion() >= "2.15.1") {
    utils::globalVariables(c(".", "maki4ports", "bou_akune", "bou_uchinoura"))
  }
#+END_SRC
*** ファイル名操作
#+BEGIN_SRC R :tangle R/handle_fname.R
  give_classi   <- function(fname, prefec) {
    out        <- fname
    class(out) <- prefec
    out
  }

  give_class <- function(fname, tbl.fname) {
    prefec     <- hash::values(tbl.fname, keys = fname)
    out <- purrr::map2(fname, prefec, give_classi)
    out
  }
#+END_SRC
*** セル位置取得
#+BEGIN_SRC R :tangle R/locate_cellpos.R
  quot_ring <- function(mod, ideal) {
    if (mod == 0) {
      a <- ideal
    } else {
      a <- mod
    }
    a
  }

  quot2col <- function(quotient, mod) {
    if (mod == 0) {
      col <- quotient
    } else {
      col <- quotient + 1
    }
    col
  }

  make_RC <- function(row, col) {
    rc <- paste0("R", row, "C", col)
    rc
  }

  locate_patterns <- function(df, regex) {
    nrows <- dim(df)[1]
    match <- apply(df, 2, gregexpr, pattern = regex) %>%
      unlist()
    pos <- which(match == TRUE)
    quo <- purrr::map(pos, `%/%`, nrows)
    mod <- purrr::map(pos, `%%`, nrows)
    col <- purrr::map2(quo, mod, quot2col)
    row <- purrr::map2(mod, nrows, quot_ring)
    pos <- cellranger::R1C1_to_A1(paste0("R", row, "C", col))
    pos
  }

  get_topleft <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    pos[1]
  }

  get_bottomright <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    rev(pos)[1]
  }

  get_row <- function(str, regex, offset = 0) {
    stringr::str_which(str, regex) + offset
  }
  #+END_SRC
*** 文字列操作
#+BEGIN_SRC R :tangle R/handle_str.R
  get_col2load   <- function(target, regex, offset) {
    match <- stringr::str_detect(target, regex)
    out <- which(match == TRUE) + offset
    out
  }

  insert_regex <- function(str, regex, prefix = FALSE, option = FALSE) {
    if (option == FALSE) {
      rep <- "+"
    } else {
      rep <- "*"
    }
    if (prefix == TRUE) {
      out <- paste0(regex, rep, substr(str, 1, 1))
    } else {
      out <- substr(str, 1, 1)
    }
    for (i in 2:nchar(str)) {
      out <- paste0(out, regex, rep, substr(str, i, i))
    }
    out
  }

  parse_ym <- function(path) {
    if (stringr::str_detect(path, "/")) {
      fname <- stringr::str_extract(path, "(?<=/)[^/]+$")
    } else {
      fname <- path
    }
    ym_start_match <- stringr::str_match(fname, "(\\d+)\\.((?:0|1)\\d)(?=-)")
    year_start     <- ym_start_match[2] %>% as.numeric()
    month_start    <- ym_start_match[3] %>% as.numeric()
    ym_end_match   <-
      stringr::str_match(fname, "\\d+\\.(?:0|1)\\d-(\\d+)\\.((?:0|1)\\d)")
    year_end       <- ym_end_match[2] %>% as.numeric()
    month_end      <- ym_end_match[3] %>% as.numeric()
    if ( (nchar(year_start) != 4) | (nchar(year_end) != 4))
      stop("Failed parsing to year")
    out <- list()
    out$year_start  <- year_start
    out$month_start <- month_start
    out$year_end    <- year_end
    out$month_end   <- month_end
    out
  }

  xtract_numeric <- function(str) {
    xtract_numerici <- function(str) {
      regex <- "\\D+"
      half <- Nippon::zen2han(str) %>%
        stringr::str_replace(regex, "") %>%
        readr::parse_integer()
      half
    }
    out <- purrr::map_int(str, xtract_numerici)
    out
  }

  abb2num <- function(abb) {
    lambda <- function(abb) {
      which(abb == month.abb)
    }
    purrr::map_int(abb, lambda)
  }

  make_ym <- function(y, m) {
    out <- paste0(y, formatC(m, width = 2, flag = 0)) %>%
      readr::parse_integer()
    out
  }
#+END_SRC


*** 種名シート名生成
#+BEGIN_SRC  R :tangle R/make_shtname.R
  make_shtname <- function(prefecture, spcs) {
    switch(prefecture,
           "kumamoto" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "sabarui"   = shtname <- "サバ類",
                    stop("Unknown spcs name"))

           },
           "nagasaki" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "masaba"    = shtname <- "マサバ",
                    "gomasaba"  = shtname <- "ゴマサバ",
                    "maaji"     = shtname <- "マアジ",
                    stop("Unknown spcs name"))
           },
           "kagoshima" = {
             switch(spcs,
                    "katakuchi" = shtname <- "ｶﾀｸﾁ",
                    "urume"     = shtname <- "ｳﾙﾒ",
                    "maiwashi"  = shtname <- "ﾏｲﾜｼ",
                    "masaba"    = shtname <- "ﾏｻﾊﾞ",
                    "gomasaba"  = shtname <- "ｺﾞﾏｻﾊﾞ",
                    "maaji"     = shtname <- "ﾏｱｼﾞ",
                    stop("Unknown spcs name"))
           },
           stop("Unknown prefecture")
           )
    shtname
  }
#+END_SRC
*** 和暦/西暦変換
#+BEGIN_SRC  R :tangle R/jpyr2ad.R
  jpyr2ad <- function(x, start) {
    conv <- vector(mode = "integer")
    if (start == "showa") {
     suppressMessages(pos_lastyr <- alert_decrease(x))
     x[1:96]
     x[1:97]
     conv[1:pos_lastyr] <- 1925
     conv[1:96]
     conv[1:97]
     conv[(pos_lastyr + 1):length(x)] <- 1988
    } else {
      stop("jpyr2ad")
    }
    ad <- x + conv
    ad
  }

#+END_SRC
*** データ取得
#+BEGIN_SRC R :tangle R/get_data.R
  get_vector <- function(col, row, df, na.rm) {
    out <- dplyr::pull(df, col)[row]
    if (na.rm) {
      out %<>% stats::na.omit() %>%
        as.vector()
    } else {
      out %<>% tidyr::replace_na(0)
    }
    out
  }

  get_measdata <- function(col, df, prefec) {
    switch(prefec,
           "kumamoto" = {
             startrow <- 8
             endrow   <- 107
           },
           stop("Unknown prefecture"))
    out <- get_vector(col, startrow:endrow, df, na.rm = TRUE) %>%
      as.numeric()
    out
  }

  locate_vecend <- function(x) {
    out <- which(!is.na(x)) %>% max()
    out
  }

  get_histdata <- function(col, df, prefec) {
    switch(prefec,
           "nagasaki" = {
             startrow  <- 5
             endrow    <- locate_vecend(df[, col]) - 1
             class_l   <- get_vector(col = cellranger::letter_to_num("B"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             class_r   <- get_vector(col = cellranger::letter_to_num("C"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             blclass   <- make_blclass(class_l, class_r)
           },
           "kagoshima" = {
             startrow <- 9
             endrow   <- stringr::str_which(dplyr::pull(df, 2), "合　計") - 1
             class_start <- df[startrow, 2] %>%
               stringr::str_replace("(?<=\\d\\.\\d)\\D", "") %>%
               stringr::str_replace("( |　)+", "") %>%
               as.double()
             class_end <- df[endrow, 2] %>%
               as.integer()
             left     <- seq(class_start * 10, class_end * 10 + 5, 5)
             blclass  <- make_blclass(left, left + 5)
           },
           stop("Unknown prefecture"))
    count <- get_vector(col, startrow:endrow, df, na.rm = FALSE) %>%
      as.numeric()
    out   <- data.frame(blclass = blclass, count = count) %>%
      dplyr::mutate(blclass = as.character(blclass))
    out
  }
#+END_SRC
*** データ作成
#+BEGIN_SRC R
  coltypes_seimitsu <- list("測定部位コード"     = "i",
                            "生殖腺重量"         = "d",
                            "体長"               = "i",
                            "性"                 = "i",
                            "漁区"               = "i",
                            "統一大海区農林漁区" = "i",
                            "開始緯度"           = "d",
                            "開始経度"           = "d")
  coltypes_taichou <- list("測定部位コード"     = "i",
                           "漁区"               = "i",
                           "統一大海区農林漁区" = "i",
                           "開始緯度"           = "d",
                           "開始経度"           = "d")
  url <- "https://gist.githubusercontent.com/smxshxishxad/47d898c195e611aa9751f7a3d6f9e611/raw/3f07db9c411fae7b65df3c6e29e9529368c43392/prefec_code_eng.csv"
  tmp <- RCurl::getURL(url, ssl.verifypeer = FALSE)
  prefec_code <- read.csv(textConnection(tmp), sep = ",", header = TRUE)

  usethis::use_data(prefec_code,
                    coltypes_taichou,
                    coltypes_seimitsu,
                    internal = TRUE, overwrite = TRUE)
#+END_SRC
*** 体長データ整形
#+BEGIN_SRC R :tangle R/fmtbl.R
  #' Load and format bl histogram data
  #'
  #' @inheritParams readxl::read_excel
  #' @param spcs Spcs name in romaji, one of
  #' @param nest If \code{TRUE}, data will be shown in rectangle format
  #'   whith nested bl datafor quick overview.
  #' \itemize{
  #'   \item maiwashi
  #'   \item maaji
  #'   \item sabarui
  #'   \item masaba
  #'   \item gomasaba
  #'   \item katakuchi
  #'   \item urume
  #' }
  #' @export
  fmtbl <- function(path, spcs, nest = FALSE) {
    UseMethod("fmtbl")
  }

  load_alldata <- function(path, sheet) {
    suppressMessages(
      alldata   <- readxl::read_excel(path,
                                      sheet = sheet, col_names = FALSE,
                                      col_types = "text")
    )
  }

  make_blclass <- function(left, right) {
    left %<>% unlist() %>%
      as.vector() %>%
      as.numeric()
    right %<>% unlist() %>%
      as.vector() %>%
      as.numeric()
    out <- paste0("[", left, ",", right, ")")
    out
  }

  jpmonth2num <- function(x) {
    out <- x %>%
      as.vector() %>%
      gsub("\u6708", "", .) %>% # "tsuki" in jp kanji
      as.numeric()
    out
  }

  fmtbl.nagasaki  <- function(path, spcs, nest = TRUE) {

    check_month <- function(months, month_start, month_end) {
      if (!(month_start == months[1]) | (!month_end == rev(months)[1])) {
        # message ("Check month data")
      }
    }

    give_yr2month <- function(mvec, year.start) {
      out           <- list()
      is_yr_changed <- FALSE
      for (i in seq_along(mvec)) {
         m            <- mvec[i]
         out$month[i] <- m
         if (i >= 2) {
           if (m < out$month[i - 1]) {
           is_yr_changed <- TRUE
           }
         }

         if (is_yr_changed) {
           out$year[i] <- year.start + 1
         } else {
           out$year[i] <- year.start
         }
      }
      out
    }

    sheet     <- make_shtname(prefecture = "nagasaki", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    colpos    <- get_col2load(target = alldata[4, ],
                              regex = ".\u6708", # "tsuki" in jp kanji
                              offset = 0)
    months         <- jpmonth2num(alldata[4, colpos])
    histdata       <- purrr::map(colpos, get_histdata, df = alldata,
                            prefec = "nagasaki")
    parsedym       <- parse_ym(path)
    check_month(months, parsedym$month_start, parsedym$month_end)
    year_start     <- parsedym$year_start
    out            <- list()
    out$year       <- give_yr2month(months, year_start)$year
    out$month      <- give_yr2month(months, year_start)$month
    out$prefecture <- "nagasaki"
    out$hist       <- histdata
    out            <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kumamoto  <- function(path, spcs, nest = TRUE) {
    parse_year <- function(path) {
      if ( ( stringr::str_detect(path, "/"))) {
        fname <- stringr::str_match(path, "^.+/(\\d+\\s?【熊本県】.+)")[2]
      } else {
        fname <- path
     }
      match  <- stringr::str_match(fname, "^\\d+\\s?【熊本県】(\\w\\d+)まき")
      wareki <- match[2]
      era    <- stringr::str_sub(wareki, 1, 1)
      jpyr   <- stringr::str_replace(wareki, "^\\w", "")
      year   <- switch(era,
             "H" = paste0("heisei", jpyr, "年") %>%
               Nippon::wareki2AD()
             )

      year
    }
    sheet     <- make_shtname(prefecture = "kumamoto", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[1, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[1, cpos_date] %>%
      purrr::map_chr(tinyplyr::num2date)
    type      <- alldata[1, cpos_date + 4] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_measdata,
                             prefec = "kumamoto", df = alldata)

    out            <- list()
    out$date       <- date
    out$type       <- type
    out$year       <- lubridate::year(out$date)
    out$month      <- lubridate::month(out$date)
    out$scbl       <- bl
    out$prefecture <- "kumamoto"

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kagoshima <- function(path, spcs, nest = TRUE) {
    sheet     <- make_shtname(prefecture = "kagoshima", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[3, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[3, cpos_date] %>%
      tinyplyr::num2date()
    type      <- alldata[6, cpos_date] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_histdata,
                             df = alldata, prefec = "kagoshima")
    out            <- list()
    out$date       <- date
    out$type       <- type
    out$year       <- lubridate::year(out$date)
    out$month      <- lubridate::month(out$date)
    out$bl         <- bl
    out$prefecture <- "kagoshima"

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  rename_class <- function(left, bin) {
    out <- paste0("[", left, ",", left + bin, ")")
    out
  }

  #' Format bldata exported from FRESCO database
  #'
  #' @inheritParams fmtbl
  #' @param type Format of data to load either 'taichou' or 'seimitsu'.
  #' @param date.start The first day of the processed data.
  #' @param date.end The last day of the the processed data
  #' @examples
  #' \dontrun{
  #'   fmtbl_fresco("2019Mar_seikai_taichou_katakuchi.csv", type = "taichou",
  #'                date.start = "20180901", date.end = "20190331")
  #'   fmtbl_fresco("2019Mar_seikai_seimitsu_katakuchi.csv", type = "seimitsu"
  #'                date.start = "20180901", date.end = "20190331")
  #' }
  #' @export
  fmtbl_fresco <- function(path, type, date.start, date.end) {
    dstart <- lubridate::ymd(date.start)
    dend   <- lubridate::ymd(date.end)
    if (type == "seimitsu") {
      suppressMessages(
        data <- readr::read_csv(path, locale = readr::locale(encoding = "cp932"),
                                col_types = coltypes_seimitsu)
      )
    } else if (type == "taichou") {
      suppressMessages(
        data <- readr::read_csv(path, locale = readr::locale(encoding = "cp932"),
                                col_types = coltypes_taichou)
      )
    }
    out <- data %>%
      dplyr::mutate(date  = lubridate::ymd(漁獲年月日),
                    year  = lubridate::year(date),
                    month = lubridate::month(date),
                    day   = lubridate::day(date),
                    ym    = paste0(year, formatC(month, width = 2, flag = 0)) %>%
                      as.numeric()) %>%
        dplyr::rename(spcs_code = 魚種コード,
                      prefec_code = 県コード) %>%
        dplyr::left_join(prefec_code, by = c("prefec_code" = "code"))
    if (type == "seimitsu") {
      out %<>%
        dplyr::rename(scbl = 被鱗体長,
                      bw = 体重) %>%
        dplyr::select(date, year, month, day, ym,
                      spcs_code, prefec_code, prefecture, scbl, bw)
    } else if (type == "taichou") {
      out %<>%
        dplyr::rename(blclass = 開始の階級値,
                      count = 度数) %>%
        dplyr::mutate(blclass = ifelse(階級幅 == 0.5,
                                            blclass * 10,
                                            ifelse(階級幅 == 5,
                                                   blclass,
                                                   NA))) %>%
        tidyr::drop_na(count) %>%
        dplyr::select(date, year, month, day, ym,
                      spcs_code, prefec_code, prefecture, blclass, count) %>%
        dplyr::mutate(blclass = rename_class(blclass, bin = 5))
    }
    dplyr::filter(out, dplyr::between(date, dstart, dend))
  }
#+END_SRC

*** 漁獲量データ整形
**** 総称関数
#+BEGIN_SRC R :tangle R/fmtcatch.R
  #' Load and format catch data
  #'
  #' @inheritParams readxl::read_excel
  #' @param spcs Spcs name in romaji, one of
  #' @param nest If \code{TRUE}, data will be shown in rectangle format
  #' @param type Character value either "maki" or "bouuke" to control
  #'   data processing algorithm for kumamoto data.
  #'   whith nested catch data for quick overview.
  #' \itemize{
  #'   \item maiwashi
  #'   \item maaji
  #'   \item sabarui
  #'   \item masaba
  #'   \item gomasaba
  #'   \item katakuchi
  #'   \item urume
  #' }
  #' @export
  fmtcatch <- function(path, spcs, type = NULL) {
    UseMethod("fmtcatch")
  }

  alert_decrease <- function(x) {
    if (any(diff(x) < 0)) {
      message("There is a decrease in number.")
      which(diff(x) < 0)
    } else {
      x
    }
  }
#+END_SRC
**** 山口
#+BEGIN_SRC R :tangle R/fmtcatch_yamaguchi.R
  #' Load and format catch data of yamaguchi
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "sukui" or "bouuke".
  fmtcatch.yamaguchi <- function(path, spcs, type = NULL) {
    switch(spcs,
           "maaji"    = {
             spcs_col     <- 5
             meigara_ofst <- 1:3
           },
           "sabarui"  = {
             spcs_col     <- 9
             meigara_ofst <- 1:2
           },
           "maiwashi" = {
             spcs_col     <- 12
             meigara_ofst <- 1:3
           },
           "urume"    = {
             spcs_col     <- 21
             meigara_ofst <- 1:3
           },
           "katakuchi" = {
             spcs_col     <- 16
             meigara_ofst <- 1:4
           })

    get_catch_meigara <- function(cofst, spcs_col, sheet) {
      alldata     <- load_alldata(path, sheet = sheet)
      year        <- xtract_numeric(sheet)
      row_jan     <- 5
      rows        <- row_jan:38
      mmatch      <- xtract_numeric(alldata[[1]][rows])
      mrows       <- which(!is.na(mmatch)) + row_jan - 1
      ofst_sukui  <- 1
      ofst_bouuke <- 2
      out         <- NULL
      out$year    <- year
      out$month   <- dplyr::pull(alldata, 1)[mrows] %>%
        xtract_numeric()
      out$sukui   <- col2data(col = spcs_col + cofst,
                        rows = 1:40,
                        row.pick = mrows + ofst_sukui,
                        alldata)
      out$bouuke  <- col2data(col = spcs_col + cofst,
                        rows = 1:40,
                        row.pick = mrows + ofst_bouuke,
                        alldata)
      out$meigara <- alldata[4, spcs_col + cofst] %>%
        unlist() %>% as.vector()
      out$prefecture <- "yamaguchi"
      out %<>% tibble::as_tibble() %>%
        tidyr::gather("sukui", "bouuke", key = "type", value = "catch")
      out
    }

    sheets <- readxl::excel_sheets(path) %>%
      stringr::str_extract("[0-9]+.+") %>%
      na.omit()

    dat1   <- purrr::map_df(meigara_ofst, get_catch_meigara,
                          spcs_col = spcs_col, sheet = sheets[1])
    dat2   <- purrr::map_df(meigara_ofst, get_catch_meigara,
                          spcs_col = spcs_col, sheet = sheets[2])
    out    <- dplyr::bind_rows(dat1, dat2) %>%
      dplyr::mutate(catch = catch / 1000)
    out
  }
#+END_SRC
**** 福岡
#+BEGIN_SRC R :tangle R/fmtcatch_fukuoka.R
  #' Load and format catch data of fukuoka
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "maki" or "bouuke", and "others".
  fmtcatch.fukuoka <- function(path, spcs, type) {
    spcs_jp <- switch(spcs,
                      "maaji"     = "ﾏｱｼﾞ",
                      "maiwashi"  = "ﾏｲﾜｼ",
                      "masaba"    = "ﾏｻﾊﾞ",
                      "gomasaba"  = "ｺﾞﾏｻﾊﾞ",
                      "katakuchi" = "ｶﾀｸﾁ",
                      "urume"     = "ｳﾙﾒ")

    sheet <- switch(type,
                    "maki"   = "まき網 ",
                    "bouuke" = "棒受網",
                    "others" = "その他漁業")
    alldata <- load_alldata(path, sheet)

    ycol     <- 2
    mcol     <- 3
    mstr     <- alldata[[mcol]]
    startrow <- get_row(mstr, "ﾂｷ", offset = 1)
    endrow   <- get_row(mstr, "KEI") %>% max()
    rows     <- startrow:endrow
    datrow   <- stringr::str_count(mstr[startrow:endrow], "KEI") == 0
    spcs_col <- get_spcscol(alldata, spcs_jp)

    out       <- NULL
    out$year  <- col2data(col = ycol, row = rows,
                          row.pick = datrow, df = alldata) %>%
      jpyr2ad(start = "showa")
    out$month <- col2data(col = mcol, row = rows,
                          row.pick = datrow, df = alldata)
    out$type  <- type
    out$catch <- col2data(col = spcs_col, row = rows,
                          row.pick = datrow, df = alldata) / 1000
    out$prefecture <- "fukuoka"
    tibble::as_tibble(out)
  }

  col2data <- function(col, rows, row.pick, df) {
    out <- df[[col]][rows][row.pick] %>%
      as.numeric()
    out
  }

  get_spcscol <- function(df, spcs_jp) {
    out <- NULL
    for (i in 2:5) {
      str <- df[i, ] %>%
        unlist() %>%
        as.vector()
      out <- stringr::str_which(str, spcs_jp)
      if (length(out) > 0)
        break
    }
    out
  }

#+END_SRC
**** 鹿児島
#+BEGIN_SRC R :tangle R/fmtcatch_kagoshima.R
  fmtcatch.kagoshima <- function(path, spcs, spread = TRUE, maki.only = FALSE) {
    make_year <- function(yr_jp, jpera) {
      out <- paste0(jpera, yr_jp, "\u5E74") %>% # "nen" (year) in jp kanji
        Nippon::wareki2AD()
      out
    }
    get_ym <- function(str) {
      split <- stringr::str_split(str, "\\.")
      out   <- NULL
      jpyr.start  <- split[[1]][1] %>% as.numeric()
      jpyr.end    <- split[[length(str)]][1] %>% as.numeric()
      if (jpyr.end < jpyr.start)
        stop("Japanese era changed! Check algorithm")
      mth.start  <- split[[1]][2] %>% as.numeric()
      mth.end    <- split[[length(str)]][2] %>% as.numeric()
      yr.start   <- make_year(jpyr.start, "heisei")
      yr.end     <- make_year(jpyr.end, "heisei")
      dstart     <- as.Date(paste(yr.start, mth.start, 1, sep = "-"))
      dend       <- as.Date(paste(yr.end, mth.end, 1, sep = "-"))
      dseq       <- seq.Date(dstart, dend, "month")
      out$years  <- stringr::str_sub(dseq, 1, 4) %>%
        readr::parse_integer()
      out$months  <- stringr::str_sub(dseq, 6, 7) %>%
        readr::parse_integer()
      out
    }

    load_catch_4ports <- function(path, spcs) {
      spcs_jp <- switch(spcs,
                        "maaji" = "マアジ",
                        "sabarui" = "サバ類",
                        "maiwashi" = "マイワシ",
                        "urume" = "ウルメイワシ",
                        "katakuchi" = "カタクチイワシ",
                        stop("Unknown spcs"))
      regex    <- insert_regex(spcs_jp, "\u3000", prefix = TRUE)
      data     <- load_alldata(path, sheet = "４港計")
      col_spcs <- which((gregexpr(regex, data[3, ]) > 0) == TRUE) #nolint
      col2load <- col_spcs + 4
      out      <- get_vector(col2load, 5:16, data, na.rm = FALSE) %>%
        readr::parse_number()
      out
    }

    load_catch_bouuke <- function(path, spcs, sheet, unit = "ton") {
      data     <- load_alldata(path, sheet)
      spcs_jp <- switch(spcs,
                        "maaji" = "マアジ",
                        "sabarui" = "サバ類",
                        "maiwashi" = "マイワシ",
                        "urume" = "ウルメ",
                        "katakuchi" = "カタクチ",
                        stop("Unknown spcs"))
      cols_spcs <- which((gregexpr(spcs_jp, data[32, ]) > 0) == TRUE) # nolint
      col_kg    <- cols_spcs[2]
      out       <- get_vector(col_kg, 33:44, data, na.rm = FALSE) %>%
        readr::parse_number()
      if (unit == "ton") {
        out <- out / 1000
      } else if (unit == "kg") {
      } else {
        stop ("Unknown unit.")
      }
      out
    }

    data  <- load_alldata(path, sheet = "\uFF14\u6E2F\u8A08")
                                          # "4koukei" (four port sum) in jp kanji
    str   <- data[5:16, 1] %>%
      unlist() %>%
      as.vector()

    years  <- get_ym(str)$years
    months <- get_ym(str)$months

    catch_4ports        <- load_catch_4ports(path, spcs)
    catch_bou_akune     <- load_catch_bouuke(path, spcs, sheet = "阿久根棒受")
    catch_bou_uchinoura <- load_catch_bouuke(path, spcs, sheet = "内之浦棒受")
    out <- list(year = years,
                month = months,
                maki4ports = catch_4ports,
                bou_akune = catch_bou_akune,
                bou_uchinoura = catch_bou_uchinoura,
                prefecture = "kagoshima") %>%
      tibble::as_tibble()
    if (maki.only == TRUE) {
      out %<>% dplyr::select(-"bou_akune", -"bou_uchinoura")
    } else {
      out %<>%
        dplyr::mutate(total = maki4ports + bou_akune + bou_uchinoura)
      if (spread == FALSE) {
        out %<>% dplyr::select(-"total") %>%
          tidyr::gather("maki4ports", "bou_akune", "bou_uchinoura",
                 key = "type", value = "catch")
      }
    }
    out
  }
#+END_SRC
**** 長崎
#+BEGIN_SRC R :tangle R/fmtcatch_nagasaki.R
  #' Make vector 'houganshi'
  #'
  #' This function returns vector 'houganshi' to locate the position of
  #'   target word (e.g. species name) in a Excel rows or columns.
  #' To keep correspondence between nubmer of cells and nchar of output string,
  #' This function replaces \code{NA} and a cell value with multiple characters.
  #' @param str String vector with NA or multiple characters
  #' @return Long single string composed of single-word cell and whitespace
  #' @examples
  #' \dontrun{
  #'   str <- rep(1:10, 10) %>%
  #'     replace(which(. %% 3  == 0), NA) %>%
  #'     replace(which(. %% 5  == 0), "foo") %>%
  #'     as.character()
  #'   make_hougan(str)
  #' }
  make_hougan <- function(str) {
    out <- tidyr::replace_na(str, " ")
    out[nchar(out) != 1] <- " "
    out %<>% stringr::str_c(collapse = "")
    out
  }

  #' Locate row position of the cell which contains species name
  #'
  #' This function locates the row position of the cell which contains
  #'   specific species name.
  #' @param regex Regular expression to match the name of the target species.
  #' @param colstr String vector made from a Excel worksheet column.
  #' @return All the row positions where the species name start.
  ngs_locate_spcsrow <- function(regex, colstr) {
    spcs_row <- stringr::str_which(colstr, regex)
    if (length(spcs_row) == 0) {
      spcs_str <- make_hougan(colstr)
      spcs_row <- unlist(gregexpr(regex, spcs_str))
    }
    spcs_row
  }

  #' Detect month column coping with variation in row position of the month cell
  #'
  #' @param row Assumed position of the month cell
  #' @param df Loaded Excel sheet
  #' @return Row-column set of month cells in a given \code{row}
  ngs_get_monthcol <- function(row, df) {
    regex <- "^([０-９]|[0-9])+　+月$"
    col   <- which(gregexpr(regex, df[row, ]) > 0)
    if (length(col) == 0) {
      row <- row - 1
      col <- which(gregexpr(regex, df[row, ]) > 0)
    }
    out   <- data.frame(row = row, col = col)
    out
  }

  #' Get values placed separately in column direction
  #'
  #' This function return values placed separately on the specific fish row
  #'   in column direction.
  #' @inheritParams ngs_locate_spcsrow
  #' @inheritParams ngs_get_monthcol
  #' @param offset.x X-offset of the target value
  #'   from the position of the month cell
  #' @param offset.y Y-offest of the target value
  #'   from the position of the month cell
  #' @param xtract.digit If \code{TRUE}, all characters were deleted so that
  #'   the return value composed only of numerics.
  ngs_get_colvalue <- function(regex, df, offset.x = 0, offset.y = 0,
                            xtract.digit = FALSE) {
    spcs_col <- dplyr::pull(df, 1)
    spcs_row <- ngs_locate_spcsrow(regex, spcs_col)
    rowcol   <- purrr::map_dfr(spcs_row, ngs_get_monthcol, df = df)
    out      <- purrr::map2(rowcol$col + offset.x,
                            rowcol$row + offset.y,
                            get_vector, df = df, na.rm = FALSE) %>%
      purrr::flatten_chr()
    if (xtract.digit) {
      out %<>% xtract_numeric()
    } else {
      out %<>% readr::parse_number()
    }
    out
  }

  #' Make year vectors considering year change
  #'
  #' This function makes year vector from Excel sheet name (\%Y.\%m-\%Y.\%m) and
  #'   month vector. If the month vector contains year change (Dec-Jan),
  #'   year vector returned is composed from two years.
  #' @param sheet Sheet name of Nagasaki catch data (fmt: \%Y.\%m-\%Y.\%m).
  #' @param month Month vector
  #' @examples
  #' \dontrun{
  #'   ngs_make_yrvec(sheet = "2018.09-2019.03",
  #'                  month = c(9, 10, 11, 12, 1, 2, 3))
  #' }
  ngs_make_yrvec <- function(sheet, month) {
    ym  <- parse_ym(sheet)
    out <- rep(ym$year_start, length(month))
    is_yr_changed <- function(month) {
      any (diff(month) < 0)
    }
    if (is_yr_changed(month)) {
      out[(which(month == 1)):length(out)] <- ym$year_start + 1
    }
    out
  }

  #' Get port name from string
  #'
  #' This function returns port name from remarks written in Excel sheet. Port
  #' name with variants are extracted using regular expression and then
  #' converted to four port names written in ascii characters.
  #' @param str Japanes string which contains port name.
  ngs_get_port <- function(str) {
    out   <- NULL
    regex <- "(?<=Ｈ(．|\\.)\\d\\d?(）|\\))?)((長崎|奈留|九十九|小佐々|橘))"
    port  <- stringr::str_extract(str, regex)
    out   <- switch(port,
                    "長崎"   = "nagasaki",
                    "奈留"   = "naru",
                    "九十九" = "kujuku",
                    "小佐々" = "kujuku",
                    "橘"     = "tachibana",
                    stop("Unknown port"))
    out
  }

  #' Load catch data from single Excel sheet and tidy it up
  #'
  #' @inheritParams readxl::read_excel
  #' @inheritParams ngs_get_colvalue
  ngs_fmt_sheet <- function(sheet, path, regex) {
    data   <- load_alldata(path, sheet)
    port   <- ngs_get_port(dplyr::pull(data, 1)[2])
    months <- ngs_get_colvalue(regex, data, xtract.digit = TRUE)
    years  <- ngs_make_yrvec(sheet, months)
    catch  <- ngs_get_colvalue(regex, data, offset.x = 2, offset.y = 5)
    out    <- list(year = years,
                   month = months,
                   port = port,
                   catch = catch,
                   fname = path,
                   sheet = sheet,
                   prefecture = "nagasaki") %>%
      tibble::as_tibble()
    rm(data)
    out
  }

  #' Make catch data reading multiple Excel worksheets
  #'
  #' @inheritParams fmtcatch
  fmtcatch.nagasaki <- function(path, spcs) {
    spcs_jp <- switch(spcs,
                      "maiwashi" = "マイワシ",
                      "urume" = "ウルメイワシ",
                      "katakuchi" = "カタクチ")
    spcs_regex <- insert_regex(str = spcs_jp, regex = "( |　)",
                               prefix = FALSE, option = TRUE)
    sheets <- readxl::excel_sheets(path)
    out    <- purrr::map(sheets, ngs_fmt_sheet,
                         path = path, regex = spcs_regex) %>%
      dplyr::bind_rows()
    out
  }
#+END_SRC
**** 熊本 & 佐賀
#+BEGIN_SRC R :tangle R/fmtcatch_kumamoto_saga.R
  #' Load catch data of kumamoto and tidy it up
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "maki" or "bouke".
  #'   Data processing algorithm is controled by this parameter.
  fmtcatch.kumamoto <- function(path, spcs, type) {
    sheet   <- switch(spcs,
                      "maaji" = "マアジ",
                      "maiwashi" = "マイワシ",
                      "sabarui" = "サバ類",
                      "katakuchi" = "カタクチイワシ",
                      "urume" = "ウルメイワシ")
    alldata <- load_alldata(path, sheet)
    out     <- get_data(alldata, type, key.start = "年度計", key.end = "前年比")
    out$prefecture <- "kumamoto"
    out
  }
  #' Load catch data of saga and tidy it up
  #'
  #' @inheritParams fmtcatch.kumamoto
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"masaba"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value one of
  #' \itemize{
  #'   \item{"karatsu"}
  #'   \item{"kennai"}
  #'   \item{"teichi"}
  #'   \item{"chumaki"}
  #' }
  #'   Data processing algorithm is controled by this parameter.
  fmtcatch.saga <- function(path, spcs, type) {
    spcs_jp <- switch(spcs,
                      "maaji" = "ﾏｱｼﾞ",
                      "maiwashi" = "ﾏｲﾜｼ",
                      "masaba" = "ﾏｻﾊﾞ",
                      "katakuchi" = "ｶﾀｸﾁ",
                      "urume" = "ｳﾙﾒ")
    type_jp <- switch(type,
                      "karatsu" = "（唐津港）",
                      "kennai" = "（唐津港県内船）",
                      "teichi" = "（定置）",
                      "chumaki" = "（中まき）")
    sheets  <- readxl::excel_sheets(path)
    regex   <- paste0(spcs_jp, type_jp)
    sheet   <- sheets[stringr::str_detect(sheets, regex)]
    alldata <- load_alldata(path, sheet)
    out     <- get_data(alldata, type, key.start = "年度", key.end = "平年値")
    out$catch <- out$catch / 1000
    out$prefecture <- "saga"
    out
  }

  get_data <- function(df, type, key.start, key.end) {
    switch(type,
           "maki" = {
             judgecol_start <- 18
             judgecol_end   <- 3
             cols           <- 4:15
             months         <- c(4:12, 1:3)
             yrcol          <- 3
           },
           "bouuke" = {
             judgecol_start <- 13
             judgecol_end   <- 2
             cols           <- 4:10
             months         <- 6:12
             yrcol          <- 3
           }
         , {
             if (!type %in% c("karatsu", "kennai", "teichi", "chumaki"))
               stop("Unknown type")
             judgecol_start <- 1
             judgecol_end   <- 16
             cols           <- 3:14
             months         <- c(4:12, 1:3)
             yrcol          <- 1
           })
    str_judge_start <- dplyr::pull(df, judgecol_start)
    str_judge_end   <- dplyr::pull(df, judgecol_end)
    row_start       <- get_row(str_judge_start, key.start, offset = 1)
    row_end         <- get_row(str_judge_end, key.end, offset = -1)
    rows            <- row_start:row_end
    year            <- dplyr::pull(df, yrcol)[rows] %>%
      as.numeric()
    out             <- NULL
    out             <- df[rows, cols]
    colnames(out)   <- months
    out %<>% dplyr::mutate(year = year,
                           type = type) %>%
      tidyr::gather(-year, -type, key = month, value = "catch") %>%
      dplyr::mutate(year = as.integer(year),
                    month = as.integer(month),
                    catch = as.double(catch)) %>%
      dplyr::select(year, month, type, catch) %>%
      dplyr::mutate(year = ifelse(dplyr::between(month, 1, 3),
                                  year + 1,
                                  year)) %>%
      dplyr::arrange(year, month)
    out
  }
#+END_SRC

*** ★ファイル形式で書き出し
#+BEGIN_SRC R :tangle R/conv2hoshifile.R
  conv2hoshifile <- function(df, prefec, type, ym.start, ym.end,
                             export = FALSE, fname = NULL,
                             class.start = 10, class.end = 160) {
    make_ymseq <- function(ym.start, ym.end) {
      dseq <- seq.Date(as.Date(lubridate::ymd(paste0(ym.start, "01"))),
                       as.Date(lubridate::ymd(paste0(ym.end, "01"))),
                       "month")
      out <- dseq %>%
        stringr::str_replace("-", "") %>%
        stringr::str_sub(1, 6)
      out
    }

    conv2count <- function(df, prefec, ym.start, ym.end) {
      out <- df %>%
        dplyr::mutate(blclass = cut(scbl, breaks = seq(0, 400, 5),
                      include.lowest = TRUE, right = FALSE)) %>%
        dplyr::group_by(year, month, ym, prefecture, blclass) %>%
        dplyr::summarize(count = length(blclass)) %>%
        dplyr::mutate(blclass = as.character(blclass))
      out
    }

    extract_count_ymclass <- function(ym, class, df.count) {
      y   <- substr(ym, 1, 4) %>% as.numeric()
      m   <- substr(ym, 5, 6) %>% as.numeric()
      out <- df.count %>%
        dplyr::filter(year == y,
                      month == m,
                      blclass == class) %>%
        dplyr::pull(count)
      if (length(out) == 0) {
        out <- 0
      }
      out
    }

    extract_count_class <- function(ym, classes, df.count) {
      out <- purrr::map(classes, extract_count_ymclass,
                 ym = ym, df.count = df.count) %>%
        unlist() %>%
        purrr::set_names(classes)
      out
    }

    extract_count <- function(classes, ymseq, df.count) {
      names(ymseq) <- ymseq
      out <- purrr::map_df(ymseq, extract_count_class,
                           classes = classes, df.count = df.count) %>%
        as.data.frame()
      rownames(out) <- classes
      out
    }

    make_class <- function(min, max, bin) {
      left  <- seq(min, max - bin, bin)
      right <- seq(min + bin, max, bin)
      out   <- paste0("[", left, ",", right, ")")
      out
    }

    classes <- make_class(class.start, class.end, 5)
    ymseq   <- make_ymseq(ym.start, ym.end)

    if (type == "seimitsu") {
      df.count <- df %>%
        dplyr::mutate(ym = paste0(year, formatC(month, width = 2, flag = 0)) %>%
                        as.numeric()) %>%
        conv2count(prefec, ym.start, ym.end) %>%
        dplyr::filter(prefecture == prefec,
                      dplyr::between(ym, ym.start, ym.end))
    } else {
      df.count <- df %>%
        dplyr::mutate(ym = paste0(year, formatC(month, width = 2, flag = 0)) %>%
                        as.numeric()) %>%
        dplyr::filter(prefecture == prefec,
                      dplyr::between(ym, ym.start, ym.end)) %>%
        dplyr::group_by(year, month, ym, blclass) %>%
        dplyr::summarize(count = sum(count))
    }
    out <- extract_count(classes, ymseq, df.count)
    if (export == TRUE) {
      write.csv(out, fname)
    }
    out
  }
#+END_SRC

*** 「各県いわし」をRで使いやすい形式に変換
#+BEGIN_SRC R :tangle R/conv2list.R
  get_range <- function(year.end, year.start) {
    year.start <- year.start
    years      <- year.start:year.end
    n.prefec   <- 6
    maxrow     <- (length(years) + 2) * n.prefec + n.prefec - 1 + 2
    paste0("A1:N", maxrow)
  }

  load_iwashi <- function(path, year.end, sheet, year.start = 1992) {
    range   <- get_range(year.end, year.start)
    suppressMessages(
      out <- readxl::read_xlsx(path,
                                   sheet = sheet, skip = 2,
                                   col_names = FALSE, range = range))
    as.data.frame(out)
  }

  parse_num_vec <- function(col, df, to) {
    vec <- as.character(df[, col])
    out <- vec %>%
      tidyr::replace_na(0)
    if (to == "integer") {
      out %<>% readr::parse_integer()
    }
    if (to == "double") {
      out %<>% readr::parse_double()
    }
    out
  }

  parse_num_df <- function(cols, df, to) {
    out <- purrr::map_dfc(cols, parse_num_vec, df = df, to = to)
    out
  }


  get_prefec_rows <- function(str) {
    stringr::str_which(str, "県")
  }

  make_list <- function(row.prefec, df.iwashi, year.end, year.start = 1992){
    years      <- year.start:year.end
    row_prefec <- get_prefec_rows(df[, 1])
    prefec_name      <- stringr::str_replace(df[row.prefec, 1], "県.+", "")
    row_start        <- row.prefec + 2
    row_end          <- row_start + length(years) - 1
    data_prefec      <- df.iwashi[row_start:row_end, ] %>%
      parse_num_df(2:13, ., "double") %>%
      magrittr::set_colnames(month.abb)
    year             <- df.iwashi[row_start:row_end, 1] %>%
      stringr::str_replace("年", "") %>%
      readr::parse_integer()
    out              <- NULL
    out$df           <- cbind(year, data_prefec)
    names(out)       <- prefec_name
    out
  }

  summarize_seikai <- function(list) {
    get_month <- function(prefec, month, list) {
      list[[prefec]][month.abb[month]]
    }
    sum_month <- function(month, list, prefecs) {
      purrr::map(prefecs, get_month, month = month, list) %>%
        purrr::flatten() %>%
        Reduce(`+`, .)
    }
    prefecs <- names(list)
    year    <- list[[1]]$year
    out     <- purrr::map_dfc(1:12, sum_month, list, prefecs) %>%
      purrr::set_names(month.abb)
    out <- cbind(year, out)
    out
  }

  iwashi2list <- function(path, sheet, year.start = 1992, year.end) {
    df          <- load_iwashi(path = path, year.end = year.end,
                    sheet = sheet, year.start = year.start)
    prefec_rows <- get_prefec_rows(df[, 1])
    out <- purrr::map(prefec_rows, make_list, df.iwashi = df,
                      year.end = year.end) %>%
      purrr::flatten()
    out
  }
#+END_SRC
*** 体長頻度データを擬似精密データに変換
#+BEGIN_SRC R
  uncount_blclass <- function(df) {
    out <- df %>%
      mutate(bl = stringr::str_sub(class, 1, 3) %>%
               as.numeric()) %>%
      dplyr::select(-class) %>%
      tidyr::uncount(count)
    out
  }
#+END_SRC

*** 水温データを整理
#+BEGIN_SRC R :tangle R/fmttemp.R
  get_tw_sst <- function(fname, year.end) {
    year.start <- 1953
    nrows      <- (year.end - year.start + 1) * 12
    range2read <- paste0("A1:F", nrows + 1)
    xldata <- readxl::read_xlsx(fname,
                                sheet = "三旬平均実測値",
                                range = range2read) %>%
      dplyr::mutate(tw_degc = 対馬暖流Ｄ,
                    year    = 0,
                    month   = 0)

    for(i in 1:nrows){
      xldata[i, "year"]  <-
        as.numeric(Nippon::zen2han(gsub("年", "", xldata[i, 1])))
      xldata[i, "month"] <-
        as.numeric(Nippon::zen2han(gsub("月", "", xldata[i, 2])))
    }

    sst_tw <- xldata %>%
      dplyr::select(year, month, tw_degc) %>%
      dplyr::mutate(year  = as.integer(year),
                    month = as.integer(month))
    sst_tw
  }
#+END_SRC
