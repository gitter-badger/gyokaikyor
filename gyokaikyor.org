#+TITLE: gyokaikyor プロジェクトノート
#+PROPERTY: header-args :exports code :results scalar :session *R:gyokaikyor*
#+STARTUP: contents

* 目次                                                                :TOC_3:
- [[#使い方デモ][使い方デモ]]
  - [[#体長組成整理][体長組成整理]]
  - [[#漁獲量整理][漁獲量整理]]
  - [[#漁況予測][漁況予測]]
    - [[#時系列解析による予測][時系列解析による予測]]
  - [[#作図][作図]]
  - [[#水温データの整理][水温データの整理]]
- [[#開発環境の整備][開発環境の整備]]
  - [[#本バッケージ内部で使用するパッケージ][本バッケージ内部で使用するパッケージ]]
- [[#開発][開発]]
  - [[#リロード--自動テスト][リロード & 自動テスト]]
  - [[#テストコード][テストコード]]
    - [[#テスト-ファイル名操作][テスト/ ファイル名操作]]
    - [[#テスト-セル位置取得][テスト/ セル位置取得]]
    - [[#テスト-文字列操作][テスト/ 文字列操作]]
    - [[#テスト-種名生成][テスト/ 種名生成]]
    - [[#テスト-計測データ取得][テスト/ 計測データ取得]]
    - [[#テスト-体長データ整形][テスト/ 体長データ整形]]
    - [[#テスト-漁獲量データ整形][テスト/ 漁獲量データ整形]]
    - [[#テスト-長崎漁獲量][テスト/ 長崎漁獲量]]
    - [[#テスト-水温データ整形][テスト/ 水温データ整形]]
    - [[#テスト-レガシーファイル連携][テスト/ レガシーファイル連携]]
    - [[#テスト-作図][テスト/ 作図]]
  - [[#関数][関数]]
    - [[#インポート][インポート]]
    - [[#ファイル名操作][ファイル名操作]]
    - [[#セル位置取得][セル位置取得]]
    - [[#文字列操作][文字列操作]]
    - [[#種名シート名生成][種名シート名生成]]
    - [[#和暦西暦変換][和暦/西暦変換]]
    - [[#データ取得][データ取得]]
    - [[#データ作成][データ作成]]
    - [[#体長データ整形][体長データ整形]]
    - [[#漁獲量データ整形][漁獲量データ整形]]
    - [[#レガシーファイル形式で書き出し][レガシーファイル形式で書き出し]]
    - [[#各県いわしをrで使いやすい形式に変換][「各県いわし」をRで使いやすい形式に変換]]
    - [[#漁獲量データ操作][漁獲量データ操作]]
    - [[#水温データを整理][水温データを整理]]
    - [[#作図-1][作図]]

* 使い方デモ
** 体長組成整理
 #+BEGIN_SRC R
   library(gyokaikyor)
   library(dplyr)
   library(ggplot2)

   seikai_seimitsu   <- bind_rows(fmtbl_fresco("data.git/fresco/201601_201612_seikai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20160101", date.end = "20161231"),
                                  fmtbl_fresco("data.git/fresco/201701_201712_seikai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20170101", date.end = "20171231"),
                                  fmtbl_fresco("data.git/fresco/201801_201812_seikai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20180101", date.end = "20181231"),
                                  fmtbl_fresco("data.git/fresco/201901_201912_seikai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20190101", date.end = "20190228"))

   seikai_taichou   <- bind_rows(fmtbl_fresco("data.git/fresco/201601_201612_seikai_taichou_katakuchi.csv",
                                               type = "taichou",
                                               date.start = "20160101", date.end = "20161231"),
                                  fmtbl_fresco("data.git/fresco/201701_201712_seikai_taichou_katakuchi.csv",
                                               type = "taichou",
                                               date.start = "20170101", date.end = "20171231"),
                                  fmtbl_fresco("data.git/fresco/201801_201812_seikai_taichou_katakuchi.csv",
                                               type = "taichou",
                                               date.start = "20180101", date.end = "20181231"),
                                  fmtbl_fresco("data.git/fresco/201901_201912_seikai_taichou_katakuchi.csv",
                                               type = "taichou",
                                               date.start = "20190101", date.end = "20190228"))

   nihonkai_seimitsu   <- bind_rows(fmtbl_fresco("data.git/fresco/201601_201612_nihonkai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20160101", date.end = "20161231"),
                                  fmtbl_fresco("data.git/fresco/201701_201712_nihonkai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20170101", date.end = "20171231"),
                                  fmtbl_fresco("data.git/fresco/201801_201812_nihonkai_seimitsu_katakuchi.csv",
                                               type = "seimitsu",
                                               date.start = "20180101", date.end = "20181231"))

   nihonkai_taichou   <- bind_rows(fmtbl_fresco("data.git/fresco/201601_201612_nihonkai_taichou_katakuchi.csv",
                                                 type = "taichou",
                                                 date.start = "20160101", date.end = "20161231"),
                                   fmtbl_fresco("data.git/fresco/201701_201712_nihonkai_taichou_katakuchi.csv",
                                                type = "taichou",
                                                date.start = "20170101", date.end = "20171231"),
                                   fmtbl_fresco("data.git/fresco/201801_201812_nihonkai_taichou_katakuchi.csv",
                                                type = "taichou",
                                                date.start = "20180101", date.end = "20181231"),
                                   fmtbl_fresco("data.git/fresco/201901_201902_nihonkai_taichou_katakuchi.csv",
                                                type = "taichou",
                                                date.start = "20190101", date.end = "20190228"))

   nihonkai_seimitsu <- fmtbl_fresco("data.git/fresco/2018_nihonkai_seimitsu_katakuchi.csv", type = "seimitsu",
                                       date.start = "20180101", date.end = "20190331")
   seikai_taichou    <- fmtbl_fresco("data.git/fresco/2018_seikai_taichou_katakuchi.csv", type = "taichou",
                                       date.start = "20180101", date.end = "20190331")
   nihonkai_taichou  <- fmtbl_fresco("data.git/fresco/2018_nihonkai_taichou_katakuchi.csv", type = "taichou",
                                       date.start = "20180101", date.end = "20190331")
   fresco_seimitsu   <- dplyr::bind_rows(seikai_seimitsu, nihonkai_seimitsu)
   fresco_taichou    <- dplyr::bind_rows(seikai_taichou, nihonkai_taichou)

   fname_kumamoto_oct  <- "data.git/漁海況/2018年10月/各県資料/熊本県/05 H29体長組成 まき網＆棒受網（熊本県）.xlsx"
   fname_kumamoto_mar  <- "data.git/漁海況/2019年3月/各県資料/熊本県/04_H30_まき網＆棒受網体長組成.xlsx"
   fname_nagasaki_1    <- "data.git/漁海況/2018年3月/各県資料/長崎県/2017.09-2018.01小型まき網体長組成.xls"
   fname_nagasaki_2    <- "data.git/漁海況/2018年10月/各県資料/長崎県/2018.02-2018.08小型まき網体長組成.xls"
   fname_nagasaki_3    <- "data.git/漁海況/2019年3月/各県資料/長崎県/2018.09-2019.01小型まき網体長組成.xls"
   fname_kagoshima_oct <- "data.git/漁海況/2018年10月/各県資料/鹿児島県/体長組成(H29年度).xlsx"
   fname_kagoshima_mar <- "data.git/漁海況/2019年3月/各県資料/鹿児島県/体長組成(H30年度).xlsx"

   kumamoto <- bind_rows(format_bl(fname_kumamoto_oct,
                                   prefec = "kumamoto", spcs = "katakuchi"),
                           format_bl(fname_kumamoto_mar,
                                   prefec = "kumamoto", spcs = "katakuchi"))
   nagasaki <- bind_rows(format_bl(fname_nagasaki_1,
                                   prefec = "nagasaki", spcs = "katakuchi"),
                           format_bl(fname_nagasaki_2,
                                   prefec = "nagasaki", spcs = "katakuchi"),
                           format_bl(fname_nagasaki_3,
                                   prefec = "nagasaki", spcs = "katakuchi"))
   kagoshima <- bind_rows(format_bl(fname_kagoshima_oct,
                                   prefec = "kagoshima", spcs = "katakuchi"),
                           format_bl(fname_kagoshima_mar,
                                   prefec = "kagoshima", spcs = "katakuchi"))

   bl_yamaguchi <- conv2hoshifile(df = fresco_seimitsu, prefec = "yamaguchi",
                                   type = "seimitsu",
                                   ym.start = 201801, ym.end = 201903,
                                   export = TRUE, fname = "gkk_2019Mar_bl_yamaguchi.csv")
   bl_fukuoka   <- 0
   bl_saga      <- 0
   bl_nagasaki  <- conv2hoshifile(df = nagasaki, prefec = "nagasaki",
                                   type = "taichou",
                                   ym.start = 201801, ym.end = 201903,
                                   export = TRUE, fname = "gkk_2019Mar_bl_nagasaki.csv")

   bl_kumamoto  <- kumamoto %>%
       dplyr::filter(type == "まき網") %>%
       conv2hoshifile(prefec = "kumamoto",
                   type = "seimitsu",
                   ym.start = 201801, ym.end = 201903,
                   export = TRUE, fname = "gkk_2019Mar_bl_kumamoto_maki.csv")

   bl_kagoshima <- kagoshima %>%
       dplyr::filter(grepl("まき", type)) %>%
       conv2hoshifile(prefec = "kagoshima",
                   type = "taichou",
                   ym.start = 201801, ym.end = 201903,
                   export = TRUE, fname = "gkk_2019Mar_bl_kagoshima_maki.csv")
   bl_seikai    <- 0

   bl_all <- bl_yamaguchi + bl_fukuoka + bl_saga +
       bl_nagasaki + bl_kumamoto + bl_kagoshima + bl_seikai
    #+END_SRC
** 漁獲量整理
    #+BEGIN_SRC R
      library(hash)
      library(dplyr)
      library(ggplot2)

      fname  <- c("data.git/漁海況/2019年3月/各県資料/熊本県/01_H30まき網漁獲量（熊本県）.xls",
                  "data.git/漁海況/2019年3月/各県資料/熊本県/02_H30棒受網漁獲量（熊本県）.xls",
                  "data.git/漁海況/2019年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls",
                  "./data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls",
                  "./data.git/漁海況/2019年3月/各県資料/長崎県/奈留漁協ｲﾜｼ類（中小旋）とりまとめ.xlsx",
                  "./data.git/漁海況/2019年3月/各県資料/長崎県/九十九島漁協ｲﾜｼ類(中小まき)とりまとめ.xlsx",
                  "data.git/漁海況/2019年3月/各県資料/鹿児島県/４港月計表（30年度）.xlsx",
                  "data.git/漁海況/2019年3月/各県資料/佐賀県/➁佐賀県_予報対象種漁獲量（元データ）.xls",
                  "data.git/漁海況/2019年3月/各県資料/福岡県/2019-3月送付_S51_H30経年福岡漁獲量データ(提出分).xlsx",
                  "data.git/漁海況/2019年3月/各県資料/山口県/2018-2019湊銘柄別水揚市場調査表.xlsx")

      prefec <- c(rep("kumamoto", 2),
                 rep("nagasaki", 4),
                 "kagoshima",
                 "saga",
                 "fukuoka",
                 "yamaguchi")
      tbl_fname <- hash(fname, prefec)

      fname2 <- give_class(fname, tbl_fname)
      fname2[[1]]
      fname2[[2]]
      fname2[[3]]
      fname2[[4]]
      fname2[[5]]
      fname2[[6]]
      fname2[[7]]
      fname2[[8]]
      fname2[[9]]
      fname2[[10]]

      spcs <- "katakuchi"

      fname_yamaguchi       <- "data.git/漁海況/2019年3月/各県資料/山口県/2018-2019湊銘柄別水揚市場調査表.xlsx"
      fname_fukuoka         <- "data.git/漁海況/2019年3月/各県資料/福岡県/2019-3月送付_S51_H30経年福岡漁獲量データ(提出分).xlsx"
      fname_saga            <- "data.git/漁海況/2019年3月/各県資料/佐賀県/➁佐賀県_予報対象種漁獲量（元データ）.xls"
      fname_kumamoto_maki   <- "data.git/漁海況/2019年3月/各県資料/熊本県/01_H30まき網漁獲量（熊本県）.xls"
      fname_kumamoto_bouuke <- "data.git/漁海況/2019年3月/各県資料/熊本県/02_H30棒受網漁獲量（熊本県）.xls"
      fname_nagasaki_ngs    <- "data.git/漁海況/2019年3月/各県資料/長崎県/長崎魚市ｲﾜｼ類（中小旋）とりまとめ.xls"
      fname_nagasaki_tbn    <- "./data.git/漁海況/2019年3月/各県資料/長崎県/橘湾中央漁協ｲﾜｼ類(中小まき)提出とりまとめ.xls"
      fname_nagasaki_nr     <- "./data.git/漁海況/2019年3月/各県資料/長崎県/奈留漁協ｲﾜｼ類（中小旋）とりまとめ.xlsx"
      fname_nagasaki_kjk    <- "./data.git/漁海況/2019年3月/各県資料/長崎県/九十九島漁協ｲﾜｼ類(中小まき)とりまとめ.xlsx"
      fname_kagoshima       <- "data.git/漁海況/2019年3月/各県資料/鹿児島県/４港月計表（30年度）.xlsx"

      yamaguchi <- format_catch(fname_yamaguchi, prefec = "yamaguchi", spcs = spcs)
      fukuoka   <- bind_rows(format_catch(fname_fukuoka, prefec = "fukuoka",
                                          spcs = spcs, type = "maki"),
                             format_catch(fname_fukuoka, prefec = "fukuoka",
                                          spcs = spcs, type= "bouuke"),
                             format_catch(fname_fukuoka, prefec = "fukuoka",
                                          spcs = spcs, type = "others"))
      saga     <- bind_rows(format_catch(fname_saga, prefec = "saga",
                                         spcs = spcs, type = "kennai"),
                            format_catch(fname_saga, prefec = "saga",
                                         spcs = spcs, type = "chumaki"),
                            format_catch(fname_saga, prefec = "saga",
                                         spcs = spcs, type = "teichi"))
      kumamoto <- bind_rows(format_catch(fname_kumamoto_maki, prefec = "kumamoto",
                                         spcs = spcs, type = "maki"),
                            format_catch(fname_kumamoto_bou, prefec = "kumamoto",
                                         spcs = spcs, type = "bouuke"))

      nagasaki <- bind_rows(format_catch(fname_nagasaki_ngs, prefec = "nagasaki",
                                         spcs = spcs, type = NULL),
                            format_catch(fname_nagasaki_tbn, prefec = "nagasaki",
                                         spcs = spcs),
                            format_catch(fname_nagasaki_nr, prefec = "nagasaki",
                                         spcs = spcs),
                            format_catch(fname_nagasaki_kjk, prefec = "nagasaki",
                                         spcs = spcs))
      kagoshima <- format_catch(fname_kagoshima, prefec = "kagoshima", spcs = spcs)


      catch_all <- dplyr::bind_rows(yamaguchi, fukuoka, saga,
                                    nagasaki, kumamoto, kagoshima)


      yamaguchi %>%
        group_by(year, month) %>%
        summarize(catch = sum(catch, na.rm = TRUE)) %>%
        export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_yamaguchi.csv")

      fukuoka %>%
        group_by(year, month) %>%
        summarize(catch = sum(catch, na.rm = TRUE)) %>%
        export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_fukuoka.csv")

      saga %>%
        dplyr::filter(type == "kennai") %>%
        group_by(year, month) %>%
        summarize(catch = sum(catch, na.rm = TRUE)) %>%
        export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_saga.csv")

      nagasaki %>%
        group_by(year, month) %>%
        summarize(catch = sum(catch, na.rm = TRUE)) %>%
        export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_nagasaki.csv")

      kumamoto %>%
        dplyr::filter(type == "maki") %>%
        group_by(year, month) %>%
        summarize(catch = sum(catch, na.rm = TRUE)) %>%
        export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_kumamoto.csv")

      kagoshima %>%
        dplyr::filter(type == "maki4ports") %>%
        group_by(year, month) %>%
        summarize(catch = sum(catch, na.rm = TRUE)) %>%
        export2kakuken_iwashi(export.csv = TRUE, fname = "gkk_2019Mar_catch_kagoshima.csv")
#+END_SRC
** 漁況予測
*** 時系列解析による予測
#+BEGIN_SRC R
  library(tidyverse)
  library(zoo)
  library(xts)
  library(lubridate)
  library(urca)
  library(forecast)
  library(tseries)
  library(ggfortify)

  stacdata       <- read_csv("/Users/ahayashi/Dropbox/Imported/Stock/Timeseries_TW_Engraulis-japonicus.csv") %>%
    rename(year = Year,
           biomass = `B_10^3ton`) %>%
    dplyr::select(year, biomass)

  sstdata        <- format_temp("data.git/水温データ/mgdsst_till201902.xlsx", 2018)

  list_catchdata <- iwashi2list(path = "../../../Google Drive/gkk/各県いわし_林20190312.xlsx",
                                sheet = "カタクチイワシ",
                                year.end = 2019)

  # make 'ts' class data
  db <- summarize_seikai(list_catchdata) %>%
    tidyr::gather(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec,
                  key = month, value = catch) %>%
    dplyr::mutate(month = abb2num(month)) %>%
    left_join(sstdata, key = c(year, month)) %>%
    left_join(stacdata, key = year) %>%
    mutate(ym = paste0(year, formatC(month, width = 2, flag = 0)) %>%
             as.numeric()) %>%
    arrange(ym) %>%
    mutate(logcatch = log(catch),
           logsst = log(tw_degc),
           logb = log(biomass)) %>%
    select(year, month, logcatch, logsst, logb) %>%
    as.data.frame()


  dbts <- db %>%
    ts(start = min(db$year), frequency = 12)

  # Make data for model ------------------------------------------------------------

  train <- window(dbts,  end = c(2017, 12))
  sst_b <- train[, c("logsst", "logb")]
  test  <- window(dbts,  start = c(2018, 1), end = c(2018, 12))

  # Build model ----------------------------------------------------------------------
  model_sarimax1 <- Arima(y = train[, "logcatch"],
                         order = c(1, 1, 1),
                         seasonal = list(order = c(1, 0, 0)),
                         xreg = sst_b)
  model_sarimax1
  #   Sst and biomass have positive effect to catch.
  #   AIC was 750.41.
  #   --- But model order should be considered.


  # Select model order automatically
  model_sarimax <- auto.arima(y = train[, "logcatch"],
                              xreg = sst_b,
                              ic = "aic",
                              max.order = 8,
                              stepwise = FALSE,
                              approximation = FALSE,
                              parallel = TRUE,
                              num.cores = 4)
  model_sarimax
  #    Regression with ARIMA(2,0,0)(1,0,1) errors were selected.
  #    AIC was 725.1.

  # Check model
  abs(polyroot(c(1, -coef(model_sarimax)[c("ar1", "ar2")]))) # ok because greater than 1.
  abs(polyroot(c(1, -coef(model_sarimax)[c("sar1")]))) # ok because greater than 1.

  checkresiduals(model_sarimax)                       # ok mecause p > 0.001
  jarque.bera.test(resid(model_sarimax)) # Not good. Residuals do not distribute normally (p < 0.001).

  # Forcast
  sst_b_test <- test[, c("logsst", "logb")]
  sarimax_f <- forecast(model_sarimax,
                        xreg = sst_b_test,
                        h = 12,
                        level = c(95, 70))
  sarimax_f
  autoplot(sarimax_f, predict.colour = 1, main = "Prediction by ARIMA")
  # Forcast completed successfully.
  # But, x values sould be considered.

  # Forecast using mean- or last x values
  sst_b_mean <- data.frame(logsst = rep(mean(train[, "logsst"]), 12),
                           logb   = rep(mean(train[, "logb"]), 12)) %>%
    as.matrix()
  sarimax_f_mean <- forecast(model_sarimax, xreg = sst_b_mean)
  autoplot(sarimax_f_mean, predict.colour = 1, main = "Prediction by ARIMA, using mean SST and Biomass")

  sst_b_tail <- data.frame(logsst = rep(tail(train[, "logsst"], 1), 12),
                           logb   = rep(tail(train[, "logb"], 1), 12)) %>%
    as.matrix()
  sarimax_f_tail <- forecast(model_sarimax, xreg = sst_b_tail)
  autoplot(sarimax_f_tail, predict.colour = 1, main = "Prediction by ARIMA, using last SST and Biomass")


  ##################################################################### end
  str(sarimax_f)
  out <- list(mean = exp(sarimax_f$mean),
              lower = exp(sarimax_f$lower),
              upper = exp(sarimax_f$upper))
  out

  # Naive forecast
  naive_f_mean   <- meanf(train[, "logcatch"], h = 12)
  naive_f_latest <- rwf(train[, "logcatch"], h = 12)

  # Validation of forecast
  sarimax_rmse <- sqrt(
    sum((sarimax_f$mean - test[, "logcatch"])^2) / length(sarimax_f$mean)
  )
  sarimax_rmse
  accuracy(sarimax_f, x = test[, "logcatch"])
  accuracy(sarimax_f_mean, x = test[, "logcatch"])
  accuracy(sarimax_f_tail, x = test[, "logcatch"]) # Best
  # ---------------All three forecasts were found to be good because RMSEs of
  #   ---------------test sets were smaller than those of training sets.
  #   -------------Forecast using TAIL DATA was the best.
  accuracy(naive_f_mean, x = test[, "logcatch"]) # Not bad but worse than ARIMA
  accuracy(naive_f_latest, x = test[, "logcatch"]) # Bad!

  model_best <- sarimax_f_tail
  model_best <- sarimax_f_tail
  plot_forecast_real(model_best, list_catchdata, 2018, 12)

  # Forcast for next period
  sarimax_f <- forecast(model_sarimax,
                        xreg = sst_b_test,
                        h = 12,
                        level = c(95, 70))

  train2           <- window(dbts,  end = c(2018, 12))
  sst_b2           <- train2[, c("logsst", "logb")]
  sarimax_forecast <- auto.arima(y = train2[, "logcatch"],
                              xreg = sst_b2,
                              ic = "aic",
                              max.order = 8,
                              stepwise = FALSE,
                              approximation = FALSE,
                              parallel = TRUE,
                              num.cores = 4)
  sst_b_tail2 <- data.frame(logsst = rep(tail(train2[, "logsst"], 1), 12),
                            logb   = rep(tail(train2[, "logb"], 1), 12)) %>%
    as.matrix()
  sarimax_f_future <- forecast(sarimax_forecast, xreg = sst_b_tail2)


  png("forecast.png", width = 1400, height = 1000)
  par(mai = c(2, 2, 0, 2), family = "HiraKakuProN-W3")
  plot_forecast(sarimax_f_future, list_catchdata, 2019, 1)
  dev.off()
#+END_SRC
** 作図
#+BEGIN_SRC R
  list_catchdata <- iwashi2list(path = "../../../Google Drive/gkk/各県いわし_林20190312.xlsx",
                                sheet = "カタクチイワシ",
                                year.end = 2019, year.start = 1992)
  df.seikai <- summarize_seikai(list_catchdata)

  png("catch_monthvar.png", width = 1300, height = 1000, res = 150)
  par(mai = c(0.5, 2, 0.5, 1), family = "HiraKakuProN-W3")
  plot_catch_monthvar(df.seikai = df.seikai, year = 2019, gkk.month = "Mar")
  dev.off()

  png("catch_prefec.png", width = 1500, height = 1000)
  par(mai = c(0.5, 2, 0.5, 1), family = "HiraKakuProN-W3")
  plot_catch_prefec(list_catchdata, 2019, "Mar")
  dev.off()

  library(XLConnect)
  library(cluster)
  # mathematical parameters
  YMAX_INIT   <- 0; ymax_updated <- YMAX_INIT
  MONTHS      <- 1:12
  SHEETNAME   <- "計"
  BLBIN       <- 5
  CLASS_LEFT  <- seq(0, 295, BLBIN)
  CLASS_RIGHT <- CLASS_LEFT + BLBIN
  CLASS_NAME  <- paste(formatC(CLASS_LEFT, width=3, flag=0), "_",
                       formatC(CLASS_RIGHT, width=3, flag=0), sep="")
  CLASS00_10_AGE0   <- data.frame(matrix(1, nrow=2, ncol=12), 
                                  row.names=c("000-005", "005-010"))
  CLASS00_10_AGE12  <- data.frame(matrix(0, nrow=2, ncol=12), 
                                  row.names=c("000-005", "005-010"))
  CLASS155_300   <- data.frame(matrix(0, nrow=length(seq(155, 295, 5)), ncol=12), 
                                  row.names=paste(seq(155, 295, 5), 
                                                    seq(160, 300, 5), sep = "_"))
  colnames(CLASS00_10_AGE0)   <- month.abb
  colnames(CLASS00_10_AGE12)  <- month.abb
  colnames(CLASS155_300)      <- month.abb
  AGE_LENGTH_KEY_0  <- read.csv("../_Library/ageLengthKey0.csv", row.names=1)
  AGE_LENGTH_KEY_0  <- rbind(CLASS00_10_AGE0, AGE_LENGTH_KEY_0, CLASS155_300)
  AGE_LENGTH_KEY_1  <- read.csv("../_Library/ageLengthKey1.csv", row.names=1)
  AGE_LENGTH_KEY_1  <- rbind(CLASS00_10_AGE12, AGE_LENGTH_KEY_1, CLASS155_300)
  AGE_LENGTH_KEY_2  <- read.csv("../_Library/ageLengthKey2.csv", row.names=1)
  AGE_LENGTH_KEY_2  <- rbind(CLASS00_10_AGE12, AGE_LENGTH_KEY_2, CLASS155_300)
  CLASS_LEFT_AL     <- as.numeric(substr(rownames(AGE_LENGTH_KEY_0), 1,3))
  STARTROW    <- 6 # Start from 0-5 mm but it is OK
  ENDROW      <- STARTROW + length(CLASS_LEFT) - 1

  plot.blhist <- function()
  # 体長組成
  # graphic parameters
  BORDER_KAERI_KOBA <- 50
  BORDER_KOBA_CHUBA <- 80
  BORDER_CHUBA_OHBA <- 100
  BARWIDTH      <- 4
  COL_FILL      <- hsv(0, 0, 0)
  COL0          <- hsv(200/360, 0.8, 0.9)
  COL1          <- hsv(200/360, 0.8, 0.6)
  COL2          <- hsv(200/360, 0.8, 0.1)
  COL_KAERI     <- hsv( 60/360, 0.9, 0.9, 0.1)
  COL_KOBA      <- hsv( 60/360, 0.9, 0.9, 0.35)
  COL_CHUBA     <- hsv( 60/360, 0.9, 0.9, 0.65)
  COL_OHBA      <- hsv( 60/360, 0.9, 0.9, 1)
  XMAX          <- 150
  YMAX_INIT     <- 100 # decide value by refering to ymax_init
  ymax_updated  <- 0
  TICKBIN_X     <- 1
  TICKBIN_Y     <- 10
  TICKLEN_X     <- 0.25
  TICKLEN_Y     <- 0.25
  LABELBIN_X    <- 5 # in cm
  LABELBIN_Y    <- 20
  pdf(paste("../output/gyokaikyo_", YEAR, "年3月_体長組成.pdf", sep=""), family="Helvetica", width=9, height=6)
  par(mfcol=c(12, 3), mai=c(0.1, 0.4, 0.05, 0.1), ps=20, oma=c(0, 0, 0.5, 0))
  for (y in (YEAR - 2):YEAR){ # To plot blhist of recent three years
    ychar     <- substr(y, 3, 4)
    if (y != YEAR){
      yfilename <- paste("★カタクチ", ychar, ".xls", sep="")
      wb        <- loadWorkbook(yfilename)
      data      <- readWorksheetFromFile(yfilename, sheet=SHEETNAME)
    }else{
      # No need to read file
    }
    out       <- NULL
    for (m in MONTHS){
      if (y != YEAR){
        startcol    <- 3
      }else{
        if (m == 3){
          break
        }
        startcol    <- 15
      }
      mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, startcol + m - 1]))
      out         <- cbind(out, mdata)
      n_mdata     <- sum(mdata)
      mdata_pcnt  <- mdata / n_mdata * 100
      if(sum(mdata)!=0){
        max_pcnt    <- max(mdata_pcnt, na.rm=T) 
        if(max_pcnt > ymax_updated){
          ymax_updated <- max_pcnt
        }
      }
      ymax      <- YMAX_INIT
      ymax_int  <- ceiling(max(mdata)/100) * 100
      if(ymax_int > ymax){
        ymax <- ymax_int
      }
      tickbin_y   <- ymax/2
      labelbin_y  <- ymax/1
      plot(1, 1, xlim=c(0, XMAX), ylim=c(0, ymax), 
           type="n", xaxs="i", yaxs="i", axes=F, ann=F)
      polygon(c(0, BORDER_KAERI_KOBA, BORDER_KAERI_KOBA, 0),
              c(0, 0, ymax, ymax), col=COL_KAERI, border=F)
      polygon(c(BORDER_KAERI_KOBA, BORDER_KOBA_CHUBA, BORDER_KOBA_CHUBA, BORDER_KAERI_KOBA), 
              c(0, 0, ymax, ymax), col=COL_KOBA, border=F)
      polygon(c(BORDER_KOBA_CHUBA, BORDER_CHUBA_OHBA, BORDER_CHUBA_OHBA, BORDER_KOBA_CHUBA),
              c(0, 0, ymax, ymax), col=COL_CHUBA, border=F)
      polygon(c(BORDER_CHUBA_OHBA, XMAX, XMAX, BORDER_CHUBA_OHBA), 
              c(0, 0, ymax, ymax), col=COL_OHBA, border=F)
      m_alkey0  <- AGE_LENGTH_KEY_0[, m]
      m_alkey1  <- AGE_LENGTH_KEY_1[, m]
      m_alkey2  <- AGE_LENGTH_KEY_2[, m]
      bottom0   <- rep(0, length(m_alkey0))
      top0      <- m_alkey0 * mdata
      bottom1   <- top0
      top1      <- (bottom1 + m_alkey1 * mdata)
      bottom2   <- top1 
      top2      <- (bottom2 + m_alkey2 * mdata)
      rect(CLASS_LEFT, bottom0, CLASS_LEFT + BARWIDTH, top0, col=COL0, border=F)
      rect(CLASS_LEFT, bottom1, CLASS_LEFT + BARWIDTH, top1, col=COL1, border=F)
      rect(CLASS_LEFT, bottom2, CLASS_LEFT + BARWIDTH, top2, col=COL2, border=F)
      # rect(CLASS_LEFT, rep(0, length(CLASS_LEFT)), CLASS_LEFT + BARWIDTH, mdata_pcnt, col=COL_FILL, border=F)
      axis(1, at=seq(0, XMAX, TICKBIN_X * 10), labels=F, tcl=TICKLEN_X)
      # axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
      axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax), tcl=0, labels=F)
      axis(2, at=seq(0, ymax, tickbin_y), labels=F, tcl=TICKLEN_Y)
      axis(2, at=seq(0, ymax, labelbin_y), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax, labelbin_y), labels=T, las=2, pos=4, col="transparent")
    }
    out           <- as.data.frame(out)
    colnames(out) <- month.abb[1:ncol(out)]
    rownames(out) <- CLASS_NAME
    if (exists("wb") == TRUE){
      rm(wb)
    }
    gc(); gc()
  }
  dev.off()
  print(paste("max % is", ceiling(ymax_updated)))

  pdf(paste("../output/gyokaikyo_", YEAR, "年3月_体長組成_4月スタート.pdf", sep=""), family="Helvetica", width=9, height=6)
  par(mfcol=c(12, 3), mai=c(0.1, 0.4, 0.05, 0.1), ps=20, oma=c(0, 0, 0.5, 0))
  for (y in (YEAR - 2):YEAR - 1){
    ychar     <- substr(y, 3, 4)
    yfilename <- paste("★カタクチ", ychar, ".xls", sep = "")
    wb        <- loadWorkbook(yfilename)
    data      <- readWorksheetFromFile(yfilename, sheet = SHEETNAME)
    out       <- NULL
    for(m in 4:12){
      mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, 3 + m - 1]))
      out         <- cbind(out, mdata)
      n_mdata     <- sum(mdata)
      mdata_pcnt  <- mdata / n_mdata * 100
      if(sum(mdata)!=0){
        max_pcnt    <- max(mdata_pcnt, na.rm=T) 
        if(max_pcnt > ymax_updated){
          ymax_updated <- max_pcnt
        }
      }
      ymax      <- YMAX_INIT
      ymax_int  <- ceiling(max(mdata)/100) * 100
      if(ymax_int > ymax){
        ymax <- ymax_int
      }
      tickbin_y   <- ymax/2
      labelbin_y  <- ymax/1
      plot(1, 1, xlim=c(0, XMAX), ylim=c(0, ymax), type="n", xaxs="i", yaxs="i", axes=F, ann=F)
      polygon(c(0, BORDER_KAERI_KOBA, BORDER_KAERI_KOBA, 0), c(0, 0, ymax, ymax), col=COL_KAERI, border=F)
      polygon(c(BORDER_KAERI_KOBA, BORDER_KOBA_CHUBA, BORDER_KOBA_CHUBA, BORDER_KAERI_KOBA), c(0, 0, ymax, ymax), col=COL_KOBA, border=F)
      polygon(c(BORDER_KOBA_CHUBA, BORDER_CHUBA_OHBA, BORDER_CHUBA_OHBA, BORDER_KOBA_CHUBA), c(0, 0, ymax, ymax), col=COL_CHUBA, border=F)
      polygon(c(BORDER_CHUBA_OHBA, XMAX, XMAX, BORDER_CHUBA_OHBA), c(0, 0, ymax, ymax), col=COL_OHBA, border=F)
      m_alkey0  <- AGE_LENGTH_KEY_0[, m]
      m_alkey1  <- AGE_LENGTH_KEY_1[, m]
      m_alkey2  <- AGE_LENGTH_KEY_2[, m]
      bottom0   <- rep(0, length(m_alkey0))
      top0      <- m_alkey0 * mdata
      bottom1   <- top0
      top1      <- (bottom1 + m_alkey1 * mdata)
      bottom2   <- top1 
      top2      <- (bottom2 + m_alkey2 * mdata)
      rect(CLASS_LEFT, bottom0, CLASS_LEFT + BARWIDTH, top0, col=COL0, border=F)
      rect(CLASS_LEFT, bottom1, CLASS_LEFT + BARWIDTH, top1, col=COL1, border=F)
      rect(CLASS_LEFT, bottom2, CLASS_LEFT + BARWIDTH, top2, col=COL2, border=F)
      # rect(CLASS_LEFT, rep(0, length(CLASS_LEFT)), CLASS_LEFT + BARWIDTH, mdata_pcnt, col=COL_FILL, border=F)
      # text(15, ymax/2, paste(ychar, m), cex = 1.5)
      axis(1, at=seq(0, XMAX, TICKBIN_X * 10), labels=F, tcl=TICKLEN_X)
      # axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
      axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax), tcl=0, labels=F)
      axis(2, at=seq(0, ymax, tickbin_y), labels=F, tcl=TICKLEN_Y)
      axis(2, at=seq(0, ymax, labelbin_y), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax, labelbin_y), labels=T, las=2, pos=4, col="transparent")
    }
    if (exists("wb") == TRUE){
      rm(wb)
    }
    gc(); gc()
    if(y != (YEAR - 1)){
      ychar_plus1 <- substr(y + 1, 3, 4)
      yfilename <- paste("★カタクチ", ychar_plus1, ".xls", sep="")
      wb        <- loadWorkbook(yfilename)
      data      <- readWorksheetFromFile(yfilename, sheet=SHEETNAME)
    }
    for(m in 1:3){
      if (y != (YEAR - 1)){
        mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, 3 + m - 1]))
      }else{
        if (m == 3){
          break
        }
        mdata       <- as.numeric(as.character(data[STARTROW:ENDROW, 15 + m - 1]))
      }
      # if(y == 2017 & m == 1){browser()}
      out         <- cbind(out, mdata)
      n_mdata     <- sum(mdata)
      mdata_pcnt  <- mdata / n_mdata * 100
      if(sum(mdata)!=0){
        max_pcnt    <- max(mdata_pcnt, na.rm=T) 
        if(max_pcnt > ymax_updated){
          ymax_updated <- max_pcnt
        }
      }
      ymax      <- YMAX_INIT
      ymax_int  <- ceiling(max(mdata)/100) * 100
      if(ymax_int > ymax){
        ymax <- ymax_int
      }
      tickbin_y   <- ymax/2
      labelbin_y  <- ymax/1
      plot(1, 1, xlim=c(0, XMAX), ylim=c(0, ymax), type="n", xaxs="i", yaxs="i", axes=F, ann=F)
      polygon(c(0, BORDER_KAERI_KOBA, BORDER_KAERI_KOBA, 0), c(0, 0, ymax, ymax), col=COL_KAERI, border=F)
      polygon(c(BORDER_KAERI_KOBA, BORDER_KOBA_CHUBA, BORDER_KOBA_CHUBA, BORDER_KAERI_KOBA), c(0, 0, ymax, ymax), col=COL_KOBA, border=F)
      polygon(c(BORDER_KOBA_CHUBA, BORDER_CHUBA_OHBA, BORDER_CHUBA_OHBA, BORDER_KOBA_CHUBA), c(0, 0, ymax, ymax), col=COL_CHUBA, border=F)
      polygon(c(BORDER_CHUBA_OHBA, XMAX, XMAX, BORDER_CHUBA_OHBA), c(0, 0, ymax, ymax), col=COL_OHBA, border=F)
      m_alkey0  <- AGE_LENGTH_KEY_0[, m]
      m_alkey1  <- AGE_LENGTH_KEY_1[, m]
      m_alkey2  <- AGE_LENGTH_KEY_2[, m]
      bottom0   <- rep(0, length(m_alkey0))
      top0      <- m_alkey0 * mdata
      bottom1   <- top0
      top1      <- (bottom1 + m_alkey1 * mdata)
      bottom2   <- top1 
      top2      <- (bottom2 + m_alkey2 * mdata)
      rect(CLASS_LEFT, bottom0, CLASS_LEFT + BARWIDTH, top0, col=COL0, border=F)
      rect(CLASS_LEFT, bottom1, CLASS_LEFT + BARWIDTH, top1, col=COL1, border=F)
      rect(CLASS_LEFT, bottom2, CLASS_LEFT + BARWIDTH, top2, col=COL2, border=F)
      # rect(CLASS_LEFT, rep(0, length(CLASS_LEFT)), CLASS_LEFT + BARWIDTH, mdata_pcnt, col=COL_FILL, border=F)
      axis(1, at=seq(0, XMAX, TICKBIN_X * 10), labels=F, tcl=TICKLEN_X)
      # axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=seq(0, XMAX, LABELBIN_X))
      axis(1, at=seq(0, XMAX * 10, LABELBIN_X * 10), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax), tcl=0, labels=F)
      axis(2, at=seq(0, ymax, tickbin_y), labels=F, tcl=TICKLEN_Y)
      axis(2, at=seq(0, ymax, labelbin_y), labels=F, tcl=-0.3)
      axis(2, at=seq(0, ymax, labelbin_y), labels=T, las=2, pos=4, col="transparent")
      # text(15, ymax/2, paste(ychar, m), cex = 1.5)
    }
    # }else{
    out           <- as.data.frame(out)
    colnames(out) <- month.abb[1:ncol(out)]
    rownames(out) <- CLASS_NAME
    if (exists("wb") == TRUE){
      rm(wb)
    }
    gc(); gc()
  }
  dev.off()


  # 資源量
  data <- read_csv("/Users/ahayashi/Dropbox/Imported/Stock/Timeseries_TW_Engraulis-japonicus.csv")
  plot_stock <- function(data, var) {
    x <- dplyr::pull(data, Year)
    y <- dplyr::pull(data, var)
    xmin          <- 1975
    xmax          <- 2020
    ymax          <- 250
    blimit        <- 91
    tickbin_y     <- 50
    ticklen_x     <- ymax/100000
    ticklen_y     <- 0.3
    labelbin_x    <- 5
    labelbin_y    <- 100
    thisx         <- rev(x)[1]
    lastx         <- rev(x)[2]
    recentx       <- (lastx - 4):lastx
    thisy         <- y[which(x == thisx)]
    lasty         <- y[which(x == lastx)]

    plot(data$Year, y, ylim = c(0, ymax), type="n",
         axes = FALSE, ann = FALSE, yaxs="i")
    rect(recenty[1] - 0.2, 0, recenty[5] + 0.2, 250, col = hsv(136/360, 0.24, 0.87),
         border = FALSE)
    abline(h = blimit, lwd = 2,  lty = 2)
    lines(data$Year, y, lwd = 4)
    points(data$Year, y, pch = 16, cex = 3)
    points(lastx, lasty, pch = 16, cex = 4, col = hsv(200 / 360, 0.8, 0.8))
    points(thisx, thisy, pch = 16, cex = 4.5, col = hsv(0, 0.8, 0.8))
    points(thisx, thisy, pch = 16, cex = 2.5, col = "white")
    text(thisx, thisy, paste0(thisx, "年"),
         pos = 4, offset = 1, xpd = TRUE, cex = 4,
         col = hsv(0, 0.8, 0.8))
    text(thisx + 2, blimit, "Blimit",
         pos = 4, offset = -1, xpd = TRUE, cex = 4)
    axis(1, at = seq(xmin, xmax, labelbin_x), tcl = 0, labels = FALSE)
    axis(1, at = seq(xmin, xmax, labelbin_x), tcl = -1, labels = FALSE)
    axis(1, at = seq(xmin, xmax, labelbin_x), cex.axis = 3.5, pos = -10,
         col = "transparent")
    axis(2, at = seq(0, ymax), tcl = 0, labels = FALSE)
    axis(2, at = seq(0, ymax, labelbin_y), cex.axis = 3.5)
    mtext("年", 1, cex = 5, line = 7)
    mtext("親魚量（千トン）", 2, cex = 6, line = 5)
  }

  png("ssb.png", width = 1300, height = 1000)
  par(mai = c(2, 2, 2, 2), family = "HiraKakuProN-W3")
  plot_stock(data, "SSB_10^3ton")
  dev.off()


#+END_SRC
** 水温データの整理
#+BEGIN_SRC R
  temp <- format_temp("/Users/ahayashi/Documents/GitHub/gyokaikyor/data.git/水温データ/mgdsst_till201902.xlsx",
                     year.end = 2019)
  write.csv(temp, "/Volumes/評価研/個人的データ置き場/hayashi/output/gkk_2019Mar_sst.csv", row.names = FALSE)
#+END_SRC
* 開発環境の整備
#+BEGIN_SRC R :results silent
  # usethis::create_package("gyokaikyor")
  # usethis::use_mit_license("Akira Hayashi")
  # usethis::use_coverage(type = "codecov")
  # usethis::use_lifecycle_badge("experimental")
#+END_SRC
** 本バッケージ内部で使用するパッケージ
#+BEGIN_SRC R :results silent
  usethis::use_package("magrittr", "Imports")
  usethis::use_package("hash")
  usethis::use_package("tibble")
  usethis::use_package("cellranger")
  usethis::use_package("tidyr")
  usethis::use_package("lubridate")
  usethis::use_package("readxl")
  usethis::use_package("readr")
  usethis::use_package("stringr")
  usethis::use_package("purrr")
  usethis::use_dev_package("tinyplyr")
  usethis::use_package("Nippon")
  usethis::use_package("stringi")
  usethis::use_package("dplyr")
  usethis::use_package("forecast")
  # usethis::use_package("ggplot2", "Imports")
  # usethis::use_package("tibble", "Imports")
  # usethis::use_testthat()
  # usethis::use_pipe()
#+END_SRC

#+BEGIN_SRC sh :exports results :session nil
cat DESCRIPTION
#+END_SRC

#+RESULTS[26e6d91ffe9c3ff5d95f888fb0006e9154a02abb]:
#+begin_example

Package: gyokaikyor
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person(given = "First",
           family = "Last",
           role = c("aut", "cre"),
           email = "first.last@example.com")
Description: What the package does (one paragraph).
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
Imports: 
    magrittr,
    hash,
    tibble,
    cellranger,
    tinyplyr,
    tidyr,
    lubridate,
    purrr,
    readxl,
    stringr,
    Nippon,
    dplyr
Suggests: 
    testthat,
    covr
RoxygenNote: 6.1.1
#+end_example

#+BEGIN_SRC sh :exports results :session nil
cat NAMESPACE
#+END_SRC

#+RESULTS:
: 
: Generated by roxygen2: do not edit by hand
: <>%")
: >%")

* 開発
** リロード & 自動テスト
#+BEGIN_SRC R :results silent
  devtools::document(roclets=c('rd', 'collate', 'namespace'))
  devtools::load_all()
  system("R CMD INSTALL --preclean --no-multiarch --with-keep.source .")
  devtools::test()
  lintr::lint_package()
  devtools::check(args = "--as-cran")
  covr::package_coverage()
#+END_SRC

** テストコード
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** テスト/ 文字列操作
#+BEGIN_SRC R :tangle tests/testthat/test_handle_str.R
  library(gyokaikyor)
  context("Handle string")

  target <-
    c("漁獲年月日", "", "2017.4.20", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.5.19", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.6.23", "操業海域", "八代海", "漁法", "まき網")

  test_that("get_col2load() works well",
            expect_equal(get_col2load(target,
                            regex = "20[0-9]{2}\\.[0-9][0-9]?\\.[0-9][0-9]?",
                            offset = -2),
                         c(1, 8, 15))
            )

  test_that("parse_ym() works well", {
    expect_setequal(parse_ym("2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_setequal(parse_ym("foo/bar/2012.01-2012.09") %>% unlist(),
                    c(2012, 1, 2012, 9))
    expect_error(parse_ym("20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
    expect_error(parse_ym("foo/bar/20012.01-2012.09") %>% unlist(),
                 "Failed parsing to year", fix = TRUE)
  })
#+END_SRC
*** テスト/ 種名生成
#+BEGIN_SRC  R :tangle tests/testthat/test_make_shtname.R
  library(gyokaikyor)
  context("Make shtname of prefecture")

  test_that("make_shtname() makes sheetname for kumamoto data", {
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "kumamoto", spcs = "sabarui"), "サバ類")
    expect_error(make_shtname(prefec = "kumamoto", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for nagasaki data", {
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "katakuchi"), "カタクチ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "urume"), "ウルメ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maiwashi"), "マイワシ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "masaba"), "マサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "gomasaba"), "ゴマサバ")
    expect_equal(make_shtname(prefec = "nagasaki", spcs = "maaji"), "マアジ")
    expect_error(make_shtname(prefec = "nagasaki", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() makes sheetname for kagoshima data", {
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "katakuchi"), "ｶﾀｸﾁ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "urume"), "ｳﾙﾒ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maiwashi"), "ﾏｲﾜｼ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "masaba"), "ﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "gomasaba"), "ｺﾞﾏｻﾊﾞ")
    expect_equal(make_shtname(prefec = "kagoshima", spcs = "maaji"), "ﾏｱｼﾞ")
    expect_error(make_shtname(prefec = "kagoshima", spcs = "foo"),
                 "Unknown spcs name")
  })

  test_that("make_shtname() stops for unknown prefecture", {
    expect_error(make_shtname(prefec = "foo", spcs = "katakuchi"),
                 "Unknown prefecture")
  })
#+END_SRC
*** テスト/ 計測データ取得
#+BEGIN_SRC  R :tangle tests/testthat/test_get_measdata.R
  library(gyokaikyor)
  context("Get measure data vector from data frame")

  test_that("get_vector() extracts vector correctly", {
    df <- data.frame(a = 1:200, b = 101:300, c = c(201:250, NA, 252:400))
    expect_equal(get_vector(1, 10:20, df, na.rm = TRUE), 10:20)
    expect_equal(get_vector(2, 50:60, df, na.rm = TRUE), 150:160)
    expect_equal(get_vector(3, 50:60, df, na.rm = TRUE), c(250, 252:260))
    expect_equal(get_vector(3, 50:60, df, na.rm = FALSE), c(250, 0, 252:260))
  })

  test_that("get_measdata() extracts vector correctly", {
    df <- data.frame(kumamoto_a = 1:200, kumamoto_b = c(1:100, NA, 102:200))
    expect_equal(get_measdata(1, df, prefec = "kumamoto"), 8:107)
    expect_equal(get_measdata(2, df, prefec = "kumamoto"), c(8:100, 102:107))
    expect_error(get_measdata(1, df, prefec = "foo"),
                 "Unknown prefecture", fix = TRUE)
  })

  test_that("get_histdata() extracts vector correctly", {
    df <- data.frame(blank = 1:200,
                     class_l = seq(5, 1000, 5), class_r = seq(10, 1005, 5),
                     a = c(1:50, rep(NA, 50), 101:150,
                           sum(c(1:50, 101:150)), rep(NA, 49)))
    expect_equal(get_histdata(4, df, prefec = "nagasaki")[, 2],
                 c(5:50, rep(0, 50), 101:150))
    expect_error(get_histdata(1, df, prefec = "kumamoto"),
                 "Unknown prefecture", fix = TRUE)
  })
#+END_SRC
*** テスト/ 体長データ整形
#+BEGIN_SRC R :tangle tests/testthat/test_fmtbl.R
  library(gyokaikyor)
  context("Load blhist data from Excel spreadhseet and tidy it up")

  test_that("fmtbl() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    class(path) <- "nagasaki"
    expect_is(fmtbl(path, spcs = "katakuchi", nest = TRUE), "data.frame")
  })

  test_that("fmtbl.nagasaki() works well", {
    path <- "ExcelFiles/2017.09-2018.01_test_bl_nagasaki.xls"
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.nagasaki(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("fmtbl.kumamoto() works well", {
    path <- "ExcelFiles/test_bl_kumamoto.xlsx"
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kumamoto(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("fmtbl.kagoshima() works well", {
    path <- "ExcelFiles/test_bl_kagoshima.xlsx"
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = TRUE),
              "data.frame")
    expect_is(fmtbl.kagoshima(path, spcs = "katakuchi", nest = FALSE),
              "data.frame")
  })

  test_that("rename_class() make blclass from start of class and bin", {
    expect_equal(rename_class(10, 5), "[10,15)")
    expect_equal(rename_class(20, 5), "[20,25)")
    expect_equal(rename_class(0, 1), "[0,1)")
    expect_equal(rename_class(1, 2), "[1,3)")
  })

  test_that("fmtbl_fresco() tidy fresco data", {
    fname_taichou <- "ExcelFiles/test_fresco_taichou.csv"
    fname_seimitsu <- "ExcelFiles/test_fresco_seimitsu.csv"
    taichou  <- fmtbl_fresco(fname_taichou, type = "taichou",
                             date.start = "20180101", date.end = "20190331")
    seimitsu <- fmtbl_fresco(fname_seimitsu, type = "seimitsu",
                            date.start = "20180101", date.end = "20190331")
    expect_is(taichou, "data.frame")
    expect_is(seimitsu, "data.frame")
  })
#+END_SRC
*** テスト/ 漁獲量データ整形
#+BEGIN_SRC  R :tangle tests/testthat/test_fmtcatch.R
  library(gyokaikyor)
  context("Load catch data from Excel spreadhseet and tidy it up")

  test_that("fmtcatch.yamaguchi() work correctly", {
    path <- "ExcelFiles/test_catch_yamaguchi.xlsx"
    df   <- fmtcatch.yamaguchi(path, spcs = "katakuchi")
    expect_is(df, "data.frame")

    expect_setequal(dplyr::filter(df,
                                  year == 2018,
                                  month == 1,
                                  type == "sukui") %>%
                    dplyr::pull(catch),
                    seq(33, 36))
    expect_setequal(unique(df$type), c("sukui", "bouuke"))
  })

  test_that("fmtcatch.fukuoka() work correctly", {
    path <- "ExcelFiles/test_catch_fukuoka.xlsx"
    df   <- fmtcatch.fukuoka(path, spcs = "katakuchi", type = "maki")
    expect_is(df, "data.frame")
    expect_setequal(subset(df, year == 1977)$catch,
                    c(18, 51, 84, 117, 150, 183, 216, 249))
    expect_setequal(subset(df, year == 1978)$catch,
                    c(315, 348, 381, 414, 447, 480, 513, 546))
    expect_equal(unique(df$type), "maki")
    expect_setequal(unique(df$month), 4:12)
  })

  test_that("fmtcatch.kumamoto() processes makiami data correctly", {
    path <- "ExcelFiles/test_catch_kumamoto_maki.xls"
    df   <- fmtcatch.kumamoto(path, spcs = "katakuchi", type = "maki")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1989)$catch, 1:9)
    expect_equal(subset(df, year == 1990)$catch, 10:21)
    expect_equal(unique(df$type), "maki")
    expect_setequal(unique(df$month), 1:12)
  })

  test_that("fmtcatch.kumamoto() processes bouukeami data correctly", {
    path <- "ExcelFiles/test_catch_kumamoto_bouuke.xls"
    df   <- fmtcatch.kumamoto(path, spcs = "katakuchi", type = "bouuke")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1993)$catch, 1:7)
    expect_equal(subset(df, year == 1994)$catch, 8:14)
    expect_equal(unique(df$type), "bouuke")
    expect_setequal(unique(df$month), 6:12)
  })

  test_that("fmtcatch.saga() prosesses saga data correctly", {
    path <- "ExcelFiles/test_catch_saga.xls"
    df   <- fmtcatch.saga(path, spcs = "katakuchi", type = "kennai")
    expect_is(df, "data.frame")
    expect_equal(subset(df, year == 1975)$catch, 1:9)
    expect_equal(subset(df, year == 1976)$catch, 10:21)
    expect_equal(unique(df$type), "kennai")
    expect_setequal(unique(df$month), 1:12)
  })

  test_that("fmtcatch.kagoshima() works well", {
    path <- "ExcelFiles/test_catch_kagoshima.xlsx"
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "katakuchi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi", spread = FALSE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = TRUE, maki.only = TRUE),
              "data.frame")
    expect_is(fmtcatch.kagoshima(path, spcs = "maiwashi",
                                 spread = FALSE, maki.only = TRUE),
              "data.frame")
  })

  test_that("format_catch() call fmtcatch() and use method of each prefec", {
    path <- "ExcelFiles/test_catch_kagoshima.xlsx"
    df   <- format_catch(path, prefec = "kagoshima", spcs = "katakuchi")
    expect_is(df, "data.frame")
  })
#+END_SRC
*** テスト/ 長崎漁獲量
#+BEGIN_SRC  R :tangle tests/testthat/test_catch_nagasaki.R
  library(gyokaikyor)
  context("Formating nagasaki catch data")

  test_that("make_hougan() creates vector houganshi", {
    str1 <- rep(1:10, 4) %>%
      replace(which(. %% 3  == 0), NA) %>%
      replace(which(. %% 5  == 0), "foo") %>%
      as.character()
    str2 <- c("いち", "に", "さん", "し",
              NA, "ろく", "なな", "はち", NA, "じゅう")
    str3 <- c("カ", NA, "タ", NA, "ク", NA, "チ", "イ", "ワ", "シ")
    expect_equal(make_hougan(str1), "12 4  78  12 4  78  12 4  78  12 4  78  ")
    expect_equal(make_hougan(str2), " に し      ")
    expect_equal(make_hougan(str3), "カ タ ク チイワシ")
  })

  test_that("ngs_locate_spcsrow(), locates row position", {
    regex <- "カ( |　)*タ( |　)*ク( |　)*チ"
    str1  <- c("カタクチ", NA, "カ タ ク チ", NA, "カ　タ　ク　チ")
    str2  <- c("カ", NA, "タ", NA, "ク", NA, "チ",
               NA, "foo", NA, "カ", "タ", "ク", "チ")
    expect_equal(ngs_locate_spcsrow(regex, str1), c(1, 3, 5))
    expect_equal(ngs_locate_spcsrow(regex, str2), c(1, 11))
  })

  test_that("ngs_get_monthcol() detect month column", {
    df <- tibble::tribble(~A, ~B, ~C, ~D, ~E, ~F, ~G,
                          "foo", "bar", "3月", "baz", "４　月", "bum", "5　月",
                          1, 2, 3, 4, 5, 6, 7,
                          8, 9, 10, 11, 12, 13, 14)
    expect_equal(ngs_get_monthcol(1, df), data.frame(row = c(1, 1),
                 col = c(5, 7)))
    expect_equal(ngs_get_monthcol(2, df), data.frame(row = c(1, 1),
                 col = c(5, 7)))
  })

  test_that("ngs_get_colvalue(), gets values correctly", {
    df <- tibble::tribble(
        ~A, ~B, ~C, ~D, ~E, ~F, ~G, ~H,
        "foo", "bar", "3月", "baz", "４　月", "bum", "5　月", "boo",
        "カタクチイワシ", 2, 3, 4, 5, 6, 7, 8,
        9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24,
        "foo", "bar", "3月", "baz", "４　月", "bum", "5　月", "boo",
        "カタクチイワシ", 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40
      )
    expect_setequal(
      ngs_get_colvalue(regex = "カタクチイワシ", df = df,
                       offset.x = 1, offset.y = 1, xtract.digit = TRUE),
                       c(6, 8, 30, 32))
    expect_setequal(
      ngs_get_colvalue(regex = "カタクチイワシ", df = df,
                       offset.x = 1, offset.y = 2, xtract.digit = TRUE),
                       c(14, 16, 38, 40))
  })

  test_that("ngs_make_yrvec() makes year vector correctly", {
    expect_equal(ngs_make_yrvec("2018.11-2019.03", c(11, 12, 1, 2, 3)),
                 c(rep(2018, 2), rep(2019, 3)))
    expect_equal(ngs_make_yrvec("2019.01-2019.03", c(1, 2, 3)),
                 rep(2019, 3))
  })
#+END_SRC
*** テスト/ 水温データ整形
#+BEGIN_SRC  R :tangle tests/testthat/test_format_temp.R
  context("Format TW sst data")

  test_that("format_temp() loads and format temp data correctly", {
    fname     <- "ExcelFiles/test_sst.xlsx"
    data_2000 <- format_temp(fname, year.end = 2000)
    data_2018 <- format_temp(fname, year.end = 2018)

    expect_equal(tail(data_2000, 1)$year, 2000)
    expect_equal(tail(data_2000, 1)$tw_degc, 606)
    expect_equal(tail(data_2018, 1)$year, 2018)
    expect_equal(tail(data_2018, 1)$tw_degc, 822)
  })
#+END_SRC
*** テスト/ レガシーファイル連携
#+BEGIN_SRC R :tangle tests/testthat/test_conv2legacy.R
  context("Be friendly with legacy files")

  test_that("conv2hoshifile() converts seimitsu data correctly", {
    df     <- read.csv("ExcelFiles/test_conv2hoshifile_seimitsu.csv")
    hoshi  <- conv2hoshifile(df, prefec = "toyama", type = "seimitsu",
                             ym.start = 196901, ym.end = 196912)
    expect_is(hoshi, "data.frame")
    expect_equal(hoshi[, 1], c(1, rep(0, 29)))
    expect_equal(hoshi[, 2], c(0, 1, rep(0, 28)))
  })

  test_that("conv2hoshifile() converts taichou data correctly", {
    df     <- read.csv("ExcelFiles/test_conv2hoshifile_taichou.csv")
    hoshi  <- conv2hoshifile(df, prefec = "nagasaki", type = "taichou",
                             ym.start = 196901, ym.end = 196912,
                             export = TRUE, fname = "foo.csv")
    expect_is(hoshi, "data.frame")
    expect_equal(hoshi[, 1], c(1, rep(0, 29)))
    expect_equal(hoshi[, 2], c(0, 1, rep(0, 28)))
    file.remove("foo.csv")
  })

  test_that("iwashi2list() converts 'kakukeniwashi' file correctly", {
    fname     <- "ExcelFiles/test_kakukeniwashi.xlsx"
    urume     <- iwashi2list(fname, sheet = "ウルメイワシ",
                             year.start = 1992, year.end = 2019)
    maiwashi  <- iwashi2list(fname, sheet = "マイワシ",
                             year.start = 1992, year.end = 2019)
    katakuchi <- iwashi2list(fname, sheet = "カタクチイワシ",
                 year.start = 1992, year.end = 2019)
    expect_equal(urume$山口[1, "Jan"], 1)
    expect_equal(maiwashi$山口[1, "Jan"], 11)
    expect_equal(katakuchi$山口[1, "Jan"], 21)
    expect_equal(urume$鹿児島[1, "Jan"], 51)
    expect_equal(maiwashi$鹿児島[1, "Jan"], 61)
    expect_equal(katakuchi$鹿児島[1, "Jan"], 71)
  })

  test_that("summarize_seikai() and iwashi2df()
   hacks 'kakukeniwashi' file correctly", {
    fname     <- "ExcelFiles/test_kakukeniwashi.xlsx"
    katakuchi <- summarize_seikai(iwashi2list(fname, sheet = "カタクチイワシ",
                 year.start = 1992, year.end = 2019))
    expect_equal(katakuchi[1, "Jan"], 276)
    expect_equal(katakuchi[28, "Jan"], 2220)

    katakuchi_df <- iwashi2df(katakuchi)
    expect_equal(katakuchi_df[1, "catch"], 276)
    expect_equal(katakuchi_df[2, "catch"], 282)
  })

  test_that("export2kakuken_iwashi() converts df to 'iwashi' style", {
    df     <- data.frame(year = c(rep(1969, 12), rep(1970, 12)),
                     month = rep(1:12, 2), catch = 11:34)
    iwashi <- export2kakuken_iwashi(df, export.csv = TRUE, fname = "bar.csv") %>%
      as.data.frame()
    expect_equal(iwashi[1, 2], 11)
    expect_equal(iwashi[2, 2], 23)
    file.remove("bar.csv")
  })

  test_that("make_ymrange() makes proper ym range", {
    ymrange <- make_ymrange(1969, "Mar")
    expect_equal(ymrange$start, 196804)
    expect_equal(ymrange$end, 196903)
    expect_error(make_ymrange(1969, "Jan"), "Unknown month")
  })

  test_that("get_catch() pulls total catch data during fishing period", {
    fname <- "ExcelFiles/test_kakukeniwashi.xlsx"
    l     <- iwashi2list(fname, year.end = 2019, sheet = "カタクチイワシ")
    summarize_seikai(l)
    expect_equal(get_catch(2017, l, "Mar"), c(seq(2022, 2088, by = 6)))
    expect_equal(get_catch(2018, l, "Mar"), c(seq(2094, 2160, by = 6)))
  })

  test_that("make_summary() returns catch summary during fishing period", {
    fname <- "ExcelFiles/test_kakukeniwashi.xlsx"
    l     <- iwashi2list(fname, year.end = 2019, sheet = "カタクチイワシ")
    expect_equal(make_summary(l, 2018, "Mar")$last, 2055)
    expect_equal(make_summary(l, 2018, "Mar")$recent, 1911)
    expect_equal(make_summary(l, 2019, "Mar")$last, 2127)
    expect_equal(make_summary(l, 2019, "Mar")$recent, 1983)
  })
#+END_SRC
*** テスト/ 作図
#+BEGIN_SRC R :tangle tests/testthat/test_plot.R
  context("Drawing figs")

  Sys.unsetenv("R_TESTS")

  test_that("plot_catch_monthvar() draw monthly variation of catch", {
    path <- "ExcelFiles/test_kakukeniwashi.xlsx"
    df   <- iwashi2list(path, sheet = "カタクチイワシ", year.end = 2019) %>%
      summarize_seikai()
    expect_silent(plot_catch_monthvar(df.seikai = df,
                                      year = 2019, gkk.month = "Mar"))
    expect_silent(plot_catch_monthvar(df.seikai = df,
                                      year = 2019, gkk.month = "Mar",
                  fname = "foo.png", family = "Times"))
    file.remove("foo.png")
  })

  test_that("plot_catch_prefec() draw", {
    path <- "ExcelFiles/test_kakukeniwashi.xlsx"
    l    <- iwashi2list(path, sheet = "カタクチイワシ", year.end = 2019)
    expect_silent(plot_catch_prefec(list = l, year = 2019, gkk.month = "Mar"))
    expect_silent(plot_catch_prefec(list = l, year = 2019, gkk.month = "Mar",
                                    fname = "bar.png", family = "Times"))
    file.remove("bar.png")
  })

  test_that("plot_catch_forecast() draw catch forcast", {
    path     <- "ExcelFiles/test_kakukeniwashi.xlsx"
    l        <- iwashi2list(path, sheet = "カタクチイワシ", year.end = 2019)
    df       <- l %>%
      summarize_seikai() %>%
      iwashi2df() %>%
      dplyr::filter(dplyr::between(year, 1992, 1995)) %>%
      dplyr::mutate(logcatch = log(catch))
    ts       <- stats::ts(df, start = 1992, frequency = 12)
    model    <- forecast::Arima(y = ts[, "logcatch"])
    forecast <- forecast::forecast(model)
    expect_silent(plot_forecast(forecast, l, 2019, 3))
  })
#+END_SRC
** 関数
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** インポート
#+BEGIN_SRC  R :tangle R/util.R
  ## quiets concerns of R CMD check re: the .'s that appear in pipelines
  if (getRversion() >= "2.15.1") {
    utils::globalVariables(c(".",
                             "maki4ports", "bou_akune", "bou_uchinoura",
                             "year", "month", "ym", "day",
                             "prefecture", "spcs_code",
                             "scbl", "blclass", "count", "bw",
                             "catch", "list_catchdata",
                             "漁獲年月日", "魚種コード", "県コード",
                             "被鱗体長", "体重",
                             "開始の階級値", "度数", "階級幅",
                             "対馬暖流Ｄ", "tw_degc",
                             "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
  }

  #' @export
  #' @importFrom graphics polygon

  #' @export
  #' @importFrom graphics lines

  #' @export
  #' @importFrom graphics points

  #' @export
  #' @importFrom graphics text

  #' @export
  #' @importFrom graphics arrows

  #' @export
  #' @importFrom graphics plot

  #' @export
  #' @importFrom graphics rect

  #' @export
  #' @importFrom graphics mtext

  #' @export
  #' @importFrom graphics axis

  #' @export
  #' @importFrom grDevices hsv

  #' @export
  #' @importFrom grDevices dev.off
  NULL
#+END_SRC
*** 文字列操作
#+BEGIN_SRC R :tangle R/handle_str.R
  get_row <- function(str, regex, offset = 0) {
    stringr::str_which(str, regex) + offset
  }

  get_col2load   <- function(target, regex, offset) {
    match <- stringr::str_detect(target, regex)
    out <- which(match == TRUE) + offset
    out
  }

  insert_regex <- function(str, regex, prefix = FALSE, option = FALSE) {
    if (option == FALSE) {
      rep <- "+"
    } else {
      rep <- "*"
    }
    if (prefix == TRUE) {
      out <- paste0(regex, rep, substr(str, 1, 1))
    } else {
      out <- substr(str, 1, 1)
    }
    for (i in 2:nchar(str)) {
      out <- paste0(out, regex, rep, substr(str, i, i))
    }
    out
  }

  parse_ym <- function(path) {
    if (stringr::str_detect(path, "/")) {
      fname <- stringr::str_extract(path, "(?<=/)[^/]+$")
    } else {
      fname <- path
    }
    ym_start_match <- stringr::str_match(fname, "(\\d+)\\.((?:0|1)\\d)(?=-)")
    year_start     <- ym_start_match[2] %>% as.numeric()
    month_start    <- ym_start_match[3] %>% as.numeric()
    ym_end_match   <-
      stringr::str_match(fname, "\\d+\\.(?:0|1)\\d-(\\d+)\\.((?:0|1)\\d)")
    year_end       <- ym_end_match[2] %>% as.numeric()
    month_end      <- ym_end_match[3] %>% as.numeric()
    if ( (nchar(year_start) != 4) | (nchar(year_end) != 4))
      stop("Failed parsing to year")
    out <- list()
    out$year_start  <- year_start
    out$month_start <- month_start
    out$year_end    <- year_end
    out$month_end   <- month_end
    out
  }

  xtract_numeric <- function(str) {
    xtract_numerici <- function(str) {
      regex <- "\\D+"
      half <- Nippon::zen2han(str) %>%
        stringr::str_replace(regex, "") %>%
        readr::parse_integer()
      half
    }
    out <- purrr::map_int(str, xtract_numerici)
    out
  }

  abb2num <- function(abb) {
    lambda <- function(abb) {
      which(abb == month.abb)
    }
    purrr::map_int(abb, lambda)
  }

  make_ym <- function(y, m) {
    out <- paste0(y, formatC(m, width = 2, flag = 0)) %>%
      readr::parse_integer()
    out
  }
#+END_SRC

*** 種名シート名生成
#+BEGIN_SRC  R :tangle R/make_shtname.R
  make_shtname <- function(prefecture, spcs) {
    switch(prefecture,
           "kumamoto" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "sabarui"   = shtname <- "サバ類",
                    stop("Unknown spcs name"))

           },
           "nagasaki" = {
             switch(spcs,
                    "katakuchi" = shtname <- "カタクチ",
                    "urume"     = shtname <- "ウルメ",
                    "maiwashi"  = shtname <- "マイワシ",
                    "masaba"    = shtname <- "マサバ",
                    "gomasaba"  = shtname <- "ゴマサバ",
                    "maaji"     = shtname <- "マアジ",
                    stop("Unknown spcs name"))
           },
           "kagoshima" = {
             switch(spcs,
                    "katakuchi" = shtname <- "ｶﾀｸﾁ",
                    "urume"     = shtname <- "ｳﾙﾒ",
                    "maiwashi"  = shtname <- "ﾏｲﾜｼ",
                    "masaba"    = shtname <- "ﾏｻﾊﾞ",
                    "gomasaba"  = shtname <- "ｺﾞﾏｻﾊﾞ",
                    "maaji"     = shtname <- "ﾏｱｼﾞ",
                    stop("Unknown spcs name"))
           },
           stop("Unknown prefecture")
           )
    shtname
  }
#+END_SRC
*** 和暦/西暦変換
#+BEGIN_SRC  R :tangle R/jpyr2ad.R
  jpyr2ad <- function(x, start) {
    conv <- vector(mode = "integer")
    if (start == "showa") {
     suppressMessages(pos_lastyr <- alert_decrease(x))
     x[1:96]
     x[1:97]
     conv[1:pos_lastyr] <- 1925
     conv[1:96]
     conv[1:97]
     conv[(pos_lastyr + 1):length(x)] <- 1988
    } else {
      stop("jpyr2ad")
    }
    ad <- x + conv
    ad
  }

#+END_SRC
*** データ取得
#+BEGIN_SRC R :tangle R/get_data.R
  get_vector <- function(col, row, df, na.rm) {
    out <- dplyr::pull(df, col)[row]
    if (na.rm) {
      out %<>% stats::na.omit() %>%
        as.vector()
    } else {
      out %<>% tidyr::replace_na(0)
    }
    out
  }

  get_measdata <- function(col, df, prefec) {
    switch(prefec,
           "kumamoto" = {
             startrow <- 8
             endrow   <- 107
           },
           stop("Unknown prefecture"))
    out <- get_vector(col, startrow:endrow, df, na.rm = TRUE) %>%
      as.numeric()
    out
  }

  locate_vecend <- function(x) {
    out <- which(!is.na(x)) %>% max()
    out
  }

  get_histdata <- function(col, df, prefec) {
    switch(prefec,
           "nagasaki" = {
             startrow  <- 5
             endrow    <- locate_vecend(df[, col]) - 1
             class_l   <- get_vector(col = cellranger::letter_to_num("B"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             class_r   <- get_vector(col = cellranger::letter_to_num("C"),
                                     startrow:endrow, df = df, na.rm = FALSE)
             blclass   <- make_blclass(class_l, class_r)
           },
           "kagoshima" = {
             startrow <- 9
             endrow   <- stringr::str_which(dplyr::pull(df, 2), "合　計") - 1
             class_start <- df[startrow, 2] %>%
               stringr::str_replace("(?<=\\d\\.\\d)\\D", "") %>%
               stringr::str_replace("( |　)+", "") %>%
               as.double()
             class_end <- df[endrow, 2] %>%
               as.integer()
             left     <- seq(class_start * 10, class_end * 10 + 5, 5)
             blclass  <- make_blclass(left, left + 5)
           },
           stop("Unknown prefecture"))
    count <- get_vector(col, startrow:endrow, df, na.rm = FALSE) %>%
      as.numeric()
    out   <- data.frame(blclass = blclass, count = count) %>%
      dplyr::mutate(blclass = as.character(blclass))
    out
  }
#+END_SRC
*** データ作成
#+BEGIN_SRC R
  coltypes_seimitsu <- list("測定部位コード"     = "i",
                            "生殖腺重量"         = "d",
                            "体長"               = "i",
                            "性"                 = "i",
                            "漁区"               = "i",
                            "統一大海区農林漁区" = "i",
                            "開始緯度"           = "d",
                            "開始経度"           = "d")
  coltypes_taichou <- list("測定部位コード"     = "i",
                           "漁区"               = "i",
                           "統一大海区農林漁区" = "i",
                           "開始緯度"           = "d",
                           "開始経度"           = "d",
                           "船名"               = "c")
  url <- "https://gist.githubusercontent.com/smxshxishxad/47d898c195e611aa9751f7a3d6f9e611/raw/3f07db9c411fae7b65df3c6e29e9529368c43392/prefec_code_eng.csv"
  tmp <- RCurl::getURL(url, ssl.verifypeer = FALSE)
  prefec_code <- read.csv(textConnection(tmp), sep = ",", header = TRUE)

  usethis::use_data(prefec_code,
                    coltypes_taichou,
                    coltypes_seimitsu,
                    internal = TRUE, overwrite = TRUE)
#+END_SRC
*** 体長データ整形
#+BEGIN_SRC R :tangle R/fmtbl.R
  #' Load and format bl histogram data
  #'
  #' @inheritParams readxl::read_excel
  #' @param prefec Name of prefecture as string, oneof
  #' \itemize{
  #'   \item "yamaguchi"
  #'   \item "fukuoka"
  #'   \item "saga"
  #'   \item "nagasaki"
  #'   \item "kumamoto"
  #'   \item "kagoshima"
  #' }
  #' @param spcs Spcs name as string, one of
  #' \itemize{
  #'   \item maiwashi
  #'   \item maaji
  #'   \item sabarui
  #'   \item masaba
  #'   \item gomasaba
  #'   \item katakuchi
  #'   \item urume
  #' }
  #' @param nest If \code{TRUE}, data will be shown in rectangle format
  #'   whith nested bl datafor quick overview.
  #' @export
  format_bl <- function(path, prefec, spcs, nest = FALSE) {
    class(path) <- prefec
    fmtbl(path, spcs, nest)
  }

  fmtbl <- function(path, spcs, nest = FALSE) {
    UseMethod("fmtbl")
  }

  load_alldata <- function(path, sheet) {
    suppressMessages(
      alldata   <- readxl::read_excel(path,
                                      sheet = sheet, col_names = FALSE,
                                      col_types = "text")
    )
  }

  make_blclass <- function(left, right) {
    left %<>% unlist() %>%
      as.vector() %>%
      as.numeric()
    right %<>% unlist() %>%
      as.vector() %>%
      as.numeric()
    out <- paste0("[", left, ",", right, ")")
    out
  }

  jpmonth2num <- function(x) {
    out <- x %>%
      as.vector() %>%
      gsub("\u6708", "", .) %>% # "tsuki" in jp kanji
      as.numeric()
    out
  }

  fmtbl.nagasaki  <- function(path, spcs, nest = TRUE) {

    check_month <- function(months, month_start, month_end) {
      if (!(month_start == months[1]) | (!month_end == rev(months)[1])) {
        # message ("Check month data")
      }
    }

    give_yr2month <- function(mvec, year.start) {
      out           <- list()
      is_yr_changed <- FALSE
      for (i in seq_along(mvec)) {
         m            <- mvec[i]
         out$month[i] <- m
         if (i >= 2) {
           if (m < out$month[i - 1]) {
           is_yr_changed <- TRUE
           }
         }

         if (is_yr_changed) {
           out$year[i] <- year.start + 1
         } else {
           out$year[i] <- year.start
         }
      }
      out
    }

    sheet     <- make_shtname(prefecture = "nagasaki", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    colpos    <- get_col2load(target = alldata[4, ],
                              regex = ".\u6708", # "tsuki" in jp kanji
                              offset = 0)
    months         <- jpmonth2num(alldata[4, colpos])
    histdata       <- purrr::map(colpos, get_histdata, df = alldata,
                            prefec = "nagasaki")
    parsedym       <- parse_ym(path)
    check_month(months, parsedym$month_start, parsedym$month_end)
    year_start     <- parsedym$year_start
    out            <- list()
    out$year       <- give_yr2month(months, year_start)$year
    out$month      <- give_yr2month(months, year_start)$month
    out$prefecture <- "nagasaki"
    out$hist       <- histdata
    out            <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kumamoto  <- function(path, spcs, nest = TRUE) {
    parse_year <- function(path) {
      if ( ( stringr::str_detect(path, "/"))) {
        fname <- stringr::str_match(path, "^.+/(\\d+\\s?【熊本県】.+)")[2]
      } else {
        fname <- path
     }
      match  <- stringr::str_match(fname, "^\\d+\\s?【熊本県】(\\w\\d+)まき")
      wareki <- match[2]
      era    <- stringr::str_sub(wareki, 1, 1)
      jpyr   <- stringr::str_replace(wareki, "^\\w", "")
      year   <- switch(era,
             "H" = paste0("heisei", jpyr, "年") %>%
               Nippon::wareki2AD()
             )

      year
    }
    sheet     <- make_shtname(prefecture = "kumamoto", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[1, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[1, cpos_date] %>%
      purrr::map_chr(tinyplyr::num2date)
    type      <- alldata[1, cpos_date + 4] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_measdata,
                             prefec = "kumamoto", df = alldata)

    out            <- list()
    out$date       <- date
    out$type       <- type
    out$year       <- lubridate::year(out$date)
    out$month      <- lubridate::month(out$date)
    out$scbl       <- bl
    out$prefecture <- "kumamoto"

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  fmtbl.kagoshima <- function(path, spcs, nest = TRUE) {
    sheet     <- make_shtname(prefecture = "kagoshima", spcs = spcs)
    alldata   <- load_alldata(path, sheet)
    cpos_date <- get_col2load(alldata[3, ], regex = "[0-9]+", offset = 0)
    date      <- alldata[3, cpos_date] %>%
      tinyplyr::num2date()
    type      <- alldata[6, cpos_date] %>%
      unlist() %>%
      as.vector()
    bl         <- purrr::map(cpos_date, get_histdata,
                             df = alldata, prefec = "kagoshima")
    out            <- list()
    out$date       <- date
    out$type       <- type
    out$year       <- lubridate::year(out$date)
    out$month      <- lubridate::month(out$date)
    out$bl         <- bl
    out$prefecture <- "kagoshima"

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

  rename_class <- function(left, bin) {
    out <- paste0("[", left, ",", left + bin, ")")
    out
  }

  #' Format bldata exported from FRESCO database
  #'
  #' @param path File path to load
  #' @param type Format of data to load either 'taichou' or 'seimitsu'.
  #' @param date.start The first day of the processed data.
  #' @param date.end The last day of the the processed data
  #' @examples
  #' \dontrun{
  #'   fmtbl_fresco("2019Mar_seikai_taichou_katakuchi.csv", type = "taichou",
  #'                date.start = "20180901", date.end = "20190331")
  #'   fmtbl_fresco("2019Mar_seikai_seimitsu_katakuchi.csv", type = "seimitsu"
  #'                date.start = "20180901", date.end = "20190331")
  #' }
  #' @export
  fmtbl_fresco <- function(path, type, date.start, date.end) {
    detect_bad_data <- function(data) {
      check_date <- function(x) {
        badrow <- which(nchar(data$漁獲年月日) != 8)
        unique(dplyr::pull(data, "県コード")[badrow])
      }
      bad_prefec <- check_date(data)
      if (length(bad_prefec) > 0)
        stop(paste0("Bad date format in prefec code ", bad_prefec))
    }

    dstart <- lubridate::ymd(date.start)
    dend   <- lubridate::ymd(date.end)
    if (type == "seimitsu") {
      suppressMessages(
        data <- readr::read_csv(path, col_types = coltypes_seimitsu)
      )
    } else if (type == "taichou") {
      suppressMessages(
        data <- readr::read_csv(path, col_types = coltypes_taichou)
      )
    }
    detect_bad_data(data)
    out <- data %>%
      dplyr::mutate(date  = lubridate::ymd(漁獲年月日),
                    year  = lubridate::year(date),
                    month = lubridate::month(date),
                    day   = lubridate::day(date),
                    ym    = paste0(year, formatC(month, width = 2, flag = 0)) %>%
                      as.numeric()
                    ) %>%
        dplyr::rename(spcs_code = 魚種コード,
                      prefec_code = 県コード) %>%
        dplyr::left_join(prefec_code, by = c("prefec_code" = "code"))
    if (type == "seimitsu") {
      out %<>%
        dplyr::rename(scbl = 被鱗体長,
                      bw = 体重) %>%
        dplyr::select(date, year, month, day, ym,
                      spcs_code, prefec_code, prefecture, scbl, bw)
    } else if (type == "taichou") {
      out %<>%
        dplyr::rename(blclass = 開始の階級値,
                      count = 度数) %>%
        dplyr::mutate(blclass = ifelse(階級幅 == 0.5,
                                       blclass * 10,
                                ifelse(階級幅 == 5 | 階級幅 == 1,
                                       blclass,
                                       stop("Unknown blclass")))) %>%
        tidyr::drop_na(count) %>%
        dplyr::select(date, year, month, day, ym,
                      spcs_code, prefec_code, prefecture, blclass, count) %>%
        dplyr::mutate(blclass = rename_class(blclass, bin = 5))
    }
    dplyr::filter(out, dplyr::between(date, dstart, dend))
  }
#+END_SRC

*** 漁獲量データ整形
**** 総称関数
#+BEGIN_SRC R :tangle R/fmtcatch.R
  #' Load and format catch data
  #'
  #' @inheritParams readxl::read_excel
  #' @param spcs Spcs name in romaji, one of
  #' \itemize{
  #'   \item "maiwashi"
  #'   \item "maaji"
  #'   \item "sabarui"
  #'   \item "masaba"
  #'   \item "gomasaba"
  #'   \item "katakuchi"
  #'   \item "urume"
  #' }
  #' @param prefec Prefecture name as string, one of
  #' \itemize{
  #'   \item "yamaguchi"
  #'   \item "fukuoka"
  #'   \item "saga"
  #'   \item "nagasaki"
  #'   \item "kumamoto"
  #'   \item "kagoshima"
  #' }
  #' @param type Character value either "maki" or "bouuke" to control
  #'   data processing algorithm for kumamoto data.
  #' @export
  format_catch <- function(path, prefec, spcs, type = NULL) {
    class(path) <- prefec
    fmtcatch(path, spcs, type)
  }

  fmtcatch <- function(path, spcs, type) {
    UseMethod("fmtcatch")
  }

  alert_decrease <- function(x) {
    if (any(diff(x) < 0)) {
      message("There is a decrease in number.")
      which(diff(x) < 0)
    } else {
      x
    }
  }
#+END_SRC
**** 山口
#+BEGIN_SRC R :tangle R/fmtcatch_yamaguchi.R
  #' Load and format catch data of yamaguchi
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "sukui" or "bouuke".
  fmtcatch.yamaguchi <- function(path, spcs, type = NULL) {
    switch(spcs,
           "maaji"    = {
             spcs_col     <- 5
             meigara_ofst <- 1:3
           },
           "sabarui"  = {
             spcs_col     <- 9
             meigara_ofst <- 1:2
           },
           "maiwashi" = {
             spcs_col     <- 12
             meigara_ofst <- 1:3
           },
           "urume"    = {
             spcs_col     <- 21
             meigara_ofst <- 1:3
           },
           "katakuchi" = {
             spcs_col     <- 16
             meigara_ofst <- 1:4
           })

    get_catch_meigara <- function(cofst, spcs_col, sheet) {
      alldata     <- load_alldata(path, sheet = sheet)
      year        <- xtract_numeric(sheet)
      row_jan     <- 5
      rows        <- row_jan:38
      mmatch      <- xtract_numeric(alldata[[1]][rows])
      mrows       <- which(!is.na(mmatch)) + row_jan - 1
      ofst_sukui  <- 1
      ofst_bouuke <- 2
      out         <- NULL
      out$year    <- year
      out$month   <- dplyr::pull(alldata, 1)[mrows] %>%
        xtract_numeric()
      out$sukui   <- col2data(col = spcs_col + cofst,
                        rows = 1:40,
                        row.pick = mrows + ofst_sukui,
                        alldata)
      out$bouuke  <- col2data(col = spcs_col + cofst,
                        rows = 1:40,
                        row.pick = mrows + ofst_bouuke,
                        alldata)
      out$meigara <- alldata[4, spcs_col + cofst] %>%
        unlist() %>% as.vector()
      out$prefecture <- "yamaguchi"
      out %<>% tibble::as_tibble() %>%
        tidyr::gather("sukui", "bouuke", key = "type", value = "catch")
      out
    }

    sheets <- readxl::excel_sheets(path) %>%
      stringr::str_extract("[0-9]+.+") %>%
      stats::na.omit()

    dat1   <- purrr::map_df(meigara_ofst, get_catch_meigara,
                          spcs_col = spcs_col, sheet = sheets[1])
    dat2   <- purrr::map_df(meigara_ofst, get_catch_meigara,
                          spcs_col = spcs_col, sheet = sheets[2])
    out    <- dplyr::bind_rows(dat1, dat2) %>%
      dplyr::mutate(catch = catch / 1000)
    out
  }
#+END_SRC
**** 福岡
#+BEGIN_SRC R :tangle R/fmtcatch_fukuoka.R
  #' Load and format catch data of fukuoka
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "maki" or "bouuke", and "others".
  fmtcatch.fukuoka <- function(path, spcs, type) {
    spcs_jp <- switch(spcs,
                      "maaji"     = "ﾏｱｼﾞ",
                      "maiwashi"  = "ﾏｲﾜｼ",
                      "masaba"    = "ﾏｻﾊﾞ",
                      "gomasaba"  = "ｺﾞﾏｻﾊﾞ",
                      "katakuchi" = "ｶﾀｸﾁ",
                      "urume"     = "ｳﾙﾒ")

    sheet <- switch(type,
                    "maki"   = "まき網 ",
                    "bouuke" = "棒受網",
                    "others" = "その他漁業")
    alldata <- load_alldata(path, sheet)

    ycol     <- 2
    mcol     <- 3
    mstr     <- alldata[[mcol]]
    startrow <- get_row(mstr, "ﾂｷ", offset = 1)
    endrow   <- get_row(mstr, "KEI") %>% max()
    rows     <- startrow:endrow
    datrow   <- stringr::str_count(mstr[rows], "KEI") == 0
    spcs_col <- get_spcscol(alldata, spcs_jp)

    out       <- NULL
    out$year  <- col2data(col = ycol, row = rows,
                          row.pick = datrow, df = alldata) %>%
      jpyr2ad(start = "showa")
    out$month <- col2data(col = mcol, row = rows,
                          row.pick = datrow, df = alldata)
    out$type  <- type
    out$catch <- col2data(col = spcs_col, row = rows,
                          row.pick = datrow, df = alldata) / 1000
    out$prefecture <- "fukuoka"
    tibble::as_tibble(out)
  }

  col2data <- function(col, rows, row.pick, df) {
    out <- df[[col]][rows][row.pick] %>%
      as.numeric()
    out
  }

  get_spcscol <- function(df, spcs_jp) {
    out <- NULL
    for (i in 2:5) {
      str <- df[i, ] %>%
        unlist() %>%
        as.vector()
      out <- stringr::str_which(str, spcs_jp)
      if (length(out) > 0)
        break
    }
    out
  }

#+END_SRC
**** 鹿児島
#+BEGIN_SRC R :tangle R/fmtcatch_kagoshima.R
  fmtcatch.kagoshima <- function(path, spcs, spread = TRUE, maki.only = FALSE) {
    make_year <- function(yr_jp, jpera) {
      out <- paste0(jpera, yr_jp, "\u5E74") %>% # "nen" (year) in jp kanji
        Nippon::wareki2AD()
      out
    }
    get_ym <- function(str) {
      split <- stringr::str_split(str, "\\.")
      out   <- NULL
      jpyr.start  <- split[[1]][1] %>% as.numeric()
      jpyr.end    <- split[[length(str)]][1] %>% as.numeric()
      if (jpyr.end < jpyr.start)
        stop("Japanese era changed! Check algorithm")
      mth.start  <- split[[1]][2] %>% as.numeric()
      mth.end    <- split[[length(str)]][2] %>% as.numeric()
      yr.start   <- make_year(jpyr.start, "heisei")
      yr.end     <- make_year(jpyr.end, "heisei")
      dstart     <- as.Date(paste(yr.start, mth.start, 1, sep = "-"))
      dend       <- as.Date(paste(yr.end, mth.end, 1, sep = "-"))
      dseq       <- seq.Date(dstart, dend, "month")
      out$years  <- stringr::str_sub(dseq, 1, 4) %>%
        readr::parse_integer()
      out$months  <- stringr::str_sub(dseq, 6, 7) %>%
        readr::parse_integer()
      out
    }

    load_catch_4ports <- function(path, spcs) {
      spcs_jp <- switch(spcs,
                        "maaji" = "マアジ",
                        "sabarui" = "サバ類",
                        "maiwashi" = "マイワシ",
                        "urume" = "ウルメイワシ",
                        "katakuchi" = "カタクチイワシ",
                        stop("Unknown spcs"))
      regex    <- insert_regex(spcs_jp, "\u3000", prefix = TRUE)
      data     <- load_alldata(path, sheet = "４港計")
      col_spcs <- which((gregexpr(regex, data[3, ]) > 0) == TRUE) #nolint
      col2load <- col_spcs + 4
      out      <- get_vector(col2load, 5:16, data, na.rm = FALSE) %>%
        readr::parse_number()
      out
    }

    load_catch_bouuke <- function(path, spcs, sheet, unit = "ton") {
      data     <- load_alldata(path, sheet)
      spcs_jp <- switch(spcs,
                        "maaji" = "マアジ",
                        "sabarui" = "サバ類",
                        "maiwashi" = "マイワシ",
                        "urume" = "ウルメ",
                        "katakuchi" = "カタクチ",
                        stop("Unknown spcs"))
      cols_spcs <- which((gregexpr(spcs_jp, data[32, ]) > 0) == TRUE) # nolint
      col_kg    <- cols_spcs[2]
      out       <- get_vector(col_kg, 33:44, data, na.rm = FALSE) %>%
        readr::parse_number()
      if (unit == "ton") {
        out <- out / 1000
      } else if (unit == "kg") {
      } else {
        stop ("Unknown unit.")
      }
      out
    }

    data  <- load_alldata(path, sheet = "\uFF14\u6E2F\u8A08")
                                          # "4koukei" (four port sum) in jp kanji
    str   <- data[5:16, 1] %>%
      unlist() %>%
      as.vector()

    years  <- get_ym(str)$years
    months <- get_ym(str)$months

    catch_4ports        <- load_catch_4ports(path, spcs)
    catch_bou_akune     <- load_catch_bouuke(path, spcs, sheet = "阿久根棒受")
    catch_bou_uchinoura <- load_catch_bouuke(path, spcs, sheet = "内之浦棒受")
    out <- list(year = years,
                month = months,
                maki4ports = catch_4ports,
                bou_akune = catch_bou_akune,
                bou_uchinoura = catch_bou_uchinoura,
                prefecture = "kagoshima") %>%
      tibble::as_tibble() %>%
      tidyr::gather("maki4ports", "bou_akune", "bou_uchinoura",
                    key = "type", value = "catch")
    out
  }
#+END_SRC
**** 長崎
#+BEGIN_SRC R :tangle R/fmtcatch_nagasaki.R
  #' Make vector 'houganshi'
  #'
  #' This function returns vector 'houganshi' to locate the position of
  #'   target word (e.g. species name) in a Excel rows or columns.
  #' To keep correspondence between nubmer of cells and nchar of output string,
  #' This function replaces \code{NA} and a cell value with multiple characters.
  #' @param str String vector with NA or multiple characters
  #' @return Long single string composed of single-word cell and whitespace
  #' @examples
  #' \dontrun{
  #'   str <- rep(1:10, 10) %>%
  #'     replace(which(. %% 3  == 0), NA) %>%
  #'     replace(which(. %% 5  == 0), "foo") %>%
  #'     as.character()
  #'   make_hougan(str)
  #' }
  make_hougan <- function(str) {
    out <- tidyr::replace_na(str, " ")
    out[nchar(out) != 1] <- " "
    out %<>% stringr::str_c(collapse = "")
    out
  }

  #' Locate row position of the cell which contains species name
  #'
  #' This function locates the row position of the cell which contains
  #'   specific species name.
  #' @param regex Regular expression to match the name of the target species.
  #' @param colstr String vector made from a Excel worksheet column.
  #' @return All the row positions where the species name start.
  ngs_locate_spcsrow <- function(regex, colstr) {
    spcs_row <- stringr::str_which(colstr, regex)
    if (length(spcs_row) == 0) {
      spcs_str <- make_hougan(colstr)
      spcs_row <- unlist(gregexpr(regex, spcs_str))
    }
    spcs_row
  }

  #' Detect month column coping with variation in row position of the month cell
  #'
  #' @param row Assumed position of the month cell
  #' @param df Loaded Excel sheet
  #' @return Row-column set of month cells in a given \code{row}
  ngs_get_monthcol <- function(row, df) {
    regex <- "^([０-９]|[0-9])+　+月$"
    col   <- which(gregexpr(regex, df[row, ]) > 0)
    if (length(col) == 0) {
      row <- row - 1
      col <- which(gregexpr(regex, df[row, ]) > 0)
    }
    out   <- data.frame(row = row, col = col)
    out
  }

  #' Get values placed separately in column direction
  #'
  #' This function return values placed separately on the specific fish row
  #'   in column direction.
  #' @inheritParams ngs_locate_spcsrow
  #' @inheritParams ngs_get_monthcol
  #' @param offset.x X-offset of the target value
  #'   from the position of the month cell
  #' @param offset.y Y-offest of the target value
  #'   from the position of the month cell
  #' @param xtract.digit If \code{TRUE}, all characters were deleted so that
  #'   the return value composed only of numerics.
  ngs_get_colvalue <- function(regex, df, offset.x = 0, offset.y = 0,
                            xtract.digit = FALSE) {
    spcs_col <- dplyr::pull(df, 1)
    spcs_row <- ngs_locate_spcsrow(regex, spcs_col)
    rowcol   <- purrr::map_dfr(spcs_row, ngs_get_monthcol, df = df)
    out      <- purrr::map2(rowcol$col + offset.x,
                            rowcol$row + offset.y,
                            get_vector, df = df, na.rm = FALSE) %>%
      purrr::flatten_chr()
    if (xtract.digit) {
      out %<>% xtract_numeric()
    } else {
      out %<>% readr::parse_number()
    }
    out
  }

  #' Make year vectors considering year change
  #'
  #' This function makes year vector from Excel sheet name (\%Y.\%m-\%Y.\%m) and
  #'   month vector. If the month vector contains year change (Dec-Jan),
  #'   year vector returned is composed from two years.
  #' @param sheet Sheet name of Nagasaki catch data (fmt: \%Y.\%m-\%Y.\%m).
  #' @param month Month vector
  #' @examples
  #' \dontrun{
  #'   ngs_make_yrvec(sheet = "2018.09-2019.03",
  #'                  month = c(9, 10, 11, 12, 1, 2, 3))
  #' }
  ngs_make_yrvec <- function(sheet, month) {
    ym  <- parse_ym(sheet)
    out <- rep(ym$year_start, length(month))
    is_yr_changed <- function(month) {
      any (diff(month) < 0)
    }
    if (is_yr_changed(month)) {
      out[(which(month == 1)):length(out)] <- ym$year_start + 1
    }
    out
  }

  #' Get port name from string
  #'
  #' This function returns port name from remarks written in Excel sheet. Port
  #' name with variants are extracted using regular expression and then
  #' converted to four port names written in ascii characters.
  #' @param str Japanes string which contains port name.
  ngs_get_port <- function(str) {
    out   <- NULL
    regex <- "(?<=Ｈ(．|\\.)\\d\\d?(）|\\))?)((長崎|奈留|九十九|小佐々|橘))"
    port  <- stringr::str_extract(str, regex)
    out   <- switch(port,
                    "長崎"   = "nagasaki",
                    "奈留"   = "naru",
                    "九十九" = "kujuku",
                    "小佐々" = "kujuku",
                    "橘"     = "tachibana",
                    stop("Unknown port"))
    out
  }

  #' Load catch data from single Excel sheet and tidy it up
  #'
  #' @inheritParams readxl::read_excel
  #' @inheritParams ngs_get_colvalue
  ngs_fmt_sheet <- function(sheet, path, regex) {
    data   <- load_alldata(path, sheet)
    port   <- ngs_get_port(dplyr::pull(data, 1)[2])
    months <- ngs_get_colvalue(regex, data, xtract.digit = TRUE)
    years  <- ngs_make_yrvec(sheet, months)
    catch  <- ngs_get_colvalue(regex, data, offset.x = 2, offset.y = 5)
    out    <- list(year = years,
                   month = months,
                   port = port,
                   catch = catch,
                   fname = path,
                   sheet = sheet,
                   prefecture = "nagasaki") %>%
      tibble::as_tibble()
    rm(data)
    out
  }

  #' Make catch data reading multiple Excel worksheets
  #'
  #' @inheritParams format_catch
  fmtcatch.nagasaki <- function(path, spcs, type = NULL) {
    spcs_jp <- switch(spcs,
                      "maiwashi" = "マイワシ",
                      "urume" = "ウルメイワシ",
                      "katakuchi" = "カタクチ")
    spcs_regex <- insert_regex(str = spcs_jp, regex = "( |　)",
                               prefix = FALSE, option = TRUE)
    sheets <- readxl::excel_sheets(path)
    out    <- purrr::map(sheets, ngs_fmt_sheet,
                         path = path, regex = spcs_regex) %>%
      dplyr::bind_rows()
    out
  }
#+END_SRC
**** 熊本 & 佐賀
#+BEGIN_SRC R :tangle R/fmtcatch_kumamoto_saga.R
  #' Load catch data of kumamoto and tidy it up
  #'
  #' @param path File path to process
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"sabarui"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value either "maki" or "bouke".
  #'   Data processing algorithm is controled by this parameter.
  fmtcatch.kumamoto <- function(path, spcs, type) {
    sheet   <- switch(spcs,
                      "maaji" = "マアジ",
                      "maiwashi" = "マイワシ",
                      "sabarui" = "サバ類",
                      "katakuchi" = "カタクチイワシ",
                      "urume" = "ウルメイワシ")
    alldata <- load_alldata(path, sheet)
    out     <- get_data(alldata, type, key.start = "年度計", key.end = "前年比")
    out$prefecture <- "kumamoto"
    out
  }
  #' Load catch data of saga and tidy it up
  #'
  #' @inheritParams fmtcatch.kumamoto
  #' @param spcs Romaji spcs name one of
  #' \itemize{
  #'   \item{"maaji"}
  #'   \item{"maiwashi"}
  #'   \item{"masaba"}
  #'   \item{"katakuchi"}
  #'   \item{"urume"}
  #' }
  #' @param type Character value one of
  #' \itemize{
  #'   \item{"karatsu"}
  #'   \item{"kennai"}
  #'   \item{"teichi"}
  #'   \item{"chumaki"}
  #' }
  #'   Data processing algorithm is controled by this parameter.
  fmtcatch.saga <- function(path, spcs, type) {
    spcs_jp <- switch(spcs,
                      "maaji" = "ﾏｱｼﾞ",
                      "maiwashi" = "ﾏｲﾜｼ",
                      "masaba" = "ﾏｻﾊﾞ",
                      "katakuchi" = "ｶﾀｸﾁ",
                      "urume" = "ｳﾙﾒ")
    type_jp <- switch(type,
                      "karatsu" = "（唐津港）",
                      "kennai" = "（唐津港県内船）",
                      "teichi" = "（定置）",
                      "chumaki" = "（中まき）")
    sheets  <- readxl::excel_sheets(path)
    regex   <- paste0(spcs_jp, type_jp)
    sheet   <- sheets[stringr::str_detect(sheets, regex)]
    alldata <- load_alldata(path, sheet)
    out     <- get_data(alldata, type, key.start = "年度", key.end = "平年値")
    out$catch <- out$catch / 1000
    out$prefecture <- "saga"
    out
  }

  get_data <- function(df, type, key.start, key.end) {
    switch(type,
           "maki" = {
             judgecol_start <- 18
             judgecol_end   <- 3
             cols           <- 4:15
             months         <- c(4:12, 1:3)
             yrcol          <- 3
           },
           "bouuke" = {
             judgecol_start <- 13
             judgecol_end   <- 2
             cols           <- 4:10
             months         <- 6:12
             yrcol          <- 3
           }
         , {
             if (!type %in% c("karatsu", "kennai", "teichi", "chumaki"))
               stop("Unknown type")
             judgecol_start <- 1
             judgecol_end   <- 16
             cols           <- 3:14
             months         <- c(4:12, 1:3)
             yrcol          <- 1
           })
    str_judge_start <- dplyr::pull(df, judgecol_start)
    str_judge_end   <- dplyr::pull(df, judgecol_end)
    row_start       <- get_row(str_judge_start, key.start, offset = 1)
    row_end         <- get_row(str_judge_end, key.end, offset = -1)
    rows            <- row_start:row_end
    year            <- dplyr::pull(df, yrcol)[rows] %>%
      as.numeric()
    out             <- NULL
    out             <- df[rows, cols]
    colnames(out)   <- months
    out %<>% dplyr::mutate(year = year,
                           type = type) %>%
      tidyr::gather(-year, -type, key = month, value = "catch") %>%
      dplyr::mutate(year = as.integer(year),
                    month = as.integer(month),
                    catch = as.double(catch)) %>%
      dplyr::select(year, month, type, catch) %>%
      dplyr::mutate(year = ifelse(dplyr::between(month, 1, 3),
                                  year + 1,
                                  year)) %>%
      dplyr::arrange(year, month)
    out
  }
#+END_SRC

*** レガシーファイル形式で書き出し
#+BEGIN_SRC R :tangle R/conv2hoshifile.R
  conv2hoshifile <- function(df, prefec, type, ym.start, ym.end,
                             export = FALSE, fname = NULL,
                             class.start = 10, class.end = 160) {
    make_ymseq <- function(ym.start, ym.end) {
      dseq <- seq.Date(as.Date(lubridate::ymd(paste0(ym.start, "01"))),
                       as.Date(lubridate::ymd(paste0(ym.end, "01"))),
                       "month")
      out <- dseq %>%
        stringr::str_replace("-", "") %>%
        stringr::str_sub(1, 6)
      out
    }

    conv2count <- function(df, prefec, ym.start, ym.end) {
      out <- df %>%
        dplyr::mutate(blclass = cut(scbl, breaks = seq(0, 400, 5),
                      include.lowest = TRUE, right = FALSE)) %>%
        dplyr::group_by(year, month, ym, prefecture, blclass) %>%
        dplyr::summarize(count = length(blclass)) %>%
        dplyr::mutate(blclass = as.character(blclass))
      out
    }

    extract_count_ymclass <- function(ym, class, df.count) {
      y   <- substr(ym, 1, 4) %>% as.numeric()
      m   <- substr(ym, 5, 6) %>% as.numeric()
      out <- df.count %>%
        dplyr::filter(year == y,
                      month == m,
                      blclass == class) %>%
        dplyr::pull(count)
      if (length(out) == 0) {
        out <- 0
      }
      out
    }

    extract_count_class <- function(ym, classes, df.count) {
      out <- purrr::map(classes, extract_count_ymclass,
                 ym = ym, df.count = df.count) %>%
        unlist() %>%
        purrr::set_names(classes)
      out
    }

    extract_count <- function(classes, ymseq, df.count) {
      names(ymseq) <- ymseq
      out <- purrr::map_df(ymseq, extract_count_class,
                           classes = classes, df.count = df.count) %>%
        as.data.frame()
      rownames(out) <- classes
      out
    }

    make_class <- function(min, max, bin) {
      left  <- seq(min, max - bin, bin)
      right <- seq(min + bin, max, bin)
      out   <- paste0("[", left, ",", right, ")")
      out
    }

    classes <- make_class(class.start, class.end, 5)
    ymseq   <- make_ymseq(ym.start, ym.end)

    if (type == "seimitsu") {
      df.count <- df %>%
        dplyr::mutate(ym = paste0(year, formatC(month, width = 2, flag = 0)) %>%
                        as.numeric()) %>%
        conv2count(prefec, ym.start, ym.end) %>%
        dplyr::filter(prefecture == prefec,
                      dplyr::between(ym, ym.start, ym.end))
    } else {
      df.count <- df %>%
        dplyr::mutate(ym = paste0(year, formatC(month, width = 2, flag = 0)) %>%
                        as.numeric()) %>%
        dplyr::filter(prefecture == prefec,
                      dplyr::between(ym, ym.start, ym.end)) %>%
        dplyr::group_by(year, month, ym, blclass) %>%
        dplyr::summarize(count = sum(count))
    }
    out <- extract_count(classes, ymseq, df.count)
    if (export == TRUE) {
      utils::write.csv(out, fname)
    }
    out
  }

  export2kakuken_iwashi <- function(df, export.csv = FALSE, fname = NULL) {
    out <- tibble::tribble(~year,
                           ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`,
                           ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`)
    df2 <- df %>%
      tidyr::spread(key = month, value = catch)
    out %<>% dplyr::right_join(df2)
    if (export.csv == TRUE) {
      utils::write.csv(out, fname, row.names = FALSE)
    }
    out
  }

#+END_SRC

*** 「各県いわし」をRで使いやすい形式に変換
#+BEGIN_SRC R :tangle R/conv2list.R
  get_range <- function(year.end, year.start) {
    year.start <- year.start
    years      <- year.start:year.end
    n.prefec   <- 6
    maxrow     <- (length(years) + 2) * n.prefec + n.prefec - 1 + 2
    paste0("A1:N", maxrow)
  }

  load_iwashi <- function(path, year.end, sheet, year.start = 1992) {
    range   <- get_range(year.end, year.start)
    suppressMessages(
      out <- readxl::read_xlsx(path,
                                   sheet = sheet, skip = 2,
                                   col_names = FALSE, range = range))
    as.data.frame(out)
  }

  parse_num_vec <- function(col, df, to) {
    vec <- as.character(df[, col])
    out <- vec %>%
      tidyr::replace_na(0)
    if (to == "integer") {
      out %<>% readr::parse_integer()
    }
    if (to == "double") {
      out %<>% readr::parse_double()
    }
    out
  }

  parse_num_df <- function(cols, df, to) {
    out <- purrr::map_dfc(cols, parse_num_vec, df = df, to = to)
    out
  }


  get_prefec_rows <- function(str) {
    stringr::str_which(str, "県")
  }

  make_list <- function(row.prefec, df.iwashi, year.end, year.start = 1992){
    years       <- year.start:year.end
    prefec_name <- stringr::str_replace(df.iwashi[row.prefec, 1], "県.+", "")
    row_start   <- row.prefec + 2
    row_end     <- row_start + length(years) - 1
    data_prefec <- df.iwashi[row_start:row_end, ] %>%
      parse_num_df(2:13, ., "double") %>%
      magrittr::set_colnames(month.abb)
    year        <- df.iwashi[row_start:row_end, 1] %>%
      stringr::str_replace("年", "") %>%
      readr::parse_integer()
    out         <- NULL
    out$df      <- cbind(year, data_prefec)
    names(out)  <- prefec_name
    out
  }

  summarize_seikai <- function(list) {
    get_month <- function(prefec, month, list) {
      list[[prefec]][month.abb[month]]
    }
    sum_month <- function(month, list, prefecs) {
      purrr::map(prefecs, get_month, month = month, list) %>%
        purrr::flatten() %>%
        Reduce(`+`, .)
    }
    prefecs <- names(list)
    year    <- list[[1]]$year
    out     <- purrr::map_dfc(1:12, sum_month, list, prefecs) %>%
      purrr::set_names(month.abb)
    out <- cbind(year, out)
    out
  }

  iwashi2list <- function(path, sheet, year.start = 1992, year.end) {
    df          <- load_iwashi(path = path, year.end = year.end,
                    sheet = sheet, year.start = year.start)
    prefec_rows <- get_prefec_rows(dplyr::pull(df, 1))
    out <- purrr::map(prefec_rows, make_list, df.iwashi = df,
                      year.end = year.end) %>%
      purrr::flatten()
    out
  }

  iwashi2df <- function(x) {
    out <- x %>%
      tidyr::gather(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec,
                    key = month, value = catch) %>%
      dplyr::mutate(month = abb2num(month),
                    ym    = make_ym(year, month)) %>%
      dplyr::arrange(ym)
    out
  }

  make_ymrange <- function(year, gkk.month) {
    out <- NULL
    switch(gkk.month,
           "Mar" = {
             mstart <- 4
             mend   <- 3
           },
           "Oct" = {
           },
           stop("Unknown month"))
    out$start <- paste0(year - 1, formatC(mstart, width = 2, flag = 0)) %>%
      as.numeric()
    out$end   <- paste0(year, formatC(mend, width = 2, flag = 0)) %>%
      as.numeric()
    out
  }
#+END_SRC
*** 漁獲量データ操作
#+BEGIN_SRC R :tangle R/handle_catchdata.R
  get_catch <- function(year, list_catchdata, gkk.month) {
    range <- make_ymrange(year, gkk.month)
    df    <- list_catchdata %>%
      summarize_seikai() %>%
      iwashi2df()
    out <- NULL
    out <- df %>%
      dplyr::filter(dplyr::between(ym, range$start, range$end)) %>%
      dplyr::pull(catch)
    out
  }

  make_summary <- function(list_catchdata, year, gkk.month) {
    recentyr <- (year - 5):(year - 1)
    out            <- NULL
    out$last       <- get_catch(year - 1, list_catchdata, gkk.month)
    out$last_upr   <- out$last * 1.2
    out$last_lwr   <- out$last * 0.8
    out$recent     <- purrr::map_dfc(recentyr, get_catch,
                                     list_catchdata, gkk.month) %>%
      rowMeans()
    out$recent_upr <- out$recent * 1.2
    out$recent_lwr <- out$recent * 0.8
    out            <- sapply(out, mean)
    suppressWarnings(
      out$range_last <- make_ymrange(year - 1, gkk.month))
    out
  }

#+END_SRC
*** 水温データを整理
#+BEGIN_SRC R :tangle R/format_temp.R
  format_temp <- function(fname, year.end) {
    year.start <- 1953
    nrows      <- (year.end - year.start + 1) * 12
    range2read <- paste0("A1:F", nrows + 1)
    xldata <- suppressMessages(readxl::read_xlsx(fname,
                                sheet = "三旬平均実測値",
                                range = range2read)) %>%
      dplyr::mutate(tw_degc = 対馬暖流Ｄ,
                    year    = 0,
                    month   = 0)

    for (i in 1:nrows){
      xldata[i, "year"]  <-
        as.numeric(Nippon::zen2han(gsub("年", "", xldata[i, 1])))
      xldata[i, "month"] <-
        as.numeric(Nippon::zen2han(gsub("月", "", xldata[i, 2])))
    }

    sst_tw <- xldata %>%
      dplyr::select(year, month, tw_degc) %>%
      dplyr::mutate(year  = as.integer(year),
                    month = as.integer(month))
    sst_tw
  }
#+END_SRC
*** 作図
#+BEGIN_SRC R :tangle R/plot.R
  plot_catch_monthvar <- function(df.seikai, year, gkk.month,
                                  fname = NULL, family = NULL) {
    get_mvar  <- function(year, gkk.month, df.seikai) {
      out      <- NULL
      ym.start <- make_ymrange(year, gkk.month)$start
      ym.end   <- make_ymrange(year, gkk.month)$end
      out      <- iwashi2df(df.seikai) %>%
        dplyr::filter(dplyr::between(ym,
                                     ym.start,
                                     ym.end)) %>%
        dplyr::arrange(ym) %>%
        dplyr::pull(catch)
      out
    }

    draw_catch <- function(l, var, year) {
      catch <- l[[var]]
      ofst  <- 0.5
      switch(var,
             "recent" = {
               polygon(c(1:12, 12:1), c(catch * 0.8, rev(catch * 1.2)),
                       col = hsv(0, 0, 0.8), border = FALSE)
               lines(1:12, catch)
               points(1:12, catch, pch = 16)
               text(12, catch[12], "平年±20%", pos = 4, offset = ofst,
                    xpd = TRUE)
             },
             "last" = {
               col <- hsv(200 / 360, 0.8, 0.8)
               lines(1:12, catch, col = col)
               points(1:12, catch, col = col, pch = 16)
               arrows(1:12, catch * 0.8, 1:12, catch * 1.2,
                      col = col, length = 0)
               text(12, catch[12], "前年±20%",
                    col = col, pos = 4, offset = ofst, xpd = TRUE)
             },
             "this" = {
               catch <- catch[1:11]
               col <- hsv(0 / 360, 0.8, 0.8)
               lines(1:11, catch, col = col)
               points(1:11, catch, col = col, pch = 16, cex = 1.3)
               points(1:11, catch, col = "white", pch = 16, cex = 0.9)
               text(11, catch[11], paste0(year - 1, "年度"), cex = 1.5,
                    col = col, pos = 4, offset = ofst, xpd = TRUE)
             })
    }

    init_plot <- function(l, gkk.month) {
      max <- l$max
      min <- l$min
      plot(1, 1, xlim = c(1, 13.5), ylim = c(min, max * 1.2), type = "n",
           axes = FALSE, ann = FALSE, yaxs = "i")
      switch(gkk.month,
             "Mar" = {
               rect(7.8, -10, 12.2, max * 1.1, col = hsv(20 / 360, 0.2, 1),
                           border = FALSE)
               text(10, max, "漁期", col = hsv(20 / 360, 0.5, 0.85), cex = 1.5)
               axis(1, at = 1:12, labels = FALSE)
               axis(1, at = 1:12, pos = 0.06, las = 2,
                    labels = month.abb[c(4:12, 1:3)], col = "transparent")
             })
    }

    draw_axes <- function(l) {
      axis(2, at = l$min:l$max, labels = FALSE)
      axis(2, at = l$min:l$max, pos = 0.6, col = "transparent")
      mtext("漁獲量 (千トン)", side = 2, line = 2, cex = 1.2)
    }

    lastyr   <- year - 1
    recentyr <- (year - 4):year
    l        <- list()
    l$this   <- get_mvar(year, "Mar", df.seikai) / 1000
    l$last   <- get_mvar(lastyr, "Mar", df.seikai) / 1000
    l$recent <- purrr::map_dfc(recentyr, get_mvar, "Mar", df.seikai) %>%
      rowMeans() / 1000
    max      <- max(unlist(l)) * 1.2
    min      <- min(unlist(l)) * 0.8
    l$max    <- max
    l$min    <- min

    if (!is.null(fname)) {
      grDevices::png(filename = fname, width = 1200, height = 800, res = 190)
      graphics::par(mai = c(0.5, 0.7, 0.1, 0.1), family = family)
    }

    init_plot(l, gkk.month)
    draw_catch(l, var = "recent", year)
    draw_catch(l, var = "last", year)
    draw_catch(l, var = "this", year)
    draw_axes(l)

    if (!is.null(fname)) {
      dev.off()
    }
  }

  plot_catch_prefec <- function(list, year, gkk.month,
                                fname = NULL, family = NULL) {
    get_ysum <- function(yr, prefec, gkk.month, list) {
      switch(gkk.month,
             "Mar" = {
               ym.start <- paste0(yr - 1, "11") %>% as.numeric()
               ym.end   <- paste0(yr, "01") %>% as.numeric()
             })
      out <- list[[prefec]] %>%
        iwashi2df() %>%
        dplyr::filter(dplyr::between(ym, ym.start, ym.end)) %>%
        dplyr::select(catch) %>%
        sum(na.rm = TRUE)
      out
    }

    get_prefec_catch <- function(prefec, yr, gkk.month, list) {
      lastyr     <- yr - 1
      recentyr   <- (yr - 5):(yr - 1)
      out        <- NULL
      out$this   <- get_ysum(yr, prefec, gkk.month, list)
      out$last   <- get_ysum(lastyr, prefec, gkk.month, list)
      out$recent <- purrr::map(recentyr, get_ysum, prefec, gkk.month, list) %>%
        unlist() %>%
        mean(na.rm = TRUE)
      out
    }

    plot_init <- function(sums) {
      max <- max(unlist(sums), na.rm = TRUE) / 1000
      min <- min(unlist(sums), na.rm = TRUE) / 1000
      prefecs <- names(sums)
      plot(1, 1, xlim = c(0.5, 7.1), ylim = c(0, max * 1.2),
           type = "n", yaxs = "i",
           axes = FALSE, ann = FALSE)
      axis(1, at = c(1:6, 7), labels = FALSE)
      axis(1, at = c(1:6, 7), labels = prefecs, pos = 0.2, col = "transparent")
      axis(2, at = seq(0, ceiling(max * 1.2), 1), labels = FALSE)
      axis(2, at = seq(0, ceiling(max * 1.2), 1), pos = 0.3, col = "transparent")
      mtext("漁獲量（千トン）", 2, line = 2, cex = 1.2)
      rect(0.7, 1.6, 3.3, max * 1.2, col = hsv(0, 0, 1), xpd = TRUE)
      x1 <- 1.52
      x2 <- 2
      y1 <- 2.3
      y2 <- 2.6
      draw_point(1, 2.8, "recent", xright = 1.5)
      lines(c(x1, x2), c(y1, y2))
      draw_point(x1, y1, "last")
      draw_point(x2, y2, "this")
      text(1.5, max, "平年±20%", col = hsv(0, 0, 0.2),
           pos = 4, offset = 1)
      text(x1, y1, "前年±20%", col = hsv(200 / 360, 0.8, 0.8),
           pos = 4, offset = 2)
      text(x2, y2, "今期", col = hsv(0, 0.8, 0.8),
           pos = 4, offset = 2)
    }

    draw_point <- function(x, y, type, xright = NULL) {
      switch(type,
             "recent" = {
               rect(x, y * 0.8, xright, y * 1.2, col = hsv(0, 0, 0.8))
               lines(c(x, xright), c(y, y), lwd = 2)

             },
             "last" = {
               arrows(x, y * 0.8, x, y * 1.2, length = 0, xpd = TRUE,
                      col = hsv(200 / 360, 0.8, 0.8), lwd = 1.5)
               points(x, y, pch = 16, col = hsv(200 / 360, 0.8, 0.8),
                      cex = 1.5, xpd = TRUE)
             },
             "this" = {
               points(x, y, pch = 16, col = hsv(0, 0.8, 0.8),
                      cex = 2, xpd = TRUE)
               points(x, y, pch = 16, col = "white", cex = 1.5, xpd = TRUE)
             })
    }

    plot_prefec <- function(prefec, sums) {
      pdata <- sums[[prefec]]
      prefecs <- names(sums)
      x       <- which(prefec == prefecs)
      this <- pdata$this / 1000
      last <- pdata$last / 1000
      recent <- pdata$recent / 1000

      x_this <- x + 0.3
      x_last <- x + 0.1
      lrecent <- x - 0.2
      rrecent <- x_last

      draw_point(x = lrecent, y = recent,
                 xright = rrecent, type = "recent")
      lines(c(x_last, x_this), c(last, this), lwd = 2)
      draw_point(x_last, last, "last")
      draw_point(x_this, this, "this")
    }

    make_sums <- function(sums, which) {
      out <- NULL
      for (i in seq_along(sums)) {
        out <- append(out, sums[[i]][which])
      }
      out %<>% unlist %>%
        sum(na.rm = TRUE)
      out
    }

    prefecs <- names(list)
    sums <- purrr::map(prefecs, get_prefec_catch, 2019, "Mar", list) %>%
      purrr::set_names(prefecs)
    sum_this <- make_sums(sums, "this")
    sum_last <- make_sums(sums, "last")
    sum_recent <- make_sums(sums, "recent")
    sums$計$this <- sum_this
    sums$計$last <- sum_last
    sums$計$recent <- sum_recent
    sums

    if (!is.null(fname)) {
      grDevices::png(filename = fname, width = 1200, height = 800, res = 190)
      graphics::par(mai = c(0.5, 0.7, 0.1, 0.1), family = family)
    }

    plot_init(sums)
    plot_prefec("山口", sums)
    plot_prefec("福岡", sums)
    plot_prefec("佐賀", sums)
    plot_prefec("長崎", sums)
    plot_prefec("熊本", sums)
    plot_prefec("鹿児島", sums)
    plot_prefec("鹿児島", sums)
    plot_prefec("計", sums)

    if (!is.null(fname)) {
      dev.off()
    }
  }

  plot_forecast <- function(forecast, list.catchdata, yr, month.until) {
    plot_rects <- function(summary, yr) {
      years <- (yr - 5):(yr - 1)
      for (y in years) {
        rect(y + (4 - 1) / 12, summary$recent_lwr / 1000,
             y + (9 - 1) / 12, summary$recent_upr / 1000,
             col = hsv(0, 0, 0.8, 0.8), border = FALSE)
      }
      rect(yr + (4 - 1) / 12 + 0.05, summary$last_lwr / 1000,
           yr + (9 - 1) / 12 + 0.05, summary$last_upr / 1000,
           col = hsv(200 / 360, 0.8, 0.8, 0.4), border = FALSE)
    }

    plot_lines <- function(forecast, summary, yr) {
      years <- (yr - 5):(yr - 1)
      pred  <- mean(exp(forecast$mean[4:9])) / 1000
      for (y in years) {
        lines(c(y + (4 - 1) / 12, y + (9 - 1) / 12),
              c(summary$recent / 1000, summary$recent / 1000),
              col = hsv(0, 0, 0.2), lwd = 4)
      }
      lines(c(yr + (4 - 1) / 12 + 0.05, yr + (9 - 1) / 12 + 0.05),
            c(summary$last / 1000, summary$last / 1000),
            col = hsv(200 / 360, 1, 0.8), lwd = 4)
      lines(c(yr + 1 + (4 - 1) / 12 + 0.05, yr + 1 + (9 - 1) / 12 + 0.05),
            c(pred, pred),
            col = hsv(0 / 360, 0.8, 0.8), lwd = 4)
      text(yr + 1.8, pred, "予測平均値", pos = 4,
           col = hsv(0, 0.8, 0.8), cex = 3, xpd = TRUE)
    }

    plot_texts <- function(forecast, yr, summary) {
      text(yr + 1, forecast$upper[12, "80%"], "80%予測区間",
           pos = 4, xpd = TRUE,
           col = hsv(230 / 360, 0.14, 0.7), cex = 3)
      text(yr + 1, forecast$upper[12, "95%"], "95%予測区間",
           pos = 4, xpd = TRUE,
           col = hsv(230 / 360, 0.02, 0.7), cex = 3)
      rect(yr - 1.1, summary$last_lwr / 1000,
           yr + 0.1, summary$last_lwr / 1000 - 0.5,
           col = hsv(0, 0, 1, 0.7), border = FALSE)
      text(yr - 0.5, summary$last_lwr / 1000, "前年±20%",
           pos = 1, col = hsv(200 / 360, 0.8, 0.8),
           cex = 3)
      rect(yr - 3.1, summary$recent_lwr / 1000,
           yr - 1.9, summary$recent_lwr / 1000 - 0.5,
           col = hsv(0, 0, 1, 0.7), border = FALSE)
      text(yr - 2.5, summary$recent_lwr / 1000, "平年±20%",
           pos = 1, cex = 3)
    }

    real <- summarize_seikai(list.catchdata) %>%
      iwashi2df() %>%
      dplyr::arrange(ym) %>%
      dplyr::filter(dplyr::between(ym,
                     make_ym(yr, 1),
                     make_ym(yr, 12))) %>%
      dplyr::select(catch)

    real2 <- real[1:month.until, ] %>%
      stats::ts(start = c(yr, 1), frequency = 12) / 1000

    forecast_org   <- forecast
    forecast$x     <- exp(forecast$x) / 1000
    forecast$mean  <- exp(forecast$mean) / 1000
    forecast$lower <- exp(forecast$lower) / 1000
    forecast$upper <- exp(forecast$upper) / 1000
    summary     <- make_summary(list.catchdata, 2019, "Mar")
    max         <- ceiling(max(forecast$upper))
    plot(forecast, main = "",
         axes = FALSE, ann = FALSE, yaxs = "i",
         xlim = c(yr - 6, yr + 1.5), ylim = c(0, max),
         lwd = 3)
    plot_rects(summary, yr - 1)
    plot_lines(forecast_org, summary, yr - 1)
    plot_texts(forecast, yr, summary)
    mtext("年", 1, cex = 5, line = 7)
    mtext("漁獲量（千トン）", 2, cex = 5, line = 5)
    axis(1, at = seq(yr - 6, yr + 1, 1), cex.axis = 3, labels = FALSE)
    axis(1, at = seq(yr - 6, yr + 1, 1), cex.axis = 3,
         pos = -0.2, col = "transparent", srt = 30)
    axis(2, at = seq(0, max, 2), cex.axis = 3, pos = yr - 6.3)
  }
#+END_SRC
